/*! For license information please see solclient-debug.js.LICENSE.txt */
(() => {
    var __webpack_modules__ = {
        "./index.js": (module, __unused_webpack_exports, __webpack_require__) => {
            module.exports = __webpack_require__("./modules/solclient-core/api.js");
        },
        "./modules/solclient-convert/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Base64
            } = __webpack_require__("./modules/solclient-convert/lib/base64.js");
            const {
                Bits
            } = __webpack_require__("./modules/solclient-convert/lib/bits.js");
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/lib/convert.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/lib/hex.js");
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/lib/long.js");
            module.exports.Base64 = Base64;
            module.exports.Bits = Bits;
            module.exports.Convert = Convert;
            module.exports.Hex = Hex;
            module.exports.Long = Long;
        },
        "./modules/solclient-convert/lib/base64.js": module => {
            const KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            const ENC_LUT = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 99, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ];
            class DecodeError extends Error {}
            const LegacyEncoder = {
                base64_encode(input) {
                    let output = "";
                    let i = 0;
                    do {
                        const chr1 = input.charCodeAt(i++);
                        const chr2 = input.charCodeAt(i++);
                        const chr3 = input.charCodeAt(i++);
                        const enc1 = chr1 >> 2;
                        const enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                        let enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                        let enc4 = chr3 & 63;
                        if (isNaN(chr2)) {
                            enc3 = enc4 = 64;
                        } else if (isNaN(chr3)) {
                            enc4 = 64;
                        }
                        output += KEY_STR.charAt(enc1);
                        output += KEY_STR.charAt(enc2);
                        output += KEY_STR.charAt(enc3);
                        output += KEY_STR.charAt(enc4);
                    } while (i < input.length);
                    return output;
                },
                base64_decode(input) {
                    let output = "";
                    let i = 0;
                    do {
                        while (ENC_LUT[input.charCodeAt(i)] > 64) {
                            i++;
                        }
                        const enc1 = ENC_LUT[input.charCodeAt(i++)];
                        const enc2 = ENC_LUT[input.charCodeAt(i++)];
                        const enc3 = ENC_LUT[input.charCodeAt(i++)];
                        const enc4 = ENC_LUT[input.charCodeAt(i++)];
                        if (enc1 < 0 || enc2 < 0 || enc3 < 0 || enc4 < 0) {
                            throw new DecodeError("Invalid base64 character");
                        }
                        const chr1 = enc1 << 2 | enc2 >> 4;
                        const chr2 = (enc2 & 15) << 4 | enc3 >> 2;
                        const chr3 = (enc3 & 3) << 6 | enc4;
                        output += String.fromCharCode(chr1);
                        if (enc3 !== 64) {
                            output += String.fromCharCode(chr2);
                        }
                        if (enc4 !== 64) {
                            output += String.fromCharCode(chr3);
                        }
                    } while (i < input.length - 3);
                    return output;
                }
            };
            const isNode = typeof window === "undefined";
            const hasBuffer = typeof Buffer !== "undefined";
            const hasBlob = typeof Blob !== "undefined";
            const BufferEncoder = hasBuffer && (hasBlob || isNode) ? {
                base64_encode: str => Buffer.from(str, "binary").toString("base64"),
                base64_decode: str => Buffer.from(str, "base64").toString("binary")
            } : {};
            const WindowEncoder = typeof window !== "undefined" ? {
                base64_encode: window["btoa"] ? b => window["btoa"](b) : null,
                base64_decode: window["atob"] ? a => window["atob"](a) : null
            } : {};
            const Base64 = {
                encode: WindowEncoder.base64_encode || BufferEncoder.base64_encode || LegacyEncoder.base64_encode,
                decode: WindowEncoder.base64_decode || BufferEncoder.base64_decode || LegacyEncoder.base64_decode
            };
            module.exports.Base64 = Base64;
        },
        "./modules/solclient-convert/lib/bits.js": module => {
            const Bits = {
                get(val, shift, numBits) {
                    return val >>> shift & (1 << numBits) - 1;
                },
                set(dataIn, val, shift, numBits) {
                    const curMask = (1 << numBits) - 1;
                    const shiftedVal = (val & curMask) << shift;
                    const data = dataIn & ~(curMask << shift);
                    return data | shiftedVal;
                }
            };
            module.exports.Bits = Bits;
        },
        "./modules/solclient-convert/lib/convert.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const Long = __webpack_require__("./node_modules/long/umd/index.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const BufferImpl = __webpack_require__("buffer").Buffer;
            const TWO_ZEROES_STR = String.fromCharCode(0, 0);
            const THREE_ZEROES_STR = String.fromCharCode(0, 0, 0);
            const FOUR_ZEROES_STR = String.fromCharCode(0, 0, 0, 0);
            const BYTEARRAY_CONVERT_CHUNK = 8192;
            const UNSIGNED_LSHIFT_24 = 256 * 256 * 256;
            const ARRAY_BUFFER_CONVERT_CHUNK = 32768;
            function stringToUint8Array(data) {
                const dataLength = data.length;
                const arrayBuf = new ArrayBuffer(dataLength);
                const uint8Array = new Uint8Array(arrayBuf, 0, dataLength);
                for (let i = 0; i < dataLength; i++) {
                    uint8Array[i] = data.charCodeAt(i);
                }
                return uint8Array;
            }
            function arrayBufferToString(ab) {
                if (!ab) return "";
                const len = ab.byteLength;
                const u8 = new Uint8Array(ab);
                if (len < ARRAY_BUFFER_CONVERT_CHUNK) {
                    return String.fromCharCode.apply(null, u8);
                }
                let k = 0;
                let r = "";
                while (k < len) {
                    r += String.fromCharCode.apply(null, u8.subarray(k, k + ARRAY_BUFFER_CONVERT_CHUNK));
                    k += ARRAY_BUFFER_CONVERT_CHUNK;
                }
                return r;
            }
            function stringToArrayBuffer(str) {
                return stringToUint8Array(str).buffer;
            }
            function int8ToStr(int8) {
                return String.fromCharCode(int8 & 255);
            }
            function int16ToStr(int16) {
                return String.fromCharCode(int16 >> 8 & 255) + String.fromCharCode(int16 & 255);
            }
            function int24ToStr(int24) {
                return String.fromCharCode(int24 >> 16 & 255) + String.fromCharCode(int24 >> 8 & 255) + String.fromCharCode(int24 & 255);
            }
            function int32ToStr(int32) {
                if (int32 === 0) return FOUR_ZEROES_STR;
                if (int32 > 0) {
                    if (int32 < 256) {
                        return THREE_ZEROES_STR + String.fromCharCode(int32);
                    }
                    if (int32 < 65536) {
                        return TWO_ZEROES_STR + String.fromCharCode(int32 >> 8) + String.fromCharCode(int32 & 255);
                    }
                }
                return String.fromCharCode(int32 >> 24 & 255) + String.fromCharCode(int32 >> 16 & 255) + String.fromCharCode(int32 >> 8 & 255) + String.fromCharCode(int32 & 255);
            }
            function int64ToStr(int64) {
                if (typeof int64 !== "number") {
                    return int32ToStr(int64.high) + int32ToStr(int64.low);
                }
                if (int64 >= 0) {
                    if (int64 < 256) {
                        return FOUR_ZEROES_STR + THREE_ZEROES_STR + String.fromCharCode(int64);
                    }
                    if (int64 < 65536) {
                        return FOUR_ZEROES_STR + TWO_ZEROES_STR + String.fromCharCode(int64 >> 8) + String.fromCharCode(int64 & 255);
                    }
                    if (int64 < 4294967296) {
                        return FOUR_ZEROES_STR + (String.fromCharCode(int64 >> 24 & 255) + String.fromCharCode(int64 >> 16 & 255) + String.fromCharCode(int64 >> 8 & 255) + String.fromCharCode(int64 & 255));
                    }
                }
                return String.fromCharCode(int64 >> 56 & 255) + String.fromCharCode(int64 >> 48 & 255) + String.fromCharCode(int64 >> 40 & 255) + String.fromCharCode(int64 >> 32 & 255) + String.fromCharCode(int64 >> 24 & 255) + String.fromCharCode(int64 >> 16 & 255) + String.fromCharCode(int64 >> 8 & 255) + String.fromCharCode(int64 & 255);
            }
            function byteArrayToStr(byteArray) {
                const len = byteArray.length;
                if (len < BYTEARRAY_CONVERT_CHUNK) {
                    return String.fromCharCode.apply(null, byteArray);
                }
                let k = 0;
                let r = "";
                while (k < len) {
                    r += String.fromCharCode.apply(null, byteArray.slice(k, k + BYTEARRAY_CONVERT_CHUNK));
                    k += BYTEARRAY_CONVERT_CHUNK;
                }
                return r;
            }
            function strToByteArray(str) {
                const result = [];
                let i;
                for (i = 0; i < str.length; i++) {
                    result[i] = str.charCodeAt(i);
                }
                return result;
            }
            function strToHexArray(str) {
                function toHex(c) {
                    return c.charCodeAt(0).toString(16);
                }
                return Array.prototype.map.call(str.split(""), toHex);
            }
            function strToInt8(data) {
                return data.charCodeAt(0) & 255;
            }
            function strToInt16(data) {
                return (data.charCodeAt(0) << 8) + data.charCodeAt(1);
            }
            function strToInt24(data) {
                return (data.charCodeAt(0) << 16) + (data.charCodeAt(1) << 8) + data.charCodeAt(2);
            }
            function strToInt32(data) {
                return (data.charCodeAt(0) << 24) + (data.charCodeAt(1) << 16) + (data.charCodeAt(2) << 8) + data.charCodeAt(3);
            }
            function strToUInt32(data) {
                return data.charCodeAt(0) * UNSIGNED_LSHIFT_24 + (data.charCodeAt(1) << 16) + (data.charCodeAt(2) << 8) + data.charCodeAt(3);
            }
            function strToUInt64(data) {
                return Long.fromBits(strToUInt32(data.substr(4, 4)), strToUInt32(data.substr(0, 4)), true);
            }
            function ucs2ToUtf8(ucs2) {
                return unescape(encodeURIComponent(ucs2));
            }
            function utf8ToUcs2(utf8) {
                return decodeURIComponent(escape(utf8));
            }
            function anythingToBuffer(value) {
                if (BufferImpl.isBuffer(value)) {
                    return value;
                }
                if (typeof value === "string") {
                    return BufferImpl.from(value, "latin1");
                }
                if (value instanceof ArrayBuffer) {
                    return BufferImpl.from(value);
                }
                if (value.buffer instanceof ArrayBuffer && typeof value.byteLength === "number" && typeof value.byteOffset === "number") {
                    if (value.byteOffset === 0 && value.byteLength === value.buffer.byteLength) {
                        return BufferImpl.from(value.buffer);
                    }
                    return BufferImpl.from(value.buffer, value.byteOffset, value.byteLength);
                }
                throw new OperationError("Parameter value failed validation", ErrorSubcode.PARAMETER_OUT_OF_RANGE, "Expecting Buffer/Uint8Array, also accepting string, ArrayBuffer, any TypedArray, or DataView.");
            }
            const Convert = {
                arrayBufferToString: arrayBufferToString,
                stringToArrayBuffer: stringToArrayBuffer,
                stringToUint8Array: stringToUint8Array,
                int8ToStr: int8ToStr,
                strToInt8: strToInt8,
                int16ToStr: int16ToStr,
                strToInt16: strToInt16,
                int24ToStr: int24ToStr,
                strToInt24: strToInt24,
                int32ToStr: int32ToStr,
                strToInt32: strToInt32,
                strToUInt32: strToUInt32,
                int64ToStr: int64ToStr,
                strToUInt64: strToUInt64,
                byteArrayToStr: byteArrayToStr,
                strToByteArray: strToByteArray,
                strToHexArray: strToHexArray,
                ucs2ToUtf8: ucs2ToUtf8,
                utf8ToUcs2: utf8ToUcs2,
                anythingToBuffer: anythingToBuffer
            };
            module.exports.Convert = Convert;
        },
        "./modules/solclient-convert/lib/hex.js": module => {
            function numToHex(n) {
                if (typeof n !== "number") {
                    return "";
                }
                const s = n.toString(16);
                return s.length < 2 ? `0${s}` : s;
            }
            function formatHexString(obj) {
                if (typeof obj === "number") {
                    return `0x${numToHex(obj)}`;
                }
                if (typeof obj === "object" && Array.isArray(obj)) {
                    return obj.map(numToHex).join();
                }
                if (typeof obj === "string") {
                    return Array.prototype.map.call(obj, (_, i) => numToHex(obj.charCodeAt(i))).join("");
                }
                return null;
            }
            const Hex = {
                formatHexString: formatHexString
            };
            module.exports.Hex = Hex;
        },
        "./modules/solclient-convert/lib/long.js": (module, __unused_webpack_exports, __webpack_require__) => {
            module.exports.Long = __webpack_require__("./node_modules/long/umd/index.js");
        },
        "./modules/solclient-core/api-internal.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const Convert = __webpack_require__("./modules/solclient-convert/api.js");
            const Debug = __webpack_require__("./modules/solclient-debug/api.js");
            const Destination = __webpack_require__("./modules/solclient-destination/api.js");
            const Error = __webpack_require__("./modules/solclient-error/api.js");
            const ESKit = __webpack_require__("./modules/solclient-eskit/api.js");
            const Factory = __webpack_require__("./modules/solclient-factory/api.js");
            const FSM = __webpack_require__("./modules/solclient-fsm/api.js");
            const Log = __webpack_require__("./modules/solclient-log/api.js");
            const Message = __webpack_require__("./modules/solclient-message/api.js");
            const Publisher = __webpack_require__("./modules/solclient-message-publisher/api.js");
            const SDT = __webpack_require__("./modules/solclient-sdt/api.js");
            const Session = __webpack_require__("./modules/solclient-session/api.js");
            const SMF = __webpack_require__("./modules/solclient-smf/api.js");
            const SolcacheSession = __webpack_require__("./modules/solclient-solcache-session/api.js");
            const TestEnv = __webpack_require__("./modules/solclient-env/api.js");
            const Transport = __webpack_require__("./modules/solclient-transport/api.js");
            const Util = __webpack_require__("./modules/solclient-util/api.js");
            const Validate = __webpack_require__("./modules/solclient-validate/api.js");
            module.exports = {
                Convert: Convert,
                Debug: Debug,
                Destination: Destination,
                Error: Error,
                ESKit: ESKit,
                Factory: Factory,
                FSM: FSM,
                Log: Log,
                Message: Message,
                Publisher: Publisher,
                SDT: SDT,
                Session: Session,
                SMF: SMF,
                SolcacheSession: SolcacheSession,
                TestEnv: TestEnv,
                Transport: Transport,
                Util: Util,
                Validate: Validate
            };
        },
        "./modules/solclient-core/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const FactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                SolclientFactory,
                SolclientFactoryProfiles,
                SolclientFactoryProperties
            } = FactoryLib;
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                Destination,
                DestinationType,
                Topic
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                ErrorSubcode,
                NotImplementedError,
                OperationError,
                RequestError,
                RequestEventCode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                makeIterator
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                ConsoleLogImpl,
                LogImpl,
                LogLevel
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Message,
                MessageCacheStatus,
                MessageDeliveryModeType,
                MessageDumpFlag,
                MessageType,
                MessageUserCosType,
                ReplicationGroupMessageId
            } = __webpack_require__("./modules/solclient-message/api.js");
            const {
                MessageConsumer,
                MessageConsumerAcknowledgeMode,
                MessageConsumerEventName,
                MessageConsumerProperties,
                QueueBrowser,
                QueueBrowserEventName,
                QueueBrowserProperties
            } = __webpack_require__("./modules/solclient-message-consumer/api.js");
            const {
                ReplayStartLocation,
                ReplayStartLocationBeginning
            } = __webpack_require__("./modules/solclient-replaystart/api.js");
            const {
                MessagePublisherAcknowledgeMode,
                MessagePublisherProperties
            } = __webpack_require__("./modules/solclient-message-publisher/api.js");
            const {
                AbstractQueueDescriptor,
                QueueAccessType,
                QueueDescriptor,
                QueueDiscardBehavior,
                QueuePermissions,
                QueueProperties,
                QueueType
            } = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                SDTField,
                SDTFieldType,
                SDTMapContainer,
                SDTStreamContainer,
                SDTUnsupportedValueError,
                SDTValueErrorSubcode
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                AuthenticationScheme,
                CapabilityType,
                MessageRxCBInfo,
                MutableSessionProperty,
                Session,
                SessionEvent,
                SessionEventCBInfo,
                SessionEventCode,
                SessionProperties,
                SessionState,
                SslDowngrade
            } = __webpack_require__("./modules/solclient-session/api.js");
            const {
                CacheCBInfo,
                CacheLiveDataAction,
                CacheRequestResult,
                CacheReturnCode,
                CacheReturnSubcode,
                CacheSession,
                CacheSessionProperties
            } = __webpack_require__("./modules/solclient-solcache-session/api.js");
            const {
                StatType
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                TransportError,
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/api.js");
            const {
                Version
            } = __webpack_require__("./modules/solclient-util/api.js");
            const _internal = __webpack_require__("./modules/solclient-core/api-internal.js");
            const solace = {
                AbstractQueueDescriptor: AbstractQueueDescriptor,
                AuthenticationScheme: AuthenticationScheme,
                CacheCBInfo: CacheCBInfo,
                CacheLiveDataAction: CacheLiveDataAction,
                CacheRequestResult: CacheRequestResult,
                CacheReturnCode: CacheReturnCode,
                CacheReturnSubcode: CacheReturnSubcode,
                CacheSession: CacheSession,
                CacheSessionProperties: CacheSessionProperties,
                CapabilityType: CapabilityType,
                ConsoleLogImpl: ConsoleLogImpl,
                Destination: Destination,
                DestinationType: DestinationType,
                ErrorSubcode: ErrorSubcode,
                LogImpl: LogImpl,
                LogLevel: LogLevel,
                Long: Long,
                Message: Message,
                MessageCacheStatus: MessageCacheStatus,
                MessageConsumer: MessageConsumer,
                MessageConsumerAcknowledgeMode: MessageConsumerAcknowledgeMode,
                MessageConsumerEventName: MessageConsumerEventName,
                MessageConsumerProperties: MessageConsumerProperties,
                MessageDeliveryModeType: MessageDeliveryModeType,
                MessageDumpFlag: MessageDumpFlag,
                MessagePublisherAcknowledgeMode: MessagePublisherAcknowledgeMode,
                MessagePublisherProperties: MessagePublisherProperties,
                MessageRxCBInfo: MessageRxCBInfo,
                MessageType: MessageType,
                MessageUserCosType: MessageUserCosType,
                MutableSessionProperty: MutableSessionProperty,
                NotImplementedError: NotImplementedError,
                OperationError: OperationError,
                QueueAccessType: QueueAccessType,
                QueueBrowser: QueueBrowser,
                QueueBrowserEventName: QueueBrowserEventName,
                QueueBrowserProperties: QueueBrowserProperties,
                QueueDescriptor: QueueDescriptor,
                QueueDiscardBehavior: QueueDiscardBehavior,
                QueuePermissions: QueuePermissions,
                QueueProperties: QueueProperties,
                QueueType: QueueType,
                ReplayStartLocation: ReplayStartLocation,
                ReplayStartLocationBeginning: ReplayStartLocationBeginning,
                ReplicationGroupMessageId: ReplicationGroupMessageId,
                RequestError: RequestError,
                RequestEventCode: RequestEventCode,
                SDTField: SDTField,
                SDTFieldType: SDTFieldType,
                SDTMapContainer: SDTMapContainer,
                SDTStreamContainer: SDTStreamContainer,
                SDTUnsupportedValueError: SDTUnsupportedValueError,
                SDTValueErrorSubcode: SDTValueErrorSubcode,
                Session: Session,
                SessionEvent: SessionEvent,
                SessionEventCBInfo: SessionEventCBInfo,
                SessionEventCode: SessionEventCode,
                SessionProperties: SessionProperties,
                SessionState: SessionState,
                SolclientFactory: SolclientFactory,
                SolclientFactoryProfiles: SolclientFactoryProfiles,
                SolclientFactoryProperties: SolclientFactoryProperties,
                SslDowngrade: SslDowngrade,
                StatType: StatType,
                Topic: Topic,
                TransportError: TransportError,
                TransportProtocol: TransportProtocol,
                Version: Version,
                makeIterator: makeIterator,
                _internal: _internal
            };
            Object.assign(module.exports, solace);
        },
        "./modules/solclient-debug/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Debug
            } = __webpack_require__("./modules/solclient-debug/lib/debug.js");
            module.exports.Debug = Debug;
        },
        "./modules/solclient-debug/lib/debug.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const PRINTABLE_LUT = (() => {
                const tmp = [];
                for (let c = 0; c < 256; ++c) {
                    tmp[c] = c < 33 || c > 126 ? "." : String.fromCharCode(c);
                }
                return tmp;
            })();
            const SPACER = "   ";
            const UNPRINTABLE = ".";
            function formatDumpBytes(data, showDecode, leftPadding) {
                const {
                    StringBuffer,
                    StringUtils
                } = __webpack_require__("./modules/solclient-util/api.js");
                const {
                    isEmpty,
                    padLeft,
                    padRight
                } = StringUtils;
                if (isEmpty(data)) {
                    return null;
                }
                const output = new StringBuffer();
                const ascii = new StringBuffer();
                const line = new StringBuffer();
                let lineBytes = 0;
                const asciiOffset = 54;
                for (let i = 0, dataLen = data.length; i < dataLen; ++i) {
                    const ccode = data.charCodeAt(i);
                    line.append(padLeft(ccode.toString(16), 2, "0"), " ");
                    ascii.append(PRINTABLE_LUT[ccode] || UNPRINTABLE);
                    lineBytes++;
                    if (lineBytes === 8) {
                        line.append(SPACER);
                    }
                    if (lineBytes === 16 || i === data.length - 1) {
                        if (leftPadding > 0) {
                            output.append(padRight("", leftPadding, " "));
                        }
                        output.append(padRight(line.toString(), asciiOffset, " "));
                        if (showDecode) {
                            output.append(ascii);
                        }
                        output.append("\n");
                        line.clear();
                        ascii.clear();
                        lineBytes = 0;
                    }
                }
                return output.toString();
            }
            function parseSMFStream(data) {
                const {
                    Codec: {
                        Decode: {
                            decodeCompoundMessage
                        }
                    }
                } = __webpack_require__("./modules/solclient-smf/api.js");
                const {
                    LOG_WARN,
                    LOG_ERROR
                } = __webpack_require__("./modules/solclient-log/api.js");
                if (data === null) {
                    LOG_ERROR("data null in debugParseSmfStream");
                    return;
                }
                let pos = 0;
                LOG_WARN(`parseSMFStream(): Starting parse, length ${data.length}`);
                while (pos < data.length) {
                    const incomingMsg = decodeCompoundMessage(data, pos);
                    const smf = incomingMsg ? incomingMsg.smfHeader : null;
                    if (!(incomingMsg && smf)) {
                        LOG_WARN("parseSMFStream(): couldn't decode message.");
                        LOG_WARN(`Position: ${pos} length: ${data.length}`);
                        return;
                    }
                    LOG_WARN(`>> Pos(${pos}) Protocol ${smf.smf_protocol}, Length: ${smf.messageLength}`);
                    pos += smf.messageLength;
                }
            }
            const Debug = {
                formatDumpBytes: formatDumpBytes,
                parseSMFStream: parseSMFStream
            };
            module.exports.Debug = Debug;
        },
        "./modules/solclient-destination/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/lib/destination.js");
            const {
                DestinationFromNetwork
            } = __webpack_require__("./modules/solclient-destination/lib/destination-from-network.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            const {
                DestinationUtil
            } = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                Queue
            } = __webpack_require__("./modules/solclient-destination/lib/queue.js");
            const {
                SolclientFactory
            } = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                Topic
            } = __webpack_require__("./modules/solclient-destination/lib/topic.js");
            SolclientFactory.createTopicDestination = SolclientFactory.createFactory(topicName => {
                Parameter.isString("topicName", topicName);
                return Topic.createFromName(topicName);
            });
            SolclientFactory.createTopic = SolclientFactory.createFactory(topicName => new Topic(topicName));
            SolclientFactory.createDurableQueueDestination = SolclientFactory.createFactory(queueName => {
                Parameter.isString("queueName", queueName);
                return Queue.createFromLocalName(queueName);
            });
            module.exports.Destination = Destination;
            module.exports.DestinationFromNetwork = DestinationFromNetwork;
            module.exports.DestinationType = DestinationType;
            module.exports.DestinationUtil = DestinationUtil;
            module.exports.Queue = Queue;
            module.exports.Topic = Topic;
        },
        "./modules/solclient-destination/lib/destination-from-network.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            const {
                DestinationUtil
            } = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
            const {
                Queue
            } = __webpack_require__("./modules/solclient-destination/lib/queue.js");
            const {
                Topic
            } = __webpack_require__("./modules/solclient-destination/lib/topic.js");
            const QUEUE_PREFIX = "#P2P/QUE/";
            const QUEUE_PREFIX_LEN = QUEUE_PREFIX.length;
            const TEMPORARY_QUEUE_PREFIX = "#P2P/QTMP/";
            function createDestinationFromName(networkTopicName, networkTopicBytes = undefined) {
                if (networkTopicName === null || networkTopicName.length === 0) {
                    return null;
                }
                const spec = {
                    name: networkTopicName,
                    bytes: networkTopicBytes || DestinationUtil.encodeBytes(networkTopicName)
                };
                if (networkTopicName[0] === "#") {
                    if (networkTopicName.startsWith(QUEUE_PREFIX)) {
                        const offset = QUEUE_PREFIX_LEN;
                        spec.name = networkTopicName.substr(offset);
                        spec.type = DestinationType.QUEUE;
                        spec.offset = offset;
                        return new Queue(spec);
                    } else if (networkTopicName.startsWith(TEMPORARY_QUEUE_PREFIX)) {
                        spec.name = networkTopicName;
                        spec.type = DestinationType.TEMPORARY_QUEUE;
                        spec.offset = 0;
                        return new Queue(spec);
                    }
                }
                return new Topic(spec);
            }
            function createDestinationFromBytes(networkTopicBytes) {
                if (networkTopicBytes === null || networkTopicBytes.length === 0) {
                    return null;
                }
                const networkTopicName = DestinationUtil.decodeBytes(networkTopicBytes);
                return createDestinationFromName(networkTopicName, networkTopicBytes);
            }
            const DestinationFromNetwork = {
                createDestinationFromBytes: createDestinationFromBytes,
                createDestinationFromName: createDestinationFromName
            };
            module.exports.DestinationFromNetwork = DestinationFromNetwork;
        },
        "./modules/solclient-destination/lib/destination-type.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const DestinationType = {
                TOPIC: "topic",
                QUEUE: "queue",
                TEMPORARY_QUEUE: "temporary_queue"
            };
            module.exports.DestinationType = Enum.new(DestinationType);
            module.exports.DestinationType._setCanonical({
                TOPIC: DestinationType.TOPIC,
                QUEUE: DestinationType.QUEUE,
                TEMPORARY_QUEUE: DestinationType.TEMPORARY_QUEUE
            });
        },
        "./modules/solclient-destination/lib/destination-util.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SubscriptionInfo
            } = __webpack_require__("./modules/solclient-destination/lib/subscription-info.js");
            const {
                UUID,
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                ucs2ToUtf8,
                utf8ToUcs2
            } = Convert;
            const {
                ProfileBinding
            } = SolclientFactoryLib;
            const {
                toSafeChars,
                stripNullTerminate
            } = StringUtils;
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const DESTINATION_PREFIX_FROM_TYPE = {
                [DestinationType.QUEUE]: "#P2P/QUE/",
                [DestinationType.TEMPORARY_QUEUE]: "#P2P/QTMP/"
            };
            function createTemporaryName(type, vrid, name) {
                const id = name || UUID.generateUUID();
                switch (type) {
                  case DestinationType.TOPIC:
                    return `#P2P/TTMP/${vrid}/${id}`;

                  case DestinationType.TEMPORARY_QUEUE:
                    return `#P2P/QTMP/${vrid}/${id}`;

                  default:
                    LOG_ERROR("Unknown/invalid destination type", DestinationType.describe(type));
                }
                return undefined;
            }
            function createPrefix(type) {
                return DESTINATION_PREFIX_FROM_TYPE[type] || "";
            }
            function createOperationError(type, errorStr) {
                return new OperationError(`Invalid ${type}: ${errorStr}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
            }
            function legacyValidate(type, bytes, name, exceptionCreator = createOperationError.bind(null, type)) {
                let error;
                const nameLength = name.length;
                if (nameLength < 1) {
                    error = exceptionCreator("Too short (must be >= 1 character).");
                    return {
                        error: error
                    };
                }
                const bytesLength = bytes.length;
                if (bytesLength > 251) {
                    error = exceptionCreator(`Too long (encoding must be <= 250 bytes); name is ${bytesLength - 1} bytes: '${name}'`);
                    return {
                        error: error
                    };
                }
                let isWildcarded = false;
                if (name.charAt(nameLength - 1) === ">") {
                    isWildcarded = true;
                }
                for (let i = 0; i < nameLength; ++i) {
                    switch (name.charAt(i)) {
                      case "/":
                        if (i === 0 || i === nameLength - 1 || name.charAt(i - 1) === "/") {
                            error = exceptionCreator(`Empty level(s) in '${name}'@${i}.`);
                            return {
                                error: error
                            };
                        }
                        break;

                      case "*":
                        if (i < nameLength - 1 && name.charAt(i + 1) !== "/") {
                            error = exceptionCreator(`Illegal wildcard(s) in '${name}'@${i}.`);
                            return {
                                error: error
                            };
                        }
                        isWildcarded = true;
                        break;

                      default:
                        break;
                    }
                }
                return {
                    isWildcarded: isWildcarded
                };
            }
            function encodeBytes(bytes) {
                return ProfileBinding.value.topicUtf8Encode ? `${ucs2ToUtf8(bytes)}\u0000` : `${bytes}\u0000`;
            }
            function decodeBytes(bytes) {
                return stripNullTerminate(ProfileBinding.value.topicUtf8Encode ? utf8ToUcs2(bytes) : bytes);
            }
            function encode(type, name) {
                const prefix = createPrefix(type);
                const offset = prefix.length;
                const networkName = prefix + name;
                const bytes = encodeBytes(networkName);
                return {
                    bytes: bytes,
                    offset: offset,
                    networkName: networkName
                };
            }
            function validateAndEncode(type, name, exceptionCreator = createOperationError.bind(null, type)) {
                const {
                    bytes,
                    offset
                } = encode(type, name);
                const {
                    error: constError,
                    isWildcarded
                } = legacyValidate(type, bytes, name, exceptionCreator);
                let error = constError;
                let subscriptionInfo = {};
                subscriptionInfo.isWildcarded = isWildcarded;
                if (!error) {
                    Object.keys(DESTINATION_PREFIX_FROM_TYPE).some(prefixType => {
                        const prefix = DESTINATION_PREFIX_FROM_TYPE[prefixType];
                        if (!name.startsWith(prefix)) {
                            return false;
                        }
                        error = exceptionCreator(`Reserved prefix '${prefix}' found at start of '${name}'`);
                        return true;
                    });
                }
                if (!error) {
                    const {
                        error: errorConst,
                        subInfo: subInfoConst
                    } = SubscriptionInfo.parseFromName(name, type);
                    error = errorConst;
                    subscriptionInfo = subInfoConst;
                }
                return {
                    bytes: bytes,
                    offset: offset,
                    error: error,
                    isWildcarded: isWildcarded,
                    subscriptionInfo: subscriptionInfo
                };
            }
            const DestinationUtil = {
                createPrefix: createPrefix,
                createTemporaryName: createTemporaryName,
                decodeBytes: decodeBytes,
                encode: encode,
                encodeBytes: encodeBytes,
                legacyValidate: legacyValidate,
                toSafeChars: toSafeChars,
                validateAndEncode: validateAndEncode
            };
            module.exports.DestinationUtil = DestinationUtil;
        },
        "./modules/solclient-destination/lib/destination.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            const {
                DestinationUtil
            } = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
            class Destination {
                constructor(spec, type = DestinationType.TOPIC) {
                    if (typeof spec === "object") {
                        this._name = spec.name;
                        this._type = spec.type;
                        this._bytes = spec.bytes;
                        this._offset = spec.offset;
                        if (spec.isValidated) {
                            this._isValidated = true;
                            this._isWildcarded = spec.isWildcarded;
                            this._subscriptionInfo = spec.subscriptionInfo || {};
                        } else {
                            this._isValidated = false;
                            this._subscriptionInfo = {};
                        }
                    } else {
                        this._name = spec;
                        this._type = type;
                        const result = DestinationUtil.encode(type, spec);
                        this._bytes = result.bytes;
                        this._offset = result.offset;
                        this._isValidated = false;
                        this._subscriptionInfo = {};
                    }
                }
                getName() {
                    return this._name;
                }
                get name() {
                    return this.getName();
                }
                getType() {
                    return this._type;
                }
                get type() {
                    return this.getType();
                }
                getBytes() {
                    return this._bytes;
                }
                get bytes() {
                    return this.getBytes();
                }
                getOffset() {
                    return this._offset;
                }
                get offset() {
                    return this.getOffset();
                }
                validate() {
                    if (this._isValidated) {
                        if (this._error) throw this._error;
                        return;
                    }
                    const {
                        error,
                        isWildcarded
                    } = DestinationUtil.legacyValidate(this.type, this.bytes, this.name);
                    this._isValidated = true;
                    if (error) {
                        this._error = error;
                        throw error;
                    }
                    this._isWildcarded = isWildcarded;
                }
                isWildcarded() {
                    this.validate();
                    return this._isWildcarded;
                }
                getSubscriptionInfo() {
                    return this._subscriptionInfo || {};
                }
                toString() {
                    return util_inspect(this);
                }
                equals(other) {
                    if (!(other instanceof Destination)) {
                        return false;
                    }
                    return this.toString().valueOf() === other.toString().valueOf();
                }
            }
            module.exports.Destination = Destination;
        },
        "./modules/solclient-destination/lib/queue.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DestinationUtilLib = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/lib/destination.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            class Queue extends Destination {
                constructor(spec) {
                    assert(spec.name, "Queue name not supplied");
                    assert(spec.type === DestinationType.QUEUE || spec.type === DestinationType.TEMPORARY_QUEUE, "Queue spec.type is invalid");
                    assert(spec.bytes, "Queue spec missing bytes");
                    assert(spec.offset !== undefined, "Queue spec missing offset");
                    super(spec);
                }
                getOffset() {
                    return this._offset;
                }
                get offset() {
                    return this.getOffset();
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return `[Queue ${this.getName()}]`;
                }
                static createFromLocalName(queueName) {
                    const encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(DestinationType.QUEUE, queueName);
                    if (encoding.error) {
                        throw encoding.error;
                    }
                    return new Queue({
                        name: queueName,
                        type: DestinationType.QUEUE,
                        isValidated: true,
                        bytes: encoding.bytes,
                        offset: encoding.offset,
                        isWildcarded: encoding.isWildcarded,
                        subscriptionInfo: encoding.subscriptionInfo
                    });
                }
            }
            module.exports.Queue = Queue;
        },
        "./modules/solclient-destination/lib/subscription-info.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            function subscriptionParseNoExport(type, name, bytes, offset, result) {
                const NOEXPORT_PREFIX = "#noexport/";
                const NOEXPORT_PREFIX_LEN = NOEXPORT_PREFIX.length;
                let index = offset;
                let error;
                if (name.length - index > NOEXPORT_PREFIX_LEN && !result.isNoExport) {
                    if (name.startsWith(NOEXPORT_PREFIX, index)) {
                        index += NOEXPORT_PREFIX_LEN;
                        result.isNoExport = true;
                    } else {
                        result.isNoExport = false;
                    }
                } else {
                    result.isNoExport = false;
                }
                return {
                    error: error,
                    index: index,
                    result: result
                };
            }
            function subscriptionParseShare(type, name, bytes, offset, result, exceptionCreator) {
                const SHARE_PREFIX = "#share/";
                const SHARE_PREFIX_LEN = SHARE_PREFIX.length;
                const LEVEL_DELIMETER = "/";
                const LEVEL_DELIMETER_LEN = LEVEL_DELIMETER.length;
                let index = offset;
                let error;
                let groupIndex = -1;
                let shareGroup;
                if (name.length - index > SHARE_PREFIX_LEN && !result.isShare) {
                    if (name.startsWith(SHARE_PREFIX, offset) && name.length - (index + SHARE_PREFIX_LEN) > LEVEL_DELIMETER_LEN + 1) {
                        index += SHARE_PREFIX_LEN;
                        groupIndex = index;
                        index = name.indexOf(LEVEL_DELIMETER, groupIndex);
                        if (index > 0) {
                            shareGroup = name.substring(groupIndex, index);
                            index += LEVEL_DELIMETER_LEN;
                            result.isShare = true;
                            result.shareGroup = shareGroup;
                            result.dispatchTopicIndex = index;
                        } else {
                            error = exceptionCreator(`Illegal share Group in '${name}'@${groupIndex}.`);
                            result.isShare = true;
                        }
                    } else {
                        result.isShare = false;
                    }
                } else {
                    result.isShare = false;
                }
                return {
                    error: error,
                    index: index,
                    result: result
                };
            }
            function subscriptionStringParse(layers, type, name, bytes, subInfo, exceptionCreator) {
                const parseLayers = layers.length || 0;
                let offset = 0;
                let error;
                let result = subInfo || {};
                for (let i = 0; i < parseLayers; ++i) {
                    const {
                        error: constError,
                        index: constOffset,
                        result: constResult
                    } = layers[i](type, name, bytes, offset, result, exceptionCreator);
                    offset = constOffset;
                    result = constResult;
                    error = constError;
                    if (error) break;
                }
                return {
                    error: error,
                    result: result
                };
            }
            const SUBSCRIPTION_LAYER_PARSER_FROM_TYPE = {
                [DestinationType.TOPIC]: {
                    _layers: [ subscriptionParseNoExport, subscriptionParseShare ],
                    parse: function subParse(type, name, bytes, subInfo, exceptionCreator) {
                        const {
                            error,
                            result
                        } = subscriptionStringParse(this._layers, type, name, bytes, subInfo, exceptionCreator);
                        return {
                            error: error,
                            result: result
                        };
                    }
                }
            };
            function createOperationError(type, errorStr) {
                return new OperationError(`Invalid ${type}: ${errorStr}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
            }
            class SubscriptionInfo {
                constructor(name) {
                    this._name = name;
                    this._isShare = false;
                    this._isNoExport = false;
                    this._dispatchTopicIndex = -1;
                    this._shareGroup = null;
                }
                getName() {
                    return this._name;
                }
                get name() {
                    return this.getName();
                }
                get isShare() {
                    return this._isShare;
                }
                set isShare(value) {
                    this._isShare = value;
                }
                get isNoExport() {
                    return this._isNoExport;
                }
                set isNoExport(value) {
                    this._isNoExport = value;
                }
                get dispatchTopicIndex() {
                    return this._dispatchTopicIndex < 0 ? 0 : this._dispatchTopicIndex;
                }
                set dispatchTopicIndex(value) {
                    this._dispatchTopicIndex = value < 0 ? -1 : value;
                }
                get shareGroup() {
                    return this.isShare ? this._shareGroup : null;
                }
                set shareGroup(value) {
                    if (this.isShare) {
                        this._shareGroup = value;
                    }
                }
                toString() {
                    return util_inspect(this);
                }
                static parseFromName(name, type = DestinationType.TOPIC) {
                    let subInfo = new SubscriptionInfo(name);
                    let error = null;
                    const parser = SUBSCRIPTION_LAYER_PARSER_FROM_TYPE[type];
                    if (parser) {
                        const {
                            error: errorConst,
                            result: subInfoConst
                        } = parser.parse(type, name, null, subInfo, createOperationError.bind(null, type));
                        subInfo = subInfoConst;
                        error = errorConst;
                    }
                    return {
                        error: error,
                        subInfo: subInfo
                    };
                }
            }
            module.exports.SubscriptionInfo = SubscriptionInfo;
        },
        "./modules/solclient-destination/lib/topic.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DestinationUtilLib = __webpack_require__("./modules/solclient-destination/lib/destination-util.js");
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/lib/destination.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/lib/destination-type.js");
            class Topic extends Destination {
                constructor(spec) {
                    if (typeof spec === "object") {
                        super({
                            type: DestinationType.TOPIC,
                            name: spec.name,
                            bytes: spec.bytes,
                            offset: spec.offset,
                            isValidated: spec.isValidated,
                            isWildcarded: spec.isWildcarded,
                            subscriptionInfo: spec.subscriptionInfo
                        });
                    } else {
                        super(spec, DestinationType.TOPIC);
                    }
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return `[Topic ${this.getName()}]`;
                }
                static createFromName(topicName) {
                    const encoding = DestinationUtilLib.DestinationUtil.validateAndEncode(DestinationType.TOPIC, topicName);
                    if (encoding.error) {
                        throw encoding.error;
                    }
                    return new Topic({
                        name: topicName,
                        isValidated: true,
                        bytes: encoding.bytes,
                        offset: encoding.offset,
                        isWildcarded: encoding.isWildcarded,
                        subscriptionInfo: encoding.subscriptionInfo
                    });
                }
            }
            module.exports.Topic = Topic;
        },
        "./modules/solclient-env/api.js": module => {
            function apiEnv(envObject) {
                if (true) {
                    throw new Error("Test environment will not override build environment");
                }
                global.BUILD_ENV = Object.assign({}, envObject, {
                    TEST: true
                });
                return global.BUILD_ENV;
            }
            if (true) {
                apiEnv.target = () => apiEnv();
            } else {}
            module.exports = apiEnv;
        },
        "./modules/solclient-error/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorResponseSubcodeMapper
            } = __webpack_require__("./modules/solclient-error/lib/error-response-subcode-mapper.js");
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/lib/error-subcodes.js");
            const {
                NotImplementedError
            } = __webpack_require__("./modules/solclient-error/lib/not-implemented-error.js");
            const {
                OperationError
            } = __webpack_require__("./modules/solclient-error/lib/operation-error.js");
            const {
                RequestError
            } = __webpack_require__("./modules/solclient-error/lib/request-error.js");
            const {
                RequestEventCode
            } = __webpack_require__("./modules/solclient-error/lib/request-event-codes.js");
            const {
                SolaceError
            } = __webpack_require__("./modules/solclient-error/lib/solace-error.js");
            module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
            module.exports.ErrorSubcode = ErrorSubcode;
            module.exports.NotImplementedError = NotImplementedError;
            module.exports.OperationError = OperationError;
            module.exports.RequestError = RequestError;
            module.exports.RequestEventCode = RequestEventCode;
            module.exports.SolaceError = SolaceError;
        },
        "./modules/solclient-error/lib/error-response-subcode-mapper.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/lib/error-subcodes.js");
            const {
                makeMap
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SC = ErrorSubcode;
            const ROOT_MAPPING = makeMap(400, makeMap("client name parse error", SC.CLIENT_NAME_INVALID, "document is too large", SC.MESSAGE_TOO_LARGE, "inactivity timeout", SC.INACTIVITY_TIMEOUT, "max num subscriptions exceeded", SC.SUBSCRIPTION_TOO_MANY, "message too long", SC.MESSAGE_TOO_LARGE, "nolocal discard", SC.NOLOCAL_DISCARD, "not enough space", SC.OUT_OF_RESOURCES, "subscription already exists", SC.SUBSCRIPTION_ALREADY_PRESENT, "subscription attributes conflict with existing subscription", SC.SUBSCRIPTION_ATTRIBUTES_CONFLICT, "subscription not found", SC.SUBSCRIPTION_NOT_FOUND, "subscription parse error", SC.SUBSCRIPTION_INVALID, "topic parse error", SC.INVALID_TOPIC_SYNTAX, "unknown transport session identifier", SC.UNKNOWN_TRANSPORT_SESSION_ID, "xml parse error", SC.XML_PARSE_ERROR, "unsupported ssl downgrade value", SC.LOGIN_FAILURE), 401, makeMap("", SC.LOGIN_FAILURE), 403, makeMap("basic authentication is shutdown", SC.BASIC_AUTHENTICATION_IS_SHUTDOWN, "client certificate authentication is shutdown", SC.CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN, "client name already in use", SC.CLIENT_NAME_ALREADY_IN_USE, "client username is shutdown", SC.CLIENT_USERNAME_IS_SHUTDOWN, "dynamic clients not allowed", SC.DYNAMIC_CLIENTS_NOT_ALLOWED, "invalid virtual router address", SC.INVALID_VIRTUAL_ADDRESS, "forbidden", SC.CLIENT_ACL_DENIED, "message vpn not allowed", SC.MESSAGE_VPN_NOT_ALLOWED, "publish acl denied", SC.PUBLISH_ACL_DENIED, "replication is standby", SC.REPLICATION_IS_STANDBY, "selector does not match", SC.SELECTOR_DOES_NOT_MATCH, "subscription acl denied", SC.SUBSCRIPTION_ACL_DENIED, "subscription does not match", SC.SUBSCRIPTION_DOES_NOT_MATCH, "compression is shutdown", SC.LOGIN_FAILURE, "shared subscriptions not supported on topic endpoints", SC.SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED, "shared subscriptions not supported on queues", SC.SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED, "shared subscription permission denied", SC.SHARED_SUBSCRIPTIONS_NOT_ALLOWED), 404, makeMap("", SC.LOGIN_FAILURE), 503, makeMap("low priority msg congestion", SC.LOW_PRIORITY_MSG_CONGESTION, "message vpn unavailable", SC.MESSAGE_VPN_UNAVAILABLE, "replication is standby", SC.REPLICATION_IS_STANDBY, "service unavailable", SC.GM_UNAVAILABLE, "spool over quota", SC.SPOOL_OVER_QUOTA, "subscriber delete in progress", SC.CLIENT_DELETE_IN_PROGRESS, "too many clients", SC.TOO_MANY_CLIENTS, "too many connections for vpn", SC.TOO_MANY_CLIENTS, "max message usage exceeded", SC.MAX_MESSAGE_USAGE_EXCEEDED), 507, makeMap("ad not ready", SC.GM_NOT_READY));
            const AD_MAPPING = makeMap("PARENT", ROOT_MAPPING, 400, makeMap("already bound", SC.ALREADY_BOUND, "endpoint already exists", SC.ENDPOINT_ALREADY_EXISTS, "subscription already exists", SC.SUBSCRIPTION_ALREADY_PRESENT, "already exists", SC.ENDPOINT_ALREADY_EXISTS, "endpoint property mismatch", SC.ENDPOINT_PROPERTY_MISMATCH, "invalid durable topic endpoint name", SC.INVALID_DTE_NAME, "invalid selector", SC.INVALID_SELECTOR, "invalid topic name", SC.INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT, "queue not found", SC.QUEUE_NOT_FOUND, "quota out of range", SC.QUOTA_OUT_OF_RANGE, "unknown flow name", SC.UNKNOWN_FLOW_NAME, "unsubscribe not allowed", SC.UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND), 403, makeMap("permission not allowed", SC.PERMISSION_NOT_ALLOWED, "client initiated replay not allowed on non-exclusive topic endpoint", SC.CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED, "client initiated replay not allowed on non-exclusive queue", SC.CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED, "client initiated replay from inactive flow not allowed", SC.CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED, "client initiated replay from browser flow not allowed", SC.CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED, "replay not supported on temporary topic endpoint", SC.REPLAY_TEMPORARY_NOT_SUPPORTED, "replay not supported on temporary queue", SC.REPLAY_TEMPORARY_NOT_SUPPORTED, "unknown start location type", SC.UNKNOWN_START_LOCATION_TYPE, "mismatched endpoint error id", SC.MISMATCHED_ENDPOINT_ERROR_ID, "replay start message unavailable", SC.REPLAY_START_MESSAGE_NOT_AVAILABLE), 503, makeMap("durable topic endpoint shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "endpoint shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "max clients exceeded for durable topic endpoint", SC.MAX_CLIENTS_FOR_TE, "max clients exceeded for queue", SC.MAX_CLIENTS_FOR_QUEUE, "no more non-durable queue or topic endpoint", SC.NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT, "no subscription match", SC.NO_SUBSCRIPTION_MATCH, "queue shutdown", SC.QUEUE_SHUTDOWN, "te shutdown", SC.TOPIC_ENDPOINT_SHUTDOWN, "unknown durable topic endpoint", SC.UNKNOWN_TOPIC_ENDPOINT_NAME, "unknown queue", SC.UNKNOWN_QUEUE_NAME, "replay disabled", SC.REPLAY_DISABLED, "replay cancelled", SC.REPLAY_CANCELLED, "replay message unavailable", SC.REPLAY_MESSAGE_UNAVAILABLE, "replay started", SC.REPLAY_STARTED, "replayed message rejected by topic endpoint", SC.REPLAY_MESSAGE_REJECTED, 'replayed message rejected by queue"', SC.REPLAY_MESSAGE_REJECTED, "replay log modified", SC.REPLAY_LOG_MODIFIED, "mismatched endpoint error id", SC.MISMATCHED_ENDPOINT_ERROR_ID, "out of replay resources", SC.OUT_OF_REPLAY_RESOURCES, "topic or selector modified on durable topic endpoint", SC.TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT, "replay failed", SC.REPLAY_FAILED, "replay start time not available", SC.REPLAY_START_TIME_NOT_AVAILABLE, "replay start message unavailable", SC.REPLAY_START_MESSAGE_NOT_AVAILABLE));
            function getSubcodeMappingInner(root, respErrorCode, respStr) {
                if (respErrorCode === 200) {
                    return 0;
                }
                const codeMap = root[respErrorCode] || {};
                const searchKey = (respStr || "").toLowerCase();
                const foundKey = Object.keys(codeMap).find(mapKey => mapKey === searchKey || searchKey.indexOf(mapKey) >= 0);
                if (foundKey) {
                    return codeMap[foundKey];
                }
                if (codeMap[""]) {
                    return codeMap[""];
                }
                if (root["PARENT"]) {
                    return getSubcodeMappingInner(root["PARENT"], respErrorCode, respStr);
                }
                return undefined;
            }
            function getSubcodeMapping(root, respErrorCode, respStr) {
                const result = getSubcodeMappingInner(root, respErrorCode, respStr);
                if (result === undefined) {
                    return SC.UNKNOWN_ERROR;
                }
                return result;
            }
            const ErrorResponseSubcodeMapper = {
                getErrorSubcode(respErrorCode, respStr) {
                    return getSubcodeMapping(ROOT_MAPPING, respErrorCode, respStr);
                },
                getADErrorSubcode(respErrorCode, respStr) {
                    return getSubcodeMapping(AD_MAPPING, respErrorCode, respStr);
                }
            };
            module.exports.ErrorResponseSubcodeMapper = ErrorResponseSubcodeMapper;
        },
        "./modules/solclient-error/lib/error-subcodes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const ErrorSubcode = {
                UNKNOWN_ERROR: 4294967295,
                NO_ERROR: 0,
                SESSION_NOT_CONNECTED: 2,
                INVALID_SESSION_OPERATION: 3,
                INVALID_OPERATION: 3,
                TIMEOUT: 4,
                MESSAGE_VPN_NOT_ALLOWED: 5,
                MESSAGE_VPN_UNAVAILABLE: 6,
                CLIENT_USERNAME_IS_SHUTDOWN: 7,
                DYNAMIC_CLIENTS_NOT_ALLOWED: 8,
                CLIENT_NAME_ALREADY_IN_USE: 9,
                CLIENT_NAME_INVALID: 10,
                CLIENT_DELETE_IN_PROGRESS: 11,
                TOO_MANY_CLIENTS: 12,
                LOGIN_FAILURE: 13,
                INVALID_VIRTUAL_ADDRESS: 14,
                CLIENT_ACL_DENIED: 15,
                SUBSCRIPTION_ACL_DENIED: 16,
                PUBLISH_ACL_DENIED: 17,
                PARAMETER_OUT_OF_RANGE: 18,
                PARAMETER_CONFLICT: 19,
                PARAMETER_INVALID_TYPE: 20,
                INTERNAL_ERROR: 21,
                INSUFFICIENT_SPACE: 22,
                OUT_OF_RESOURCES: 23,
                PROTOCOL_ERROR: 24,
                COMMUNICATION_ERROR: 25,
                KEEP_ALIVE_FAILURE: 26,
                TOPIC_MISSING: 28,
                INVALID_TOPIC_SYNTAX: 31,
                MESSAGE_TOO_LARGE: 32,
                XML_PARSE_ERROR: 33,
                SUBSCRIPTION_ALREADY_PRESENT: 34,
                SUBSCRIPTION_NOT_FOUND: 35,
                SUBSCRIPTION_INVALID: 36,
                SUBSCRIPTION_ERROR_OTHER: 37,
                SUBSCRIPTION_TOO_MANY: 38,
                SUBSCRIPTION_ATTRIBUTES_CONFLICT: 39,
                NO_LOCAL_NOT_SUPPORTED: 40,
                DATA_ERROR_OTHER: 42,
                CREATE_XHR_FAILED: 43,
                CONNECTION_ERROR: 44,
                DATA_DECODE_ERROR: 45,
                INACTIVITY_TIMEOUT: 46,
                UNKNOWN_TRANSPORT_SESSION_ID: 47,
                AD_MESSAGING_NOT_SUPPORTED: 48,
                CREATE_WEBSOCKET_FAILED: 49,
                REPLICATION_IS_STANDBY: 50,
                BASIC_AUTHENTICATION_IS_SHUTDOWN: 51,
                CLIENT_CERTIFICATE_AUTHENTICATION_IS_SHUTDOWN: 52,
                GM_UNAVAILABLE: 100,
                UNKNOWN_FLOW_NAME: 111,
                ALREADY_BOUND: 112,
                INVALID_TOPIC_NAME_FOR_TOPIC_ENDPOINT: 113,
                UNKNOWN_QUEUE_NAME: 114,
                UNKNOWN_TOPIC_ENDPOINT_NAME: 115,
                MAX_CLIENTS_FOR_QUEUE: 116,
                MAX_CLIENTS_FOR_TE: 117,
                UNEXPECTED_UNBIND: 118,
                QUEUE_NOT_FOUND: 119,
                SPOOL_OVER_QUOTA: 120,
                QUEUE_SHUTDOWN: 121,
                TOPIC_ENDPOINT_SHUTDOWN: 122,
                NO_MORE_NON_DURABLE_QUEUE_OR_TOPIC_ENDPOINT: 123,
                ENDPOINT_ALREADY_EXISTS: 124,
                PERMISSION_NOT_ALLOWED: 125,
                INVALID_SELECTOR: 126,
                MAX_MESSAGE_USAGE_EXCEEDED: 127,
                ENDPOINT_PROPERTY_MISMATCH: 128,
                NO_SUBSCRIPTION_MATCH: 129,
                MESSAGE_DELIVERY_MODE_MISMATCH: 130,
                MESSAGE_ALREADY_ACKNOWLEDGED: 131,
                SUBSCRIPTION_DOES_NOT_MATCH: 133,
                SELECTOR_DOES_NOT_MATCH: 134,
                INVALID_DTE_NAME: 135,
                UNSUBSCRIBE_NOT_ALLOWED_CLIENTS_BOUND: 136,
                CALLBACK_ERROR: 137,
                NOLOCAL_DISCARD: 138,
                GM_NOT_READY: 140,
                LOW_PRIORITY_MSG_CONGESTION: 141,
                QUOTA_OUT_OF_RANGE: 142,
                FAILED_LOADING_TRUSTSTORE: 143,
                FAILED_LOADING_CERTIFICATE_AND_KEY: 144,
                UNRESOLVED_HOSTS: 145,
                REPLAY_NOT_SUPPORTED: 146,
                REPLAY_DISABLED: 147,
                CLIENT_INITIATED_REPLAY_NON_EXCLUSIVE_NOT_ALLOWED: 148,
                CLIENT_INITIATED_REPLAY_INACTIVE_FLOW_NOT_ALLOWED: 149,
                CLIENT_INITIATED_REPLAY_BROWSER_FLOW_NOT_ALLOWED: 150,
                REPLAY_TEMPORARY_NOT_SUPPORTED: 151,
                UNKNOWN_START_LOCATION_TYPE: 152,
                REPLAY_CANCELLED: 153,
                REPLAY_MESSAGE_UNAVAILABLE: 154,
                REPLAY_START_TIME_NOT_AVAILABLE: 155,
                REPLAY_MESSAGE_REJECTED: 156,
                REPLAY_LOG_MODIFIED: 157,
                MISMATCHED_ENDPOINT_ERROR_ID: 158,
                OUT_OF_REPLAY_RESOURCES: 159,
                TOPIC_OR_SELECTOR_MODIFIED_ON_DURABLE_TOPIC_ENDPOINT: 160,
                REPLAY_FAILED: 161,
                REPLAY_STARTED: 162,
                COMPRESSED_TLS_NOT_SUPPORTED: 163,
                SHARED_SUBSCRIPTIONS_NOT_SUPPORTED: 164,
                SHARED_SUBSCRIPTIONS_NOT_ALLOWED: 165,
                SHARED_SUBSCRIPTIONS_ENDPOINT_NOT_ALLOWED: 166,
                REPLAY_START_MESSAGE_NOT_AVAILABLE: 167,
                MESSAGE_ID_NOT_COMPARABLE: 168
            };
            module.exports.ErrorSubcode = Enum.new(ErrorSubcode);
        },
        "./modules/solclient-error/lib/not-implemented-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                SolaceError
            } = __webpack_require__("./modules/solclient-error/lib/solace-error.js");
            class NotImplementedError extends SolaceError {
                constructor(message) {
                    super("NotImplementedError", message || "", NotImplementedError);
                }
            }
            module.exports.NotImplementedError = NotImplementedError;
        },
        "./modules/solclient-error/lib/operation-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                SolaceError
            } = __webpack_require__("./modules/solclient-error/lib/solace-error.js");
            class OperationError extends SolaceError {
                constructor(message, subcode, reason) {
                    super("OperationError", message, OperationError);
                    this.subcode = subcode;
                    this.reason = reason;
                }
            }
            module.exports.OperationError = OperationError;
        },
        "./modules/solclient-error/lib/request-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/lib/error-subcodes.js");
            const {
                OperationError
            } = __webpack_require__("./modules/solclient-error/lib/operation-error.js");
            const {
                RequestEventCode
            } = __webpack_require__("./modules/solclient-error/lib/request-event-codes.js");
            const SUBCODE_FROM_EC = {
                [RequestEventCode.REQUEST_ABORTED]: ErrorSubcode.SESSION_NOT_CONNECTED,
                [RequestEventCode.REQUEST_TIMEOUT]: ErrorSubcode.TIMEOUT
            };
            class RequestError extends OperationError {
                constructor(message, eventCode, correlationKey, reason) {
                    super(message, SUBCODE_FROM_EC[eventCode], reason);
                    this.name = "RequestError";
                    this._eventCode = eventCode;
                    this._correlationKey = correlationKey;
                }
                get requestEventCode() {
                    return this._requestEventCode;
                }
                get errorSubcode() {
                    return super.subcode;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    const superObj = super[Symbol.for("nodejs.util.inspect.custom")] ? super[Symbol.for("nodejs.util.inspect.custom")]() : {};
                    return Object.assign(superObj, {
                        requestEventCode: RequestEventCode.describe(this.requestEventCode),
                        infoStr: this.infoStr,
                        correlationKey: this.correlationKey
                    });
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.RequestError = RequestError;
        },
        "./modules/solclient-error/lib/request-event-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const RequestEventCode = {
                REQUEST_ABORTED: 8,
                REQUEST_TIMEOUT: 9
            };
            module.exports.RequestEventCode = Enum.new(RequestEventCode);
        },
        "./modules/solclient-error/lib/solace-error.js": module => {
            class SolaceError extends Error {
                constructor(type, message, constructor) {
                    super(message || "");
                    this.message = message;
                    this.name = type;
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, constructor);
                    } else {
                        this.stack = new Error().stack;
                    }
                }
            }
            module.exports.SolaceError = SolaceError;
        },
        "./modules/solclient-eskit/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ArrayOperations
            } = __webpack_require__("./modules/solclient-eskit/lib/array-operations.js");
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/lib/assert.js");
            const {
                BidiMap
            } = __webpack_require__("./modules/solclient-eskit/lib/bidi-map.js");
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/lib/enum.js");
            const {
                Iterator
            } = __webpack_require__("./modules/solclient-eskit/lib/iterator.js");
            const {
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/lib/lazy.js");
            const {
                makeMap
            } = __webpack_require__("./modules/solclient-eskit/lib/make-map.js");
            const {
                Mixin
            } = __webpack_require__("./modules/solclient-eskit/lib/mixin.js");
            const {
                Resolver
            } = __webpack_require__("./modules/solclient-eskit/lib/resolver.js");
            const {
                SetOperations
            } = __webpack_require__("./modules/solclient-eskit/lib/set-operations.js");
            module.exports.assert = assert;
            module.exports.ArrayOperations = ArrayOperations;
            module.exports.BidiMap = BidiMap;
            module.exports.Enum = Enum;
            module.exports.Iterator = Iterator;
            module.exports.Lazy = Lazy;
            module.exports.makeIterator = Iterator.makeIterator;
            module.exports.makeMap = makeMap;
            module.exports.Mixin = Mixin;
            module.exports.mixin = Mixin.mixin;
            module.exports.Resolver = Resolver;
            module.exports.resolve = Resolver.resolve;
            module.exports.SetOperations = SetOperations;
        },
        "./modules/solclient-eskit/lib/array-operations.js": module => {
            function defaultComparator(a, b) {
                const astr = String(a);
                const bstr = String(b);
                return astr > bstr ? 1 : astr < bstr ? -1 : 0;
            }
            function insertOrdered(array, element, comparator = defaultComparator) {
                const result = [ ...array ];
                return this.inplaceInsertOrdered(result, element, comparator);
            }
            function inplaceInsertOrdered(array, element, comparator = defaultComparator) {
                let index = 0;
                let min = 0;
                let max = array.length;
                if (max > 0) {
                    if (comparator(element, array[max - 1]) > 0) {
                        index = max;
                    } else {
                        index = min + max >> 1;
                        while (max > min) {
                            if (comparator(element, array[index]) < 0) {
                                max = index;
                            } else {
                                min = index + 1;
                            }
                            index = min + max >> 1;
                        }
                    }
                }
                array.splice(index, 0, element);
            }
            module.exports = {
                ArrayOperations: {
                    defaultComparator: defaultComparator,
                    insertOrdered: insertOrdered,
                    inplaceInsertOrdered: inplaceInsertOrdered
                }
            };
        },
        "./modules/solclient-eskit/lib/assert.js": module => {
            let assert;
            if (false) {} else {
                assert = () => {};
            }
            module.exports.assert = assert;
        },
        "./modules/solclient-eskit/lib/bidi-map.js": module => {
            class BidiMap {
                constructor(...pairs) {
                    this.forward = new Map();
                    this.reverse = new Map();
                    pairs.forEach(p => {
                        this.setValues(p[0], p[1]);
                    });
                }
                setValues(key, value) {
                    this.forward.set(key, value);
                    this.reverse.set(value, key);
                }
            }
            module.exports.BidiMap = BidiMap;
        },
        "./modules/solclient-eskit/lib/enum.js": module => {
            function enumName(instance, keys, value) {
                const matches = keys.filter(k => instance[k] === value);
                return matches.length ? matches[0] : null;
            }
            function enumValues(instance, keys) {
                return Array.from(new Set(keys.map(k => instance[k])));
            }
            class Enum {
                constructor(values) {
                    Object.defineProperties(this, {
                        _canonical: {
                            value: null,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    this._setCanonical(values);
                }
                _setCanonical(values, final = false) {
                    this._canonical = Object.assign({}, values);
                    Object.keys(this).forEach(key => {
                        const descriptor = Object.getOwnPropertyDescriptor(this, key);
                        if (descriptor.value !== undefined) {
                            Object.defineProperty(this, key, {
                                enumerable: false,
                                writable: true,
                                configurable: true,
                                value: descriptor.value
                            });
                        }
                    });
                    Object.keys(values).forEach(key => {
                        Object.defineProperty(this, key, {
                            enumerable: true,
                            writable: !final,
                            configurable: !final,
                            value: values[key]
                        });
                    });
                }
                describe(enumValue, noneValue = "<none>", unknownValue = "<unknown>") {
                    if (enumValue === null || enumValue === undefined) return noneValue;
                    const name = enumName(this._canonical, Object.keys(this._canonical || {}), enumValue) || unknownValue;
                    return name === enumValue ? name : `${name} (${enumValue})`;
                }
                nameOf(enumValue) {
                    return enumName(this._canonical, Object.keys(this._canonical || {}), enumValue);
                }
                get names() {
                    return Object.keys(this._canonical || {});
                }
                get values() {
                    return enumValues(this._canonical, Object.keys(this._canonical || {}));
                }
                get isEnum() {
                    return true;
                }
                static nameOf(instance, value) {
                    return instance.nameOf(value);
                }
                static values(instance) {
                    return instance.values();
                }
                static new(values) {
                    return new Enum(values);
                }
                static ofStrings(strings) {
                    const map = {};
                    strings.forEach(s => {
                        map[s] = s;
                    });
                    return Enum.new(map);
                }
                static ofNumbers(keys) {
                    const map = {};
                    keys.forEach((key, index) => {
                        map[key] = index;
                    });
                    return Enum.new(map);
                }
            }
            module.exports.Enum = Enum;
        },
        "./modules/solclient-eskit/lib/iterator.js": module => {
            class Iterator {
                constructor(arr, start = 0, end = arr.length) {
                    this._arr = arr;
                    this._index = start;
                    this._end = end;
                }
                deref() {
                    return this._arr[this._index];
                }
                incr() {
                    return ++this._index;
                }
                end() {
                    return this._index >= this._end;
                }
                static makeIterator(arr, start = 0, end = arr.length) {
                    return new Iterator(arr, start, end);
                }
            }
            module.exports.Iterator = Iterator;
        },
        "./modules/solclient-eskit/lib/lazy.js": module => {
            const DEFAULT_PROPERTY_OPTIONS = {
                enumerable: true
            };
            function setPropertyValue(target, key, value, options = null) {
                Object.defineProperty(target, key, Object.assign({
                    value: value
                }, DEFAULT_PROPERTY_OPTIONS, options));
            }
            function lazyProperty(target, key, evalFn) {
                Object.defineProperty(target, key, Object.assign({
                    configurable: true,
                    get: () => {
                        const result = evalFn(target, key);
                        setPropertyValue(target, key, result);
                        return result;
                    },
                    set: value => {
                        setPropertyValue(target, key, value);
                    }
                }, DEFAULT_PROPERTY_OPTIONS));
                return target;
            }
            function lazyProperties(target, obj) {
                Object.keys(obj).forEach(k => {
                    lazyProperty(target, k, obj[k]);
                });
                return obj;
            }
            function lazyValue(evalFn) {
                return lazyProperty({}, "value", evalFn);
            }
            const Lazy = {
                lazyProperties: lazyProperties,
                lazyProperty: lazyProperty,
                lazyValue: lazyValue
            };
            module.exports.Lazy = Lazy;
        },
        "./modules/solclient-eskit/lib/make-map.js": module => {
            module.exports.makeMap = function makeMap(...keyValuePairs) {
                const result = {};
                for (let i = 0; i < keyValuePairs.length; i += 2) {
                    result[keyValuePairs[i]] = keyValuePairs[i + 1];
                }
                return result;
            };
        },
        "./modules/solclient-eskit/lib/mixin.js": module => {
            const Mixin = {};
            Mixin.mixin = function mixin(target, add) {
                const targetProto = target.prototype;
                const addProto = add.prototype;
                Object.getOwnPropertyNames(addProto).forEach(name => {
                    if (name === "constructor") return;
                    Object.defineProperty(targetProto, name, Object.getOwnPropertyDescriptor(addProto, name));
                });
                return target;
            };
            module.exports.Mixin = Mixin;
        },
        "./modules/solclient-eskit/lib/resolver.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/lib/lazy.js");
            const {
                lazyProperty
            } = Lazy;
            function traversePath(commonSource, keySource, pathArr) {
                return pathArr.reduce((source, value) => {
                    if (typeof value === "string") {
                        return source[value];
                    }
                    return value;
                }, keySource);
            }
            class Resolver {
                constructor(options, source) {
                    Object.keys(options).forEach(compoundKey => {
                        compoundKey.split(",").map(k => k.trim()).forEach(key => {
                            const rawPath = options[compoundKey];
                            const path = typeof rawPath === "string" ? rawPath.split(".") : rawPath;
                            const pathArr = (Array.isArray(path) ? path : [ path ]).concat(key);
                            lazyProperty(this, key, () => traversePath(source, this, pathArr));
                        });
                    });
                }
                static resolve(options, source) {
                    return new Resolver(options, source);
                }
            }
            module.exports.Resolver = Resolver;
        },
        "./modules/solclient-eskit/lib/set-operations.js": module => {
            function isSuperset(set, subset) {
                return Array.from(subset).every(elem => set.has(elem));
            }
            function inplaceUnion(setA, setB) {
                setB.forEach(elem => {
                    setA.add(elem);
                });
                return setA;
            }
            function union(setA, setB) {
                return inplaceUnion(new Set(setA), setB);
            }
            function inplaceIntersection(setA, setB) {
                setA.forEach(elem => {
                    if (!setB.has(elem)) {
                        setA.delete(elem);
                    }
                });
                return setA;
            }
            function intersection(setA, setB) {
                return new Set(Array.from(setA).filter(elem => setB.has(elem)));
            }
            function inplaceDifference(setA, setB) {
                setB.forEach(elem => {
                    setA.delete(elem);
                });
                return setA;
            }
            function difference(setA, setB) {
                return new Set(Array.from(setA).filter(elem => !setB.has(elem)));
            }
            module.exports = {
                SetOperations: {
                    inplaceDifference: inplaceDifference,
                    inplaceIntersection: inplaceIntersection,
                    inplaceUnion: inplaceUnion,
                    isSuperset: isSuperset,
                    difference: difference,
                    intersection: intersection,
                    union: union
                }
            };
        },
        "./modules/solclient-events/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                EventEmitter
            } = __webpack_require__("./modules/solclient-events/lib/event-emitter.js");
            const {
                Timer
            } = __webpack_require__("./modules/solclient-events/lib/timer.js");
            module.exports = {
                EventEmitter: EventEmitter,
                Timer: Timer
            };
        },
        "./modules/solclient-events/lib/event-emitter.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const NodeEventEmitter = __webpack_require__("events").EventEmitter;
            const {
                ArrayUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LOG_WARN
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                flatten,
                includes
            } = ArrayUtils;
            const NODE_DEFAULT_EVENTS = [ "error", "newListener", "removeListener" ];
            const BLACKLIST_DIRECT = [ "newListener", "removeListener" ];
            function buildFilter(emits) {
                if (typeof emits === "function") return k => includes(NODE_DEFAULT_EVENTS, k) || emits(k);
                if (!Array.isArray(emits)) return null;
                const emitSet = new Set(flatten(emits));
                NODE_DEFAULT_EVENTS.forEach(el => emitSet.add(el));
                const emitArray = Array.from(emitSet);
                return k => includes(emitArray, k);
            }
            const DISABLED_ACTIONS = {
                ignore() {},
                fail() {
                    throw new Error("Emitter disabled");
                }
            };
            class EventEmitter extends NodeEventEmitter {
                constructor(options) {
                    super();
                    const {
                        direct,
                        emits,
                        unsafe,
                        formatEventName
                    } = options || {};
                    this.formatEventName = formatEventName || (name => name);
                    const bareEmit = this.emit.bind(this);
                    this._installDirectFilter(direct, bareEmit);
                    this._installErrorHandlers(unsafe);
                    this._installEmitVerifier();
                    this._listenerVerificationFilter = buildFilter(emits);
                    this._emits = emits;
                }
                _installDirectFilter(direct, bareEmit) {
                    if (!direct) return;
                    if (includes(BLACKLIST_DIRECT, direct)) {
                        throw new OperationError(`Cannot configure listener collection events [${BLACKLIST_DIRECT.join(", ")}] as direct`, ErrorSubcode.INTERNAL_ERROR);
                    }
                    this._defaultEmitDirect = (...args) => bareEmit(direct, ...args);
                    this.emitDirect = this._defaultEmitDirect;
                    this._directEventName = direct;
                    this.on = (eventName, listener) => {
                        this._verifyListenerEvent(eventName);
                        const ret = super.on(eventName, listener);
                        this._setEmitDirect(eventName, true, listener);
                        return ret;
                    };
                    this.addListener = (eventName, listener) => this.on(eventName, listener);
                    this.once = (eventName, listener) => {
                        this._verifyListenerEvent(eventName);
                        const ret = super.once(eventName, listener);
                        this._setEmitDirect(eventName, false);
                        return ret;
                    };
                    this.prependListener = (eventName, listener) => {
                        this._verifyListenerEvent(eventName);
                        const ret = super.prependListener(eventName, listener);
                        this._setEmitDirect(eventName, true, listener);
                        return ret;
                    };
                    this.prependOnceListener = (eventName, listener) => {
                        this._verifyListenerEvent(eventName);
                        const ret = super.prependOnceListener(eventName, listener);
                        this._setEmitDirect(eventName, false);
                        return ret;
                    };
                    this.removeAllListeners = eventName => {
                        const ret = super.removeAllListeners(eventName);
                        if (eventName === this._directEventName || eventName === undefined) {
                            this.emitDirect = this._defaultEmitDirect;
                        }
                        return ret;
                    };
                    this.removeListener = (eventName, listener) => {
                        const ret = super.removeListener(eventName, listener);
                        if (eventName === this._directEventName && this.listenerCount(eventName) === 0) {
                            this.emitDirect = this._defaultEmitDirect;
                        }
                        return ret;
                    };
                    this.directListenerCount = () => this.listenerCount(this._directEventName);
                    this.setOnFirstDirectListener = firstDirect => {
                        this._onFirstDirectListener = firstDirect;
                    };
                }
                _setEmitDirect(eventName, onListener, listener) {
                    if (eventName !== this._directEventName) {
                        return;
                    }
                    if (onListener && this.directListenerCount() === 1) {
                        this.emitDirect = listener;
                    } else {
                        this.emitDirect = this._defaultEmitDirect;
                    }
                    if (this.directListenerCount() === 1 && this._onFirstDirectListener !== undefined) {
                        this._onFirstDirectListener();
                    }
                }
                _verifyListenerEvent(event) {
                    if (!this._listenerVerificationFilter) return;
                    if (event === undefined || event === null) {
                        this.throwInternal(new OperationError(`Emitter rejects listener for no-name event: ${event}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                    }
                    if (!this._listenerVerificationFilter(event)) {
                        this.throwInternal(new OperationError(`Emitter rejects listeners for ${event}, emits ${this._emits}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                    }
                }
                _installEmitVerifier() {
                    if (false) {}
                }
                _installErrorHandlers(unsafe) {
                    if (unsafe) {
                        this.throwInternal = err => {
                            throw err;
                        };
                        return;
                    }
                    const emitBase = this.emit.bind(this);
                    this.throwInternal = function throwInternal(err) {
                        this._internalError = true;
                        throw err;
                    };
                    this.emit = (name, ...args) => {
                        try {
                            emitBase(name, ...args);
                        } catch (ex) {
                            if (this._internalError) {
                                this._internalError = undefined;
                                throw ex;
                            }
                            const err = this.formatErrorEvent(ex, name, ...args);
                            try {
                                LOG_WARN(`Listener for '${err.info.event.formattedName}' threw exception, dispatching to 'error'`);
                                emitBase("error", err);
                            } catch (innerEx) {
                                LOG_WARN("Listener for 'error' threw exception:", innerEx, "\nOriginal exception:", ex);
                            }
                        }
                    };
                }
                get isDirect() {
                    return this.emitDirect && this.emitDirect !== this._defaultEmitDirect;
                }
                formatErrorEvent(ex, name, ...args) {
                    const formattedName = this.formatEventName(name);
                    return Object.assign(new OperationError(`Unhandled error in event handler for '${formattedName}'`, ErrorSubcode.CALLBACK_ERROR, `On event: ${[ name, ...args ]} ${ex}`), {
                        stack: ex.stack,
                        info: {
                            event: {
                                name: name,
                                formattedName: formattedName,
                                args: args
                            },
                            error: ex
                        }
                    });
                }
                disableEmitter() {
                    this._defaultEmitDirect = DISABLED_ACTIONS.ignore;
                    this.removeAllListeners();
                    this.emit = DISABLED_ACTIONS.ignore;
                    this.addListener("removeListener", DISABLED_ACTIONS.fail);
                    this.addListener("newListener", DISABLED_ACTIONS.fail);
                }
            }
            module.exports.EventEmitter = EventEmitter;
        },
        "./modules/solclient-events/lib/timer.js": module => {
            class Timer {
                constructor(cancel) {
                    this.cancel = () => {
                        this.cancel = () => {};
                        cancel();
                    };
                }
                static newInterval(interval, onInterval, ...args) {
                    const timerRef = setInterval(onInterval, interval, ...args);
                    return new Timer(() => clearInterval(timerRef));
                }
                static newTimeout(timeout, onExpire, ...args) {
                    const timerRef = setTimeout(onExpire, timeout, ...args);
                    return new Timer(() => clearTimeout(timerRef));
                }
            }
            module.exports.Timer = Timer;
        },
        "./modules/solclient-factory/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                FactoryProfile,
                SolclientFactoryProfiles
            } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-profiles.js");
            const {
                ProfileBinding
            } = __webpack_require__("./modules/solclient-factory/lib/profile-binding.js");
            const {
                SolclientFactory
            } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory.js");
            const {
                SolclientFactoryProperties
            } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-properties.js");
            module.exports.FactoryProfile = FactoryProfile;
            module.exports.ProfileBinding = ProfileBinding;
            module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
            module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
            module.exports.SolclientFactory = SolclientFactory;
        },
        "./modules/solclient-factory/lib/profile-binding.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            let binding = null;
            const ProfileBinding = {
                get value() {
                    if (binding === null) {
                        throw new OperationError("Profile binding not initialized. Call solace.SolclientFactory.init");
                    }
                    return binding;
                },
                set value(value) {
                    binding = value;
                }
            };
            module.exports.ProfileBinding = ProfileBinding;
        },
        "./modules/solclient-factory/lib/solclient-factory-profiles.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            class FactoryProfile {
                get guaranteedMessagingEnabled() {
                    return undefined;
                }
                get cometEnabled() {
                    return undefined;
                }
                get topicUtf8Encode() {
                    return undefined;
                }
                get byteArrayAsString() {
                    return undefined;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        guaranteedMessagingEnabled: this.guaranteedMessagingEnabled,
                        cometEnabled: this.cometEnabled,
                        topicUtf8Encode: this.topicUtf8Encode,
                        byteArrayAsString: this.byteArrayAsString
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            class Version7Profile extends FactoryProfile {
                get guaranteedMessagingEnabled() {
                    return !!true;
                }
                get cometEnabled() {
                    return !!false;
                }
                get topicUtf8Encode() {
                    return false;
                }
                get byteArrayAsString() {
                    return true;
                }
            }
            const legacyInstance = new Version7Profile();
            class Version10Profile extends FactoryProfile {
                get guaranteedMessagingEnabled() {
                    return true;
                }
                get cometEnabled() {
                    return false;
                }
                get topicUtf8Encode() {
                    return true;
                }
                get byteArrayAsString() {
                    return true;
                }
            }
            const v10Instance = new Version10Profile();
            class Version105Profile extends FactoryProfile {
                get guaranteedMessagingEnabled() {
                    return true;
                }
                get cometEnabled() {
                    return false;
                }
                get topicUtf8Encode() {
                    return true;
                }
                get byteArrayAsString() {
                    return false;
                }
            }
            const forwardInstance = new Version105Profile();
            const SolclientFactoryProfiles = {
                _legacy: legacyInstance,
                _v10: v10Instance,
                _forward: forwardInstance,
                _default: legacyInstance,
                version7: legacyInstance,
                version10: v10Instance,
                version10_5: forwardInstance,
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        version7: this.version7,
                        version10: this.version10,
                        version10_5: this.version10_5
                    };
                },
                toString() {
                    return util_inspect(this);
                }
            };
            module.exports.FactoryProfile = FactoryProfile;
            module.exports.SolclientFactoryProfiles = SolclientFactoryProfiles;
        },
        "./modules/solclient-factory/lib/solclient-factory-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            function getDefaultLogLevel() {
                const {
                    LogLevel
                } = __webpack_require__("./modules/solclient-log/api.js");
                return LogLevel.INFO;
            }
            class SolclientFactoryProperties extends APIProperties {
                constructor(options) {
                    super({
                        logLevel: getDefaultLogLevel(),
                        logger: null
                    }, options);
                }
                get profile() {
                    return this._profile;
                }
                set profile(profile) {
                    this._profile = profile;
                }
                get logLevel() {
                    return Check.number(this._logLevel) ? this._logLevel : getDefaultLogLevel();
                }
                set logLevel(val) {
                    this._logLevel = val;
                }
                get logger() {
                    return this._logger || null;
                }
                set logger(val) {
                    this._logger = val;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    const {
                        LogLevel
                    } = __webpack_require__("./modules/solclient-log/api.js");
                    return {
                        logLevel: LogLevel.describe(this._logLevel),
                        profile: this._profile
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.SolclientFactoryProperties = SolclientFactoryProperties;
        },
        "./modules/solclient-factory/lib/solclient-factory.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                FactoryProfile,
                SolclientFactoryProfiles
            } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-profiles.js");
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ProfileBinding
            } = __webpack_require__("./modules/solclient-factory/lib/profile-binding.js");
            const {
                SolclientFactoryProperties
            } = __webpack_require__("./modules/solclient-factory/lib/solclient-factory-properties.js");
            const factoryState = {
                initializeCount: 0,
                initializers: []
            };
            const SolclientFactory = {
                addInitializer(func) {
                    factoryState.initializers.push(func);
                },
                createFactory(func) {
                    return function factoryMethod(...args) {
                        if (factoryState.initializeCount === 0) {
                            throw new OperationError("SolclientFactory not initialized", ErrorSubcode.INVALID_OPERATION);
                        }
                        return func(...args);
                    };
                },
                init(factoryProps) {
                    if (factoryState.initializeCount > 0) {
                        return this;
                    }
                    const props = new SolclientFactoryProperties(factoryProps);
                    const profile = factoryProps && factoryProps.profile || SolclientFactoryProfiles.version7;
                    Parameter.isInstanceOf("factoryProps.profile", profile, FactoryProfile);
                    ProfileBinding.value = profile;
                    factoryState.initializers.forEach(initializer => {
                        initializer.call(this, props, factoryState);
                    });
                    ++factoryState.initializeCount;
                    if (factoryProps !== undefined && factoryProps !== null) {
                        const {
                            LOG_DEBUG
                        } = __webpack_require__("./modules/solclient-log/api.js");
                        LOG_DEBUG("Factory properties:\n", factoryProps);
                    }
                    return this;
                },
                reset() {
                    factoryState.initializeCount = 0;
                },
                _getInitializeCount() {
                    return factoryState.initializeCount;
                },
                get profiles() {
                    return SolclientFactoryProfiles;
                }
            };
            module.exports.SolclientFactory = SolclientFactory;
        },
        "./modules/solclient-flow/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Flow
            } = __webpack_require__("./modules/solclient-flow/lib/flow.js");
            const {
                FlowOperation
            } = __webpack_require__("./modules/solclient-flow/lib/flow-operation.js");
            const {
                PrivateFlowEventName
            } = __webpack_require__("./modules/solclient-flow/lib/private-flow-event-names.js");
            module.exports.Flow = Flow;
            module.exports.FlowOperation = FlowOperation;
            module.exports.PrivateFlowEventName = PrivateFlowEventName;
        },
        "./modules/solclient-flow/lib/flow-operation.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const FlowOperation = {
                CONNECT: "FlowOperation_CONNECT",
                DISCONNECT: "FlowOperation_DISCONNECT",
                START: "FlowOperation_START",
                STOP: "FlowOperation_STOP",
                DISPOSE: "FlowOperation_DESTROY",
                GET_STATS: "FlowOperation_GET_STATS",
                RESET_STATS: "FlowOperation_RESET_STATS",
                GET_PROPERTIES: "FlowOperation_GET_PROPERTIES",
                GET_DESTINATION: "FlowOperation_GET_DESTINATION"
            };
            module.exports.FlowOperation = Enum.new(FlowOperation);
        },
        "./modules/solclient-flow/lib/flow.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode,
                NotImplementedError,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                EventEmitter
            } = __webpack_require__("./modules/solclient-events/api.js");
            const {
                FlowOperation
            } = __webpack_require__("./modules/solclient-flow/lib/flow-operation.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                PrivateFlowEventName
            } = __webpack_require__("./modules/solclient-flow/lib/private-flow-event-names.js");
            const {
                Stats
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const ALWAYS_OPS = [ FlowOperation.DISPOSE, FlowOperation.GET_STATS, FlowOperation.GET_PROPERTIES, FlowOperation.RESET_STATS ];
            class Flow extends EventEmitter {
                constructor(flowProperties, sessionInterfaceFactory, emitterOptions) {
                    const emitterOptionsFull = Object.assign({}, emitterOptions);
                    emitterOptionsFull.emits = (emitterOptionsFull.emits || []).concat(PrivateFlowEventName.values);
                    super(emitterOptionsFull);
                    const sessionInterface = sessionInterfaceFactory(this);
                    const self = this;
                    this.logger = new LogFormatter((...args) => [ `[session=${sessionInterface.sessionIdHex}]`, `[flow=${self.flowIdDec}]`, ...args ]);
                    this.log = this.logger.wrap(this.log, this);
                    this._disposing = false;
                    this._disposed = false;
                    this._userDisconnected = true;
                    this._properties = flowProperties;
                    this._sessionInterface = sessionInterface;
                    this._stats = new Stats(sessionInterface);
                    this._privateEventEmitter = new EventEmitter(emitterOptionsFull);
                }
                _emit(type, ...args) {
                    this._privateEventEmitter.emit(type, ...args);
                    this.emit(type, ...args);
                }
                _on(type, listener) {
                    this._privateEventEmitter.on(type, listener);
                }
                _once(type, listener) {
                    this._privateEventEmitter.once(type, listener);
                }
                _removeListener(type, listener) {
                    this._privateEventEmitter.removeListener(type, listener);
                }
                clearStats() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Clearing stats");
                    this._operationCheck(FlowOperation.RESET_STATS);
                    this._stats.resetStats();
                }
                connect() {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    LOG_DEBUG("Connecting");
                    this.userDisconnected = false;
                    this._operationCheck(FlowOperation.CONNECT);
                }
                dispose() {
                    const {
                        LOG_TRACE,
                        LOG_DEBUG
                    } = this.logger;
                    if (this._disposed || this._disposing) {
                        LOG_TRACE("Ignoring #dispose on disposed Guaranteed Message connection");
                        return;
                    }
                    LOG_TRACE("Disposing");
                    this._operationCheck(FlowOperation.DISPOSE);
                    this._disposing = true;
                    const terminate = () => {
                        this._disposed = true;
                        this._properties = null;
                        this._userDisconnected = true;
                        this._emit(this.getDisposedEvent());
                        this.disableEmitter();
                        this._privateEventEmitter.disableEmitter();
                        LOG_DEBUG("Disposed");
                    };
                    if (this._fsm._midDispatch) {
                        const terminateWithRunningFSM = () => {
                            this._fsm.terminateFsm();
                            terminate();
                        };
                        setTimeout(() => terminateWithRunningFSM(), 0);
                    } else {
                        terminate();
                    }
                }
                disconnect() {
                    this._operationCheck(FlowOperation.DISCONNECT);
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    LOG_DEBUG("Disconnecting");
                    this.userDisconnected = true;
                }
                _disconnectSession() {
                    this._operationCheck(FlowOperation.DISCONNECT);
                }
                getDisposedEvent() {
                    throw new NotImplementedError("Abstract method");
                }
                getProperties() {
                    this._operationCheck(FlowOperation.GET_PROPERTIES);
                    return this._properties.clone();
                }
                getStat(statType) {
                    this._operationCheck(FlowOperation.GET_STATS);
                    return this._stats.getStat(statType);
                }
                handleUncorrelatedControlMessage(message) {
                    throw new NotImplementedError("Guaranteed Message Connection does not implement a control message handler", message);
                }
                incStat(statType, value) {
                    this._stats.incStat(statType, value);
                }
                processFSMEvent(event) {
                    this._fsm.processEvent(event);
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        flowId: this.flowIdDec
                    };
                }
                toString() {
                    return this[Symbol.for("nodejs.util.inspect.custom")]();
                }
                get canAck() {
                    return !this.disposed;
                }
                get disposed() {
                    return this._disposed;
                }
                get flowIdDec() {
                    return this.flowId || "(N/A)";
                }
                get flowId() {
                    return new NotImplementedError("Flow does not implement ID accessor");
                }
                get session() {
                    return this._session;
                }
                get userDisconnected() {
                    return this._userDisconnecte;
                }
                set userDisconnected(value) {
                    this._userDisconnected = value;
                }
                _operationCheck(operation) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE(`Checking operation ${FlowOperation.describe(operation)}`);
                    if (this._disposed) {
                        throw new OperationError("Operation is invalid for Message Consumer in disposed state", ErrorSubcode.INVALID_OPERATION);
                    }
                    if (ALWAYS_OPS.some(v => v === operation)) return true;
                    if (operation === FlowOperation.DISCONNECT && this._isDisconnected()) {
                        throw new OperationError("Operation is invalid for Message Consumer in disconnected state", ErrorSubcode.INVALID_OPERATION);
                    }
                    return undefined;
                }
                _isDisconnected() {
                    throw new NotImplementedError("Flow#_isDisconnected not implemented");
                }
            }
            module.exports.Flow = Flow;
        },
        "./modules/solclient-flow/lib/private-flow-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const PrivateFlowEventName = {
                BIND_WAITING: "PrivateFlowEventName_bindWaiting"
            };
            module.exports.PrivateFlowEventName = Enum.new(PrivateFlowEventName);
        },
        "./modules/solclient-fsm/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                FsmEvent
            } = __webpack_require__("./modules/solclient-fsm/lib/event.js");
            const {
                State
            } = __webpack_require__("./modules/solclient-fsm/lib/state.js");
            const {
                StateMachine
            } = __webpack_require__("./modules/solclient-fsm/lib/state-machine.js");
            module.exports.FsmEvent = FsmEvent;
            module.exports.State = State;
            module.exports.StateMachine = StateMachine;
        },
        "./modules/solclient-fsm/lib/entry-point.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const StateLib = __webpack_require__("./modules/solclient-fsm/lib/state.js");
            const {
                FsmObject
            } = __webpack_require__("./modules/solclient-fsm/lib/object.js");
            class EntryPoint extends FsmObject {
                constructor(spec) {
                    super({
                        name: spec.entryPointName
                    });
                    let innerState;
                    this.impl = this.impl || {};
                    this.impl.outerState = new StateLib.State({
                        name: `${spec.state.getName()} outerEntryPoint: ${spec.entryPointName}`,
                        parentContext: spec.state.getParent()
                    }).initial(() => spec.state.transitionTo(innerState));
                    innerState = new StateLib.State({
                        name: `${spec.state.getName()} innerEntryPoint: ${spec.entryPointName}`,
                        parentContext: spec.state
                    }).initial(spec.func);
                }
                getDestState() {
                    return this.impl.outerState;
                }
            }
            module.exports.EntryPoint = EntryPoint;
        },
        "./modules/solclient-fsm/lib/event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                FsmObject
            } = __webpack_require__("./modules/solclient-fsm/lib/object.js");
            class FsmEvent extends FsmObject {}
            module.exports.FsmEvent = FsmEvent;
        },
        "./modules/solclient-fsm/lib/exit-point.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const StateLib = __webpack_require__("./modules/solclient-fsm/lib/state.js");
            const {
                FsmObject
            } = __webpack_require__("./modules/solclient-fsm/lib/object.js");
            class ExitPoint extends FsmObject {
                constructor(spec) {
                    super({
                        name: spec.exitPointName
                    });
                    let outerState;
                    this.impl.innerState = new StateLib.State({
                        name: `${spec.state.getName()} innerExitPoint: ${spec.exitPointName}`,
                        parentContext: spec.state
                    }).initial(() => spec.state.transitionTo(outerState));
                    outerState = new StateLib.State({
                        name: `${spec.state.getName()} outerExitPoint: ${spec.exitPointName}`,
                        parentContext: spec.state.getParent()
                    }).initial(spec.func);
                }
                getDestState() {
                    return this.impl.innerState;
                }
            }
            module.exports.ExitPoint = ExitPoint;
        },
        "./modules/solclient-fsm/lib/object.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            class FsmObject {
                constructor(spec) {
                    if (!spec) {
                        throw new OperationError("No spec provided");
                    }
                    if (!spec.name) {
                        throw new OperationError("No name provided for spec");
                    }
                    this.impl = {
                        name: spec.name
                    };
                }
                toString() {
                    let extraStringInfo = this.getExtraStringInfo();
                    if (extraStringInfo.length > 0) {
                        extraStringInfo = `; ${extraStringInfo}`;
                    }
                    return `{${this.constructor.name}: ${this.getName()}${extraStringInfo}}`;
                }
                getExtraStringInfo() {
                    return "";
                }
                getName() {
                    return this.impl.name;
                }
            }
            module.exports.FsmObject = FsmObject;
        },
        "./modules/solclient-fsm/lib/state-context.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const StateLib = __webpack_require__("./modules/solclient-fsm/lib/state.js");
            const {
                FsmObject
            } = __webpack_require__("./modules/solclient-fsm/lib/object.js");
            const {
                Iterator
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                makeIterator
            } = Iterator;
            class StateContext extends FsmObject {
                constructor(spec) {
                    super(spec);
                    this.impl = this.impl || {};
                    this.impl.logPadding = "";
                }
                getStateMachine() {
                    return this.impl.ancestorList[0];
                }
                initial(func) {
                    if (this.impl.initialReaction) {
                        this.log(`Replacing ${this} initialReaction ${this.impl.initialReaction} with ${func}`);
                    }
                    this.impl.initialReaction = func.bind(this);
                    return this;
                }
                transitionTo(state, action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: state,
                        action: action
                    });
                }
                terminate(action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: this.getStateMachine().getFinalState(),
                        action: action
                    });
                }
                getAncestorList() {
                    return this.impl.ancestorList;
                }
                log(...args) {
                    LOG_TRACE(this.impl.logPadding, ...args);
                }
                onInitial(event) {
                    let result;
                    if (this.impl.initialReaction) {
                        this.log(`Initial: for ${this}`);
                        result = this.impl.initialReaction(event);
                        if (result.external) {
                            throw new Error(`Initial reaction for ${this} returned external transitions`);
                        }
                        return result;
                    }
                    if (!(this instanceof StateLib.State)) {
                        throw new Error(`Missing initial reaction for ${this}`);
                    }
                    return this.transitionTo(this);
                }
                processReactionResult(result, e) {
                    let curContext = this;
                    if (!result.destState) {
                        return this;
                    }
                    const destStateIter = this.lowestCommonAncestor(result);
                    while (curContext !== destStateIter.deref()) {
                        curContext.onExit();
                        curContext = curContext.getParent();
                    }
                    if (result.action) {
                        result.action(curContext, e);
                    }
                    curContext.log(`Action: transition to ${result.destState} in context ${curContext}`);
                    for (destStateIter.incr(); !destStateIter.end(); destStateIter.incr()) {
                        curContext = destStateIter.deref();
                        curContext.onEntry();
                    }
                    const destInitial = curContext.onInitial(e);
                    if (destInitial.destState !== curContext) {
                        return curContext.processReactionResult(destInitial, e);
                    }
                    return curContext;
                }
                lowestCommonAncestor(reactionResult) {
                    const ancestorList = this.impl.ancestorList;
                    const destAncestorList = reactionResult.destState.getAncestorList();
                    let i;
                    if (ancestorList[0] !== destAncestorList[0]) {
                        throw new Error(`No common ancestor between (${this} in ${ancestorList[0]}) and (${reactionResult.destState} in ${destAncestorList[0]})`);
                    }
                    if (this === reactionResult.destState) {
                        i = ancestorList.length;
                        if (reactionResult.external) {
                            --i;
                        }
                    } else {
                        for (i = 1; i < ancestorList.length; ++i) {
                            if (ancestorList[i] !== destAncestorList[i]) {
                                break;
                            }
                        }
                        if (i === ancestorList.length || i === destAncestorList.length) {
                            if (reactionResult.external) {
                                --i;
                            }
                        }
                    }
                    return makeIterator(destAncestorList, i - 1);
                }
                setLogPadding(padding) {
                    this.impl.logPadding = padding;
                }
            }
            StateContext.ReactionResult = class {
                constructor(spec) {
                    if (!spec || !spec.caller || !(spec.caller instanceof StateContext)) {
                        throw new Error("spec.caller is required to be a StateContext");
                    }
                    if (!spec.caller.getStateMachine().isRunning()) {
                        throw new Error("ReactionResult objects can only be created while processing events");
                    }
                    if (spec.destState) {
                        if (!(spec.destState instanceof StateLib.State)) {
                            throw new Error("destState must be a State object");
                        }
                        if (spec.action && typeof spec.action !== "function") {
                            throw new Error("action must be a function");
                        }
                        this.destState = spec.destState;
                        this.action = spec.action;
                        this.external = spec.external;
                    }
                }
            };
            module.exports.StateContext = StateContext;
        },
        "./modules/solclient-fsm/lib/state-machine.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                State
            } = __webpack_require__("./modules/solclient-fsm/lib/state.js");
            const {
                StateContext
            } = __webpack_require__("./modules/solclient-fsm/lib/state-context.js");
            class StateMachine extends StateContext {
                constructor(spec) {
                    if (spec.parentContext) {
                        throw new Error(`State machine cannot have parent state: ${spec.parentContext}`);
                    }
                    super(spec);
                    this.impl.ancestorList = [ this ];
                    this.impl.eventQueue = [];
                    this.impl.finalState = new State({
                        name: "impl.final",
                        parentContext: this
                    });
                    this.impl.handleUncaughtException = (ev, exc) => {
                        LOG_ERROR(`Uncaught exception in ${this} while processing ${ev}: ${exc.stack}`);
                        return this.terminate();
                    };
                }
                process(func) {
                    const {
                        impl
                    } = this;
                    const {
                        eventQueue
                    } = impl;
                    eventQueue.push(func);
                    if (impl.processingEvents) {
                        return false;
                    }
                    impl.processingEvents = true;
                    while (eventQueue.length) {
                        const evt = eventQueue.shift();
                        evt.apply(this);
                    }
                    impl.processingEvents = false;
                    this._onEventCompletion();
                    return true;
                }
                start() {
                    if (this.getCurrentState()) {
                        throw new Error(`Cannot start ${this.getName()}; it is already started.`);
                    }
                    this.process(() => {
                        const result = this.onInitial();
                        if (result.destState === undefined) {
                            throw new Error(`Missing destination state from initial transition for ${this}`);
                        }
                        if (result.destState === this) {
                            throw new Error(`Destination state for initial transition for ${this} cannot be the FSM.`);
                        }
                        const destAncestorList = result.destState.getAncestorList();
                        if (destAncestorList[0] !== this) {
                            throw new Error(`Invalid destination state (${result.destState}) from initial transition for state machine (${this}); destState ancestor (${destAncestorList[0]})`);
                        }
                        this.impl.currentState = this.processReactionResult(result);
                    });
                }
                isRunning() {
                    return this.impl.processingEvents;
                }
                processEvent(evt) {
                    const {
                        impl
                    } = this;
                    if (!this.process(() => {
                        this.log(`Processing event ${evt}`);
                        let result;
                        if (impl.currentState) {
                            try {
                                result = impl.currentState.handleEvent(evt);
                                impl.currentState = impl.currentState.processReactionResult(result, evt);
                            } catch (exc) {
                                this.log(`Caught exception ${exc}, continuing`);
                                result = impl.handleUncaughtException.call(impl.currentState, evt, exc);
                                impl.currentState = impl.currentState.processReactionResult(result, evt);
                            }
                        }
                    })) {
                        this.log(`Deferring event ${evt}`);
                    }
                }
                terminateFsm() {
                    const curState = this.getCurrentState();
                    if (!curState) {
                        return;
                    }
                    if (this.impl.processingEvents) {
                        throw new Error("Cannot terminate state machine while FSM is processing " + "events. To terminate the FSM from within a reaction, return " + "State~terminate() from a reaction.");
                    }
                    this.process(() => {
                        const result = curState.terminate();
                        this.impl.currentState = curState.processReactionResult(result);
                    });
                }
                setPostEventAction(postEventAction) {
                    if (!this.impl.processingEvents) {
                        throw new Error("Cannot set post event hook unless FSM is processing events.");
                    }
                    if (!postEventAction || typeof postEventAction !== "function") {
                        throw new Error(`postEventAction must be a function; got (${postEventAction})`);
                    }
                    this.impl.postEventAction = postEventAction.bind(this);
                }
                _onEventCompletion() {
                    const action = this.impl.postEventAction;
                    if (action) {
                        this.impl.postEventAction = undefined;
                        this.log("Running post event action");
                        action.apply(this);
                    }
                }
                getCurrentState() {
                    return this.impl.currentState;
                }
                getActiveState(name) {
                    const activeStates = this.impl.currentState.getAncestorList();
                    for (let i = 1; i < activeStates.length; ++i) {
                        if (activeStates[i].getName() === name) {
                            return activeStates[i];
                        }
                    }
                    return undefined;
                }
                isStateActive(name) {
                    return this.getActiveState(name) !== undefined;
                }
                unhandledEventReaction(r) {
                    if (typeof r !== "function") {
                        throw new Error(`In ${this}: unhandled event reaction must be a function; got ${r}`);
                    }
                    this.impl.handleUnhandledEvent = r.bind(this);
                    return this;
                }
                uncaughtExceptionReaction(r) {
                    if (typeof r !== "function") {
                        throw new Error(`In ${this}: Uncaught exception reaction must be a function; got ${r}`);
                    }
                    this.impl.handleUncaughtException = r;
                    return this;
                }
                getFinalState() {
                    return this.impl.finalState;
                }
            }
            module.exports.StateMachine = StateMachine;
        },
        "./modules/solclient-fsm/lib/state.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                EntryPoint
            } = __webpack_require__("./modules/solclient-fsm/lib/entry-point.js");
            const {
                ExitPoint
            } = __webpack_require__("./modules/solclient-fsm/lib/exit-point.js");
            const {
                StateContext
            } = __webpack_require__("./modules/solclient-fsm/lib/state-context.js");
            class State extends StateContext {
                constructor(spec, extensions = null) {
                    super(spec);
                    const parentContext = spec.parentContext;
                    Object.assign(this.impl, {
                        parentContext: parentContext,
                        reactions: {},
                        entryPoints: {},
                        exitPoints: {},
                        ancestorList: [ ...parentContext.getAncestorList(), this ],
                        handleUnhandledEvent: e => parentContext.handleEvent ? parentContext.handleEvent(e) : parentContext.impl.handleUnhandledEvent(e)
                    });
                    if (parentContext) this.log = parentContext.log.bind(this);
                    Object.keys(extensions || {}).forEach(k => {
                        const extension = extensions[k];
                        this[k] = typeof extension === "function" ? extension.bind(this) : extension;
                    });
                    this.setLogPadding(" ".repeat(this.impl.ancestorList.length));
                }
                reaction(eventName, func) {
                    if (!eventName) throw new Error("No event name for reaction");
                    if (!func) throw new Error(`No reaction function for reaction ${eventName}`);
                    this.log(`Adding reaction to ${this} for event ${eventName}`);
                    if (this.impl.reactions[eventName]) {
                        this.log(`Replacing reaction ${this.impl.reactions[eventName]} with ${func}`);
                    }
                    this.impl.reactions[eventName] = func.bind(this);
                    return this;
                }
                entryPoint(entryPointName, func) {
                    if (!entryPointName) throw new Error("No entry point name for entry point");
                    if (!func) throw new Error(`No reaction function for entry point ${entryPointName}`);
                    this.log(`Adding entryPoint ${entryPointName} to ${this}`);
                    if (this.impl.entryPoints[entryPointName]) {
                        this.log(`EntryPoint ${entryPointName} already exists in ${this}`);
                        return this;
                    }
                    this.impl.entryPoints[entryPointName] = new EntryPoint({
                        state: this,
                        entryPointName: entryPointName,
                        func: func
                    });
                    return this;
                }
                exitPoint(exitPointName, func) {
                    if (!exitPointName) throw new Error("No exit point name for entry point");
                    if (!func) throw new Error(`No reaction function for exit point ${exitPointName}`);
                    this.log(`Adding exitPoint ${exitPointName} to ${this}`);
                    if (this.impl.exitPoints[exitPointName]) {
                        this.log(`ExitPoint ${exitPointName} already exists in  ${this}`);
                        return this;
                    }
                    this.impl.exitPoints[exitPointName] = new ExitPoint({
                        state: this,
                        exitPointName: exitPointName,
                        func: func
                    });
                    return this;
                }
                getEntryPointDestState(entryPointName) {
                    if (this.impl.entryPoints[entryPointName] === undefined) {
                        this.log(`${this}: EntryPoint ${entryPointName} does not exist.`);
                        return this;
                    }
                    return this.impl.entryPoints[entryPointName].getDestState();
                }
                getExitPointDestState(exitPointName) {
                    if (this.impl.exitPoints[exitPointName] === undefined) {
                        this.log(`${this}: ExitPoint ${exitPointName} does not exist.`);
                        return this;
                    }
                    return this.impl.exitPoints[exitPointName].getDestState();
                }
                entry(func) {
                    if (this.impl.appEntryFunc) {
                        this.log(`Replacing entry function ${this.impl.appEntryFunc} with ${func}`);
                    }
                    this.impl.appEntryFunc = func.bind(this);
                    return this;
                }
                exit(func) {
                    if (this.impl.appExitFunc) {
                        this.log(`Replacing exit function ${this.impl.appExitFunc} with ${func}`);
                    }
                    this.impl.appExitFunc = func.bind(this);
                    return this;
                }
                externalTransitionTo(state, action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: state,
                        action: action,
                        external: true
                    });
                }
                transitionToEntryPoint(state, entryPointName, action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: state.getEntryPointDestState(entryPointName),
                        action: action
                    });
                }
                transitionToExitPoint(state, exitPointName, action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: state.getExitPointDestState(exitPointName),
                        action: action
                    });
                }
                eventUnhandled() {
                    return new StateContext.ReactionResult({
                        caller: this
                    });
                }
                internalTransition(action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: this.getStateMachine().getCurrentState(),
                        action: action
                    });
                }
                terminate(action) {
                    return new StateContext.ReactionResult({
                        caller: this,
                        destState: this.getStateMachine().getFinalState(),
                        action: action
                    });
                }
                getParent() {
                    return this.impl.parentContext;
                }
                onEntry() {
                    this.log(`Entering: ${this}`);
                    if (this.impl.appEntryFunc) {
                        this.impl.appEntryFunc();
                    }
                }
                onExit() {
                    this.log(`Exiting: ${this}`);
                    if (this.impl.appExitFunc) {
                        this.impl.appExitFunc();
                    }
                }
                handleEvent(e) {
                    this.log(`Process: ${e}`);
                    const reaction = this.impl.reactions[e.getName()];
                    if (reaction) {
                        const result = reaction(e);
                        if (!result) {
                            this.log(`Reaction returned undefined: ${e} in ${this}`);
                        }
                        if (result.destState) {
                            this.log(`Handled: ${e}`);
                            return result;
                        }
                        this.log(`Unhandled: ${e} in ${this}`);
                    } else {
                        this.log(`No reaction: ${e} in ${this}`);
                    }
                    return this.impl.handleUnhandledEvent(e);
                }
            }
            module.exports.State = State;
        },
        "./modules/solclient-log/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ConsoleLogImpl
            } = __webpack_require__("./modules/solclient-log/lib/console-log-impl.js");
            const {
                GlobalBinding
            } = __webpack_require__("./modules/solclient-log/lib/global-binding.js");
            const {
                LogImpl
            } = __webpack_require__("./modules/solclient-log/lib/log-impl.js");
            const {
                LogLevel
            } = __webpack_require__("./modules/solclient-log/lib/log-levels.js");
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                SolclientFactory
            } = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                isEnumMember,
                isFunction
            } = Parameter;
            const {
                getImpl,
                getLogLevel,
                setImpl,
                setLogLevel
            } = GlobalBinding;
            const forwarder = {};
            function buildLogForwarder() {
                Object.assign(forwarder, {
                    trace(...args) {
                        const impl = getImpl();
                        if (impl && impl.trace && getLogLevel() >= LogLevel.TRACE) {
                            impl.trace.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    },
                    debug(...args) {
                        const impl = getImpl();
                        if (impl && impl.debug && getLogLevel() >= LogLevel.DEBUG) {
                            impl.debug.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    },
                    info(...args) {
                        const impl = getImpl();
                        if (impl && impl.info && getLogLevel() >= LogLevel.INFO) {
                            impl.info.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    },
                    warn(...args) {
                        const impl = getImpl();
                        if (impl && impl.warn && getLogLevel() >= LogLevel.WARN) {
                            impl.warn.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    },
                    error(...args) {
                        const impl = getImpl();
                        if (impl && impl.error && getLogLevel() >= LogLevel.ERROR) {
                            impl.error.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    },
                    fatal(...args) {
                        const impl = getImpl();
                        if (impl && impl.fatal) {
                            impl.fatal.apply(null, [ "solclientjs: ", ...args ]);
                        }
                    }
                });
            }
            buildLogForwarder();
            function addGlobalFuncs(source, target) {
                Object.keys(forwarder).forEach(k => {
                    target[`LOG_${k.toUpperCase()}`] = source[k];
                });
            }
            class LogFormatter {
                constructor(formatter) {
                    this._formatter = (() => {
                        if (typeof formatter === "function") return formatter;
                        if (typeof formatter === "string") return function prepend(...args) {
                            return [ formatter, ...args ];
                        };
                        if (!formatter) return function passthrough(...args) {
                            return [ ...args ];
                        };
                        return formatter;
                    })();
                    const self = this;
                    Object.keys(forwarder).forEach(key => {
                        this[key] = function forward(...args) {
                            return forwarder[key].apply(null, self._formatter(...args));
                        };
                    });
                    addGlobalFuncs(this, this);
                }
                get formatter() {
                    return this._formatter;
                }
                set formatter(func) {
                    this._formatter = func;
                }
                wrap(genericFunction, targetSelf) {
                    const self = this;
                    return function genericLogWrapper(...args) {
                        return genericFunction.apply(targetSelf, self._formatter(...args));
                    };
                }
            }
            SolclientFactory.getLogLevel = () => getLogLevel();
            SolclientFactory.setLogLevel = newLevel => {
                isEnumMember("logLevel", newLevel, LogLevel);
                setLogLevel(newLevel);
            };
            SolclientFactory.addInitializer(props => {
                setLogLevel(props.logLevel);
                const logger = props.logger || getImpl() || new ConsoleLogImpl();
                Object.keys(new LogImpl()).forEach(key => isFunction(`logger.${key}`, logger[key]));
                setImpl(logger);
            });
            addGlobalFuncs(forwarder, module.exports);
            module.exports.LogImpl = LogImpl;
            module.exports.LogLevel = LogLevel;
            module.exports.Binding = GlobalBinding;
            module.exports.ConsoleLogImpl = ConsoleLogImpl;
            GlobalBinding.setImpl(new ConsoleLogImpl());
            module.exports.LogFormatter = LogFormatter;
        },
        "./modules/solclient-log/lib/console-log-impl.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LogImpl
            } = __webpack_require__("./modules/solclient-log/lib/log-impl.js");
            const STUB = () => undefined;
            function generateLogHeader(levelStr) {
                const date = new Date();
                const levelStrPadding = " ".repeat(6 - levelStr.length);
                let YY = String(date.getFullYear());
                let MM = String(date.getMonth() + 1);
                let DD = String(date.getDate());
                let hh = String(date.getHours());
                let mm = String(date.getMinutes());
                let ss = String(date.getSeconds());
                let ms = String(date.getMilliseconds());
                YY = "0".repeat(4 - YY.length) + YY;
                MM = MM.length < 2 ? `0${MM}` : MM;
                DD = DD.length < 2 ? `0${DD}` : DD;
                hh = hh.length < 2 ? `0${hh}` : hh;
                mm = mm.length < 2 ? `0${mm}` : mm;
                ss = ss.length < 2 ? `0${ss}` : ss;
                ms = ms.length < 3 ? `0${ms}` : ms;
                ms = ms.length < 3 ? `0${ms}` : ms;
                return [ `${YY}-${MM}-${DD} ${hh}:${mm}:${ss}.${ms}`, `${levelStr}${levelStrPadding}` ];
            }
            class ConsoleLogImpl extends LogImpl {
                constructor(consoleIn) {
                    let _trace = STUB;
                    let _debug = STUB;
                    let _info = STUB;
                    let _warn = STUB;
                    let _error = STUB;
                    let _fatal = STUB;
                    const console = consoleIn || (typeof window === "undefined" ? global : window).console;
                    if (console && (console.log || console.warn)) {
                        if (console.log && console.log !== undefined) {
                            _trace = Function.prototype.bind.call(console.log, console);
                            _debug = Function.prototype.bind.call(console.log, console);
                        } else if (console.debug && typeof console.debug === "function") {
                            _trace = Function.prototype.bind.call(console.debug, console);
                            _debug = Function.prototype.bind.call(console.debug, console);
                        }
                        if (console.info && console.info !== undefined) {
                            _info = Function.prototype.bind.call(console.info, console);
                        } else {
                            _info = Function.prototype.bind.call(console.log, console);
                        }
                        if (console.warn && console.warn !== undefined) {
                            _warn = Function.prototype.bind.call(console.warn, console);
                        } else {
                            _warn = Function.prototype.bind.call(console.log, console);
                        }
                        if (console.error && console.error !== undefined) {
                            _error = Function.prototype.bind.call(console.error, console);
                            _fatal = Function.prototype.bind.call(console.error, console);
                        } else {
                            _error = Function.prototype.bind.call(console.log, console);
                            _fatal = Function.prototype.bind.call(console.log, console);
                        }
                    }
                    super((...args) => {
                        _trace(...generateLogHeader("TRACE"), ...args);
                    }, (...args) => {
                        _debug(...generateLogHeader("DEBUG"), ...args);
                    }, (...args) => {
                        _info(...generateLogHeader("INFO"), ...args);
                    }, (...args) => {
                        _warn(...generateLogHeader("WARN"), ...args);
                    }, (...args) => {
                        _error(...generateLogHeader("ERROR"), ...args);
                    }, (...args) => {
                        _fatal(...generateLogHeader("FATAL"), ...args);
                    });
                }
            }
            module.exports.ConsoleLogImpl = ConsoleLogImpl;
        },
        "./modules/solclient-log/lib/global-binding.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LogLevel
            } = __webpack_require__("./modules/solclient-log/lib/log-levels.js");
            const state = {
                impl: null,
                level: LogLevel.INFO
            };
            const LogBinding = {};
            LogBinding.getImpl = function getImpl() {
                return state.impl;
            };
            LogBinding.setImpl = function setImpl(impl) {
                state.impl = impl;
            };
            LogBinding.getLogLevel = function getLogLevel() {
                return state.level;
            };
            LogBinding.setLogLevel = function setLogLevel(level) {
                state.level = level;
            };
            module.exports.GlobalBinding = LogBinding;
        },
        "./modules/solclient-log/lib/log-impl.js": module => {
            class LogImpl {
                constructor(trace, debug, info, warn, error, fatal) {
                    Object.assign(this, {
                        trace: trace,
                        debug: debug,
                        info: info,
                        warn: warn,
                        error: error,
                        fatal: fatal
                    });
                }
                trace() {}
                debug() {}
                info() {}
                warn() {}
                error() {}
                fatal() {}
            }
            module.exports.LogImpl = LogImpl;
        },
        "./modules/solclient-log/lib/log-levels.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const LogLevel = {
                FATAL: 0,
                ERROR: 1,
                WARN: 2,
                INFO: 3,
                DEBUG: 4,
                TRACE: 5
            };
            module.exports.LogLevel = Enum.new(LogLevel);
        },
        "./modules/solclient-message-consumer/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ConsumerFlows
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-flows.js");
            const {
                ConsumerFSMEvent
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event.js");
            const {
                ConsumerFSMEventNames
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js");
            const {
                MessageConsumer
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer.js");
            const {
                MessageConsumerAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
            const {
                MessageConsumerEvent
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event.js");
            const {
                MessageConsumerEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
            const {
                MessageConsumerProperties
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-properties.js");
            const {
                QueueBrowser
            } = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser.js");
            const {
                QueueBrowserEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser-event-names.js");
            const {
                QueueBrowserProperties
            } = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser-properties.js");
            module.exports.ConsumerFlows = ConsumerFlows;
            module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
            module.exports.ConsumerFSMEventNames = ConsumerFSMEventNames;
            module.exports.MessageConsumer = MessageConsumer;
            module.exports.MessageConsumerEvent = MessageConsumerEvent;
            module.exports.MessageConsumerAcknowledgeMode = MessageConsumerAcknowledgeMode;
            module.exports.MessageConsumerEventName = MessageConsumerEventName;
            module.exports.MessageConsumerProperties = MessageConsumerProperties;
            module.exports.QueueBrowser = QueueBrowser;
            module.exports.QueueBrowserEventName = QueueBrowserEventName;
            module.exports.QueueBrowserProperties = QueueBrowserProperties;
        },
        "./modules/solclient-message-consumer/lib/application-acks.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum,
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LOG_DEBUG,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const ApplicationAckState = Enum.new({
                UNACKED: "UNACKED",
                ACKED_NOT_SENT: "ACKED_NOT_SENT",
                ACKED_SENT: "ACKED_SENT"
            });
            class ApplicationAck {
                constructor(id, state) {
                    if (id) {
                        this.exists = true;
                        this.id = id;
                        this.key = id.toString();
                        this.state = state || ApplicationAckState.UNACKED;
                    } else {
                        this.exists = false;
                    }
                }
                set(id, state) {
                    this.exists = true;
                    this.id = id;
                    this.key = id.toString();
                    this.state = state || ApplicationAckState.UNACKED;
                }
                clear() {
                    this.exists = false;
                    this.id = null;
                    this.key = null;
                    this.state = null;
                }
            }
            class ApplicationAckRingBuffer {
                constructor(size) {
                    LOG_DEBUG("Creating application ack ring buffer with size ", size, " retained size", size - 1);
                    assert(size >= 2);
                    this._size = size;
                    this._insertIndex = 0;
                    this._buffer = Array(size).fill(null).map(() => new ApplicationAck());
                    this._index = new Map();
                }
                reset() {
                    this._insertIndex = 0;
                    this._buffer.forEach(ack => {
                        ack.exists = false;
                    });
                    this._index.clear();
                }
                insert(id, beforeEvictCallback) {
                    assert(beforeEvictCallback);
                    assert(id);
                    const size = this._size;
                    const buffer = this._buffer;
                    const index = this._index;
                    const insertIndex = this._insertIndex;
                    assert(!buffer[insertIndex].exists, "Invariant not enforced (before): insert index not empty");
                    const inserting = buffer[insertIndex];
                    inserting.set(id, ApplicationAckState.UNACKED);
                    if (index.has(inserting.key)) {
                        LOG_ERROR(`Duplicate ID: ${index.get(inserting.key)} insertIndex: ${insertIndex}`);
                    }
                    index.set(inserting.key, insertIndex);
                    const evictingIndex = (insertIndex + 1) % size;
                    const evicting = buffer[evictingIndex];
                    let result;
                    try {
                        result = beforeEvictCallback(evicting.exists ? evicting : null);
                    } finally {
                        this._insertIndex = (insertIndex + 1) % size;
                        if (evicting.exists) {
                            index.delete(evicting.key);
                            evicting.clear();
                        }
                    }
                    assert(!buffer[this._insertIndex].exists, "Invariant not enforced (after): insert index not empty");
                    return result;
                }
                get length() {
                    return this._index.size;
                }
                front() {
                    if (this.length === 0) return null;
                    const buffer = this._buffer;
                    const insertIndex = this._insertIndex;
                    const size = this._size;
                    const firstIndex = (insertIndex + 1) % size;
                    if (buffer[firstIndex].exists) return buffer[firstIndex];
                    for (let rawIndex = firstIndex, lastIndex = firstIndex + size - 1; rawIndex <= lastIndex; ++rawIndex) {
                        const readIndex = rawIndex % size;
                        const element = buffer[readIndex];
                        if (element.exists) {
                            return element;
                        }
                    }
                    assert(this._index.size === 0, "#front() failed so buffer must be empty");
                    return null;
                }
                forEach(callback) {
                    if (this.length === 0) return;
                    const buffer = this._buffer;
                    const size = this._size;
                    let index = 0;
                    for (let rawIndex = this._insertIndex + 1, lastIndex = this._insertIndex + size; rawIndex <= lastIndex; ++rawIndex) {
                        const readIndex = rawIndex % size;
                        const element = buffer[readIndex];
                        if (element.exists) {
                            callback(element, index++, this);
                        }
                    }
                    assert(index > 0, "Not empty but did not dispatch");
                }
                updateAckState(id, state) {
                    const key = id.toString();
                    assert(this._index.has(key), "Ack key not found");
                    const buffer = this._buffer;
                    const updateIndex = this._index.get(key);
                    const existing = buffer[updateIndex];
                    assert(existing, "Ack key has no entry");
                    existing.state = state;
                }
                has(id) {
                    const key = id.toString();
                    return this._index.has(key);
                }
            }
            Object.assign(module.exports, {
                ApplicationAckState: ApplicationAckState,
                ApplicationAck: ApplicationAck,
                ApplicationAckRingBuffer: ApplicationAckRingBuffer
            });
        },
        "./modules/solclient-message-consumer/lib/consumer-flows.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                MessageConsumer
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer.js");
            const {
                MessageConsumerEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
            class ConsumerFlows {
                constructor() {
                    this._allFlows = new Set();
                    this._reconnectingFlows = new Set();
                    this._flowsById = {};
                }
                add(flow) {
                    assert(flow instanceof MessageConsumer, "Flow was not a consumer");
                    if (this._allFlows.has(flow)) {
                        return flow;
                    }
                    const flowUp = () => {
                        this._flowsById[flow.flowId] = flow;
                    };
                    const flowDisposed = () => {
                        const flowId = flow.flowId;
                        this._allFlows.delete(flow);
                        this._reconnectingFlows.delete(flow);
                        const flowById = this._flowsById[flowId];
                        if (flowById === flow) {
                            delete this._flowsById[flowId];
                        }
                    };
                    const flowReconnecting = () => {
                        flowDisposed();
                        this._reconnectingFlows.add(flow);
                    };
                    const flowReconnected = () => {
                        flowUp();
                        this._allFlows.add(flow);
                        this._reconnectingFlows.delete(flow);
                    };
                    const flowDown = () => {
                        this._reconnectingFlows.delete(flow);
                    };
                    flow._on(MessageConsumerEventName.UP, flowUp);
                    flow._on(MessageConsumerEventName.RECONNECTED, flowReconnected);
                    flow._on(MessageConsumerEventName.DISPOSED, flowDisposed);
                    flow._on(MessageConsumerEventName.RECONNECTING, flowReconnecting);
                    flow._on(MessageConsumerEventName.DOWN, flowDown);
                    flow._on(MessageConsumerEventName.DOWN_ERROR, flowDown);
                    this._allFlows.add(flow);
                    return flow;
                }
                get flows() {
                    return Array.from(this._allFlows);
                }
                get reconnectingFlows() {
                    return Array.from(this._reconnectingFlows);
                }
                getFlowById(flowId) {
                    return this._flowsById[flowId];
                }
                disposeAll() {
                    this._allFlows.forEach(flow => flow.dispose());
                }
            }
            module.exports.ConsumerFlows = ConsumerFlows;
        },
        "./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const ConsumerFSMEventNames = {
                SESSION_UP: "SESSION_UP",
                SESSION_UP_NO_AD: "SESSION_UP_NO_AD",
                SESSION_DOWN: "SESSION_DOWN",
                SESSION_DISCONNECT: "SESSION_DISCONNECT",
                FLOW_FAILED: "FLOW_FAILED",
                FLOW_UP: "FLOW_UP",
                FLOW_ACTIVE_IND: "FLOW_ACTIVE_IND",
                FLOW_CLOSE: "FLOW_CLOSE",
                FLOW_OPEN: "FLOW_OPEN",
                FLOW_UNBOUND: "FLOW_UNBOUND",
                ACK: "ACK",
                ACK_TIMEOUT: "ACK_TIMEOUT",
                BIND_TIMEOUT: "BIND_TIMEOUT",
                CREATE_TIMEOUT: "CREATE_TIMEOUT",
                UNBIND_TIMEOUT: "UNBIND_TIMEOUT",
                CAN_SEND: "CAN_SEND",
                TRANSPORT_ERROR: "TRANSPORT_ERROR",
                DISPOSE: "DISPOSE",
                VIRTUALROUTER_NAME_CHANGED: "VIRTUALROUTER_NAME_CHANGED",
                RECONNECT_INTERVAL_TIMEOUT: "RECONNECT_INTERVAL_TIMEOUT",
                BIND_RESPONSE: "BIND_RESPONSE",
                CREATE_FAILED: "CREATE_FAILED",
                CREATE_SUCCESS: "CREATE_SUCCESS"
            };
            module.exports.ConsumerFSMEventNames = Enum.new(ConsumerFSMEventNames);
        },
        "./modules/solclient-message-consumer/lib/consumer-fsm-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                FsmEvent
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            class ConsumerFSMEvent extends FsmEvent {
                constructor(spec, details) {
                    super(spec);
                    this.details = details;
                }
            }
            module.exports.ConsumerFSMEvent = ConsumerFSMEvent;
        },
        "./modules/solclient-message-consumer/lib/consumer-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                ApplicationAck,
                ApplicationAckRingBuffer,
                ApplicationAckState
            } = __webpack_require__("./modules/solclient-message-consumer/lib/application-acks.js");
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                CapabilityType
            } = __webpack_require__("./modules/solclient-session/api.js");
            const {
                ConsumerFSMEvent
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event.js");
            const {
                ConsumerFSMEventNames
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js");
            const {
                ConsumerStateNames
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-state-names.js");
            const {
                DestinationFromNetwork,
                DestinationType,
                Queue,
                Topic
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                ErrorResponseSubcodeMapper,
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                MessageConsumerAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
            const {
                MessageConsumerEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
            const {
                MessageDispatcher
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-dispatcher.js");
            const {
                PrivateFlowEventName
            } = __webpack_require__("./modules/solclient-flow/api.js");
            const {
                QueueAccessType,
                QueueDescriptor,
                QueuePermissions,
                QueueProperties,
                QueueType
            } = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                RgmidFactory
            } = __webpack_require__("./modules/solclient-message/api.js");
            const {
                State,
                StateMachine
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            const {
                Stats
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                StatType
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                Timer
            } = __webpack_require__("./modules/solclient-events/api.js");
            const {
                TransportAcks,
                TransportAckResult
            } = __webpack_require__("./modules/solclient-message-consumer/lib/transport-acks.js");
            const RING_BUFFER_SIZE = 512;
            const ZERO_APP_ACK = new ApplicationAck(Long.UZERO, ApplicationAckState.ACKED_SENT);
            class ConsumerFSM extends StateMachine {
                constructor({
                    name,
                    consumer,
                    sessionInterface,
                    properties
                } = {}) {
                    super({
                        name: name
                    });
                    const fsm = this;
                    const formatter = function formatter(...args) {
                        return [ `[session=${sessionInterface.sessionIdHex}]`, `[message-consumer-fsm=${consumer.flowIdDec}]`, ...args ];
                    };
                    const logger = this.logger = new LogFormatter(formatter);
                    const {
                        LOG_TRACE,
                        LOG_DEBUG,
                        LOG_INFO,
                        LOG_WARN,
                        LOG_ERROR
                    } = logger;
                    this.log = logger.wrap(this.log, this);
                    const autoAck = properties.acknowledgeMode === MessageConsumerAcknowledgeMode.AUTO;
                    this._consumer = consumer;
                    this._sessionInterface = sessionInterface;
                    this._acknowledgeTimeoutInMsecs = properties.acknowledgeTimeoutInMsecs;
                    this._acknowledgeThreshold = properties.acknowledgeThreshold;
                    this._localPreferredWindowSize = properties.windowSize;
                    this._localMaxWindowSize = properties.windowSize;
                    this._messageDispatch = new MessageDispatcher({
                        emitter: consumer,
                        autoAck: autoAck,
                        logger: logger
                    });
                    this._stats = new Stats();
                    this._resetRemoteConnectionState();
                    this._resetLocalConnectionState();
                    this._midDispatch = false;
                    this._replayStartLocation = properties.replayStartLocation;
                    this._errorCausingReconnect = null;
                    const emitEventActionType = "EMIT";
                    const startDispatchActionType = "DISPATCH";
                    const stopDispatchActionType = "NO_DISPATCH";
                    let postEventActions = [];
                    function preprocessPostEventActions(startIndex) {
                        LOG_TRACE(`Pre-processing post event action list @${startIndex}`, postEventActions);
                        const actionLocations = {};
                        postEventActions.forEach((action, i, arr) => {
                            function cancelAction(firstActionName, cancellingActionName) {
                                if (actionLocations[firstActionName] === undefined) {
                                    return;
                                }
                                const firstLocation = actionLocations[firstActionName];
                                LOG_TRACE(`Cancelling post event action ${firstActionName}@${firstLocation} with ${cancellingActionName}@${i}`);
                                actionLocations[firstActionName] = undefined;
                                arr[firstLocation] = null;
                                arr[i] = null;
                            }
                            if (i < startIndex || !action) {
                                LOG_TRACE(`Skip n/a action@${i}, start: ${startIndex}, action:`, action);
                                return;
                            }
                            switch (action.type) {
                              case emitEventActionType:
                                switch (action.data) {
                                  case MessageConsumerEventName.UP:
                                  case MessageConsumerEventName.ACTIVE:
                                  case MessageConsumerEventName.RECONNECTED:
                                    actionLocations[action.data] = i;
                                    break;

                                  case MessageConsumerEventName.DOWN:
                                  case MessageConsumerEventName.DOWN_ERROR:
                                    cancelAction(MessageConsumerEventName.UP, action.data);
                                    break;

                                  case MessageConsumerEventName.INACTIVE:
                                    cancelAction(MessageConsumerEventName.ACTIVE, action.data);
                                    break;

                                  default:
                                    LOG_ERROR(`Unexpected event in post-event action: ${action.data}`);
                                    break;
                                }
                                break;

                              case startDispatchActionType:
                                actionLocations[action.type] = i;
                                break;

                              case stopDispatchActionType:
                                cancelAction(startDispatchActionType, action.type);
                                break;

                              default:
                                break;
                            }
                        });
                    }
                    function processPostEventActions() {
                        let preprocessedActions = 0;
                        let i;
                        LOG_TRACE("Executing post event action list", postEventActions);
                        for (i = 0; i < postEventActions.length; ++i) {
                            if (preprocessedActions < postEventActions.length) {
                                preprocessPostEventActions(i);
                                preprocessedActions = postEventActions.length;
                            }
                            const action = postEventActions[i];
                            LOG_TRACE(`Action ${i}:`, action);
                            if (!action) {
                                continue;
                            }
                            switch (action.type) {
                              case emitEventActionType:
                                if (action.error !== undefined) {
                                    consumer._emit(action.data, action.error);
                                } else {
                                    consumer._emit(action.data);
                                }
                                break;

                              case stopDispatchActionType:
                                break;

                              case startDispatchActionType:
                                this.requestStartDispatchFSM();
                                break;

                              default:
                                LOG_ERROR(`Unhandled post event action type: ${action.type}`);
                                break;
                            }
                        }
                        postEventActions = [];
                    }
                    function addPostEventAction(type, data, error) {
                        let newEvent;
                        if (data !== undefined) {
                            newEvent = {
                                type: type,
                                data: data,
                                error: error
                            };
                        } else {
                            newEvent = {
                                type: type
                            };
                        }
                        postEventActions.push(newEvent);
                        LOG_TRACE(`Added post event action ${postEventActions.length}:`, newEvent);
                        if (postEventActions.length === 1) {
                            fsm.setPostEventAction(processPostEventActions);
                        }
                    }
                    const addEventToEmit = (event, error) => {
                        if (!properties.activeIndicationEnabled) {
                            if (event === MessageConsumerEventName.INACTIVE || event === MessageConsumerEventName.ACTIVE) {
                                LOG_TRACE(`Skip emitting ${event} due to disabled flow active indications`);
                                return;
                            }
                        }
                        addPostEventAction(emitEventActionType, event, error);
                    };
                    const requestStartDispatch = () => {
                        addPostEventAction(startDispatchActionType);
                    };
                    const requestStopDispatch = () => {
                        this.requestStopDispatchFSM();
                        addPostEventAction(stopDispatchActionType);
                    };
                    this._addEventToEmit = addEventToEmit;
                    this._requestStartDispatch = requestStartDispatch;
                    this._requestStopDispatch = requestStopDispatch;
                    function emitBindFailed(error) {
                        assert(error instanceof OperationError);
                        consumer._emit(MessageConsumerEventName.CONNECT_FAILED_ERROR, error);
                    }
                    function emitRebindFailed(error) {
                        assert(error instanceof OperationError);
                        consumer._emit(MessageConsumerEventName.DOWN_ERROR, error);
                    }
                    function verifyEndpointSubscription(destination) {
                        let error = null;
                        if (destination) {
                            const subInfo = destination.getSubscriptionInfo();
                            if (subInfo && (subInfo.isShare || subInfo.isNoExport) && !fsm._sessionInterface.isCapable(CapabilityType.SHARED_SUBSCRIPTIONS)) {
                                error = new OperationError("Shared Subscriptions not Supported", ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED);
                            }
                        }
                        return error;
                    }
                    function checkCapabilitiesChoicePoint(curState) {
                        let error = null;
                        if (fsm._replayStartLocation !== undefined && !fsm._sessionInterface.isCapable(CapabilityType.MESSAGE_REPLAY)) {
                            error = new OperationError("Message Replay Not Supported", ErrorSubcode.REPLAY_NOT_SUPPORTED);
                        } else if (properties.topicEndpointSubscription) {
                            error = verifyEndpointSubscription(properties.topicEndpointSubscription);
                        }
                        if (error) {
                            return curState.transitionTo(fsm.Unbound, () => emitBindFailed(error));
                        }
                        if (properties.createIfMissing && properties.queueDescriptor && properties.queueDescriptor.durable) {
                            return curState.transitionTo(fsm.CreateSent);
                        }
                        return curState.transitionTo(fsm.BindSent);
                    }
                    function handleAccidentalBind(msg) {
                        LOG_TRACE(`handleAccidentalBind mssg: ${msg}`);
                        const correlationTag = sessionInterface.getCorrelationTag();
                        const message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(msg.flowId, correlationTag);
                        sessionInterface.sendControl(message);
                        sessionInterface.enqueueRequest(correlationTag, () => this.handleAccidentalBind(msg), properties.connectTimeoutInMsecs, null, null);
                    }
                    this.unhandledEventReaction(function onUnhandledEvent(event) {
                        switch (event.getName()) {
                          case ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED:
                            LOG_INFO("VirtualRouter name change: clearing all acknowledgement state");
                            fsm._resetRemoteConnectionState();
                            return this;

                          case ConsumerFSMEventNames.FLOW_UNBOUND:
                            LOG_INFO("Received unsolicited unbind. Flow may be manually reconnected.");
                            return this.transitionToUnbound(MessageConsumerEventName.DOWN_ERROR, event.details);

                          case ConsumerFSMEventNames.DISPOSE:
                            fsm._dispose();
                            return fsm.getCurrentState().terminate();

                          case ConsumerFSMEventNames.BIND_RESPONSE:
                            LOG_TRACE("Unhandled bind, assuming accidental BIND duplication");
                            handleAccidentalBind(event.details);
                            return this;

                          default:
                            LOG_TRACE(`Ignoring event ${event.getName()} in state ${this.getCurrentState().getName()}`);
                            return this;
                        }
                    });
                    this.initial(function onInitial() {
                        return this.transitionTo(fsm.Unbound, context => {
                            LOG_INFO(`Starting ${context.getStateMachine().getName()}`);
                        });
                    });
                    this.Unbound = new State({
                        name: ConsumerStateNames.UNBOUND,
                        parentContext: fsm
                    }, {
                        emitDisabledEvent() {
                            consumer._emit(MessageConsumerEventName.GM_DISABLED);
                        }
                    }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                        return this.transitionTo(this);
                    }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.transitionTo(this);
                    }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSesssionDisconnect() {
                        return this.transitionTo(this);
                    }).reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
                        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                    }).reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
                        if (fsm._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) {
                            return this.transitionTo(fsm.Unbound.AwaitFlowOpen);
                        }
                        LOG_WARN(`Consumer is not supported by router for this client on sessionId 0x${fsm._sessionInterface.sessionIdHex}`);
                        return this.internalTransition(() => this.emitDisabledEvent());
                    }).reaction(ConsumerFSMEventNames.SESSION_UP_NO_AD, function onSessionUpNoAD() {
                        return this.internalTransition(() => this.emitDisabledEvent());
                    }).exit(() => {
                        fsm._connectAttempts = properties.connectAttempts;
                    });
                    this.Unbound.AwaitSessionUp = new State({
                        name: ConsumerStateNames.UNBOUND_AWAIT_SESSION_UP,
                        parentContext: this.Unbound
                    }, {
                        emitBindWaiting() {
                            consumer._emit(PrivateFlowEventName.BIND_WAITING);
                        }
                    }).entry(function onEntry() {
                        this.emitBindWaiting();
                    }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.internalTransition();
                    }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                        return this.internalTransition();
                    }).reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
                        return checkCapabilitiesChoicePoint(this);
                    });
                    this.Unbound.AwaitFlowOpen = new State({
                        name: ConsumerStateNames.UNBOUND_AWAIT_FLOWOPEN,
                        parentContext: this.Unbound
                    }).reaction(ConsumerFSMEventNames.FLOW_OPEN, function onFlowOpen() {
                        return checkCapabilitiesChoicePoint(this);
                    });
                    this.BindSentExtensions = {
                        sendBindRequest() {
                            const correlationTag = sessionInterface.getCorrelationTag();
                            const transportAcks = fsm._transportAcks;
                            fsm._endpointEnsure();
                            const endpoint = fsm._endpoint;
                            const subscription = fsm._subscription;
                            const message = SMFLib.AdProtocolMessage.getOpenMessageConsumer(properties.queueDescriptor, properties.queueProperties, endpoint, subscription, correlationTag, properties.windowSize, properties.noLocal, properties.activeIndicationEnabled, transportAcks.lastAcked, transportAcks.lastReceived, properties.browser, fsm._replayStartLocation, consumer.endpointErrorId);
                            sessionInterface.sendControl(message);
                            sessionInterface.enqueueRequest(correlationTag, this.handleBindTimeout.bind(this), properties.connectTimeoutInMsecs, null, this.handleBindResponse.bind(this));
                            LOG_TRACE("Sent consumer bind request with arguments", [ properties.queueDescriptor, properties.queueProperties, endpoint, subscription, correlationTag, properties.windowSize, properties.noLocal, properties.activeIndicationEnabled, transportAcks.lastAcked, transportAcks.lastReceived, properties.browser, fsm._replayStartLocation, consumer.endpointErrorId ]);
                        },
                        cancelBindRequestTimer() {
                            LOG_TRACE("Cancelling bindRequestTimer.");
                            this.bindRequestTimer.cancel();
                        },
                        handleBindTimeout() {
                            LOG_INFO("Bind timeout");
                            fsm.processEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.BIND_TIMEOUT
                            }));
                        },
                        handleExpectedBind(msg) {
                            const accessTypeOrDefault = x => x === undefined ? QueueAccessType.EXCLUSIVE : x;
                            const attrs = {
                                lastMsgIdAcked: msg.getLastMsgIdAcked(),
                                flowId: msg.getFlowId(),
                                accessType: accessTypeOrDefault(msg.getAccessType()),
                                topicEndpointBytes: msg.getTopicEndpointBytes(),
                                grantedPermissions: msg.getGrantedPermissions(),
                                allOthersPermissions: msg.getAllOthersPermissions(),
                                respectsTTL: msg.getRespectsTTL(),
                                activeFlow: msg.getActiveFlow(),
                                wantFlowChangeNotify: msg.getWantFlowChangeNotify(),
                                discardBehavior: msg.getQueueDiscardBehavior(),
                                deliveryCountSent: msg.getEndpointDeliveryCountSent(),
                                endpointId: msg.getEndpointId(),
                                maxUnackedMessages: msg.getMaxUnackedMessages(),
                                endpointErrorId: msg.getEndpointErrorId(),
                                spoolerUniqueId: msg.getSpoolerUniqueId(),
                                quota: msg.getQuota(),
                                maxMsgSize: msg.getMaxMsgSize(),
                                maxRedelivery: msg.getMaxRedelivery()
                            };
                            LOG_DEBUG("BIND response attributes:", attrs);
                            Object.assign(consumer, {
                                accessType: attrs.accessType,
                                queueDiscardBehavior: attrs.discardBehavior,
                                deliveryCountSent: attrs.deliveryCountSent,
                                endpointId: attrs.endpointId,
                                respectsTTL: attrs.respectsTTL,
                                flowId: attrs.flowId,
                                permissions: attrs.grantedPermissions,
                                wantFlowChangeNotify: attrs.wantFlowChangeNotify,
                                endpointErrorId: attrs.endpointErrorId,
                                spoolerUniqueId: attrs.spoolerUniqueId
                            });
                            if (fsm._sessionInterface.isCapable(CapabilityType.BR_REPLAY_ERRORID)) {
                                consumer.endpointErrorId = attrs.endpointErrorId;
                            }
                            if (attrs.topicEndpointBytes && attrs.topicEndpointBytes.length) {
                                attrs.endpoint = DestinationFromNetwork.createDestinationFromBytes(attrs.topicEndpointBytes);
                                LOG_DEBUG("Overwriting local endpoint:", fsm._endpoint, "with remote:", attrs.endpoint);
                                fsm._endpoint = attrs.endpoint;
                                const consumerProperties = fsm._consumer._properties;
                                consumerProperties.queueDescriptor = new QueueDescriptor({
                                    name: attrs.endpoint.name,
                                    type: consumerProperties.queueDescriptor.type,
                                    durable: consumerProperties.queueDescriptor.durable
                                });
                            }
                            const consumerProperties = fsm._consumer._properties;
                            consumerProperties.queueProperties = new QueueProperties({
                                respectsTTL: attrs.respectsTTL,
                                permissions: attrs.allOthersPermissions,
                                quotaMB: attrs.quota,
                                maxMessageSize: attrs.maxMsgSize,
                                discardBehavior: attrs.discardBehavior,
                                maxMessageRedelivery: attrs.maxRedelivery,
                                accessType: attrs.accessType
                            });
                            if (!consumerProperties.queueProperties.permissions) {
                                consumerProperties.queueProperties.permissions = QueuePermissions.NONE;
                            }
                            Object.assign(fsm, {
                                _active: attrs.activeFlow,
                                _remoteWindowSize: attrs.maxUnackedMessages
                            });
                            if (Long.UZERO.eq(fsm._transportAcks.lastAcked)) {
                                fsm._transportAcks.lastAcked = attrs.lastMsgIdAcked || Long.UZERO;
                            } else {
                                LOG_DEBUG(`Retaining last acked/last received: ${fsm._transportAcks}`);
                            }
                        },
                        handleBindResponse(msg) {
                            LOG_TRACE(`handleBindResponse called for message ${msg}`);
                            if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.BIND) {
                                LOG_INFO(`Unexpected message type in bind response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`);
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_FAILED
                                }, new OperationError(`Unexpected bind response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`, ErrorSubcode.PROTOTOCOL_ERROR)));
                            }
                            const header = msg.smfHeader;
                            const responseCode = header.pm_respcode;
                            if (responseCode === null) {
                                this._consumer.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                LOG_DEBUG(`Drop Open-Publisher-Flow Request message on sessionId 0x${this._sessionInterface.sessionIdHex}`);
                                return undefined;
                            }
                            if (responseCode !== 200) {
                                const description = header.pm_respstr;
                                const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                LOG_INFO("Flow failed (bind):", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                LOG_DEBUG("subcode:", errorSubcode);
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_FAILED
                                }, new OperationError(description, errorSubcode, {
                                    responseCode: responseCode
                                })));
                            }
                            const respEvent = {
                                name: ConsumerFSMEventNames.BIND_RESPONSE
                            };
                            return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                        }
                    };
                    this.BindSent = new State({
                        name: ConsumerStateNames.BIND_SENT,
                        parentContext: fsm
                    }, this.BindSentExtensions).entry(function onEntry() {
                        fsm._connectAttempts--;
                        this.sendBindRequest();
                        this.bindRequestTimer = Timer.newTimeout(properties.connectTimeoutInMsecs, this.handleBindTimeout);
                    }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                    }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                        return this.transitionTo(fsm.Unbound.AwaitSessionUp, () => fsm._addEventToEmit(MessageConsumerEventName.DOWN));
                    }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                        return this.transitionTo(fsm.UnbindSent);
                    }).reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function onBindTimeout() {
                        LOG_TRACE(`Bind timeout, connectAttempts left: ${fsm._connectAttempts}`);
                        if (fsm._connectAttempts > 0) {
                            return this.externalTransitionTo(fsm.BindSent);
                        }
                        return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(new OperationError("Bind failed due to timeout", ErrorSubcode.TIMEOUT)));
                    }).reaction(ConsumerFSMEventNames.FLOW_FAILED, function onFlowFailed(evt) {
                        return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(evt.details));
                    }).reaction(ConsumerFSMEventNames.BIND_RESPONSE, function onBindResponse(event) {
                        this.handleExpectedBind(event.details);
                        return this.transitionTo(fsm.FlowUp);
                    }).reaction(ConsumerFSMEventNames.FLOW_UP, function onFlowUp() {
                        return this.transitionTo(fsm.FlowUp);
                    }).exit(function onExit() {
                        this.cancelBindRequestTimer();
                    });
                    this.Reconnecting = new State({
                        name: ConsumerStateNames.RECONNECTING,
                        parentContext: fsm
                    }).entry(function onEntry() {
                        LOG_TRACE("RECONNECTING onEntry: emitting RECONNECTING, resetting attempt counters");
                        LOG_TRACE(`this._errorCausingReconnect: ${this._errorCausingReconnect}`);
                        LOG_TRACE(`fsm._errorCausingReconnect: ${fsm._errorCausingReconnect}`);
                        consumer._emit(MessageConsumerEventName.RECONNECTING, fsm._errorCausingReconnect);
                        fsm._connectAttempts = properties.connectAttempts;
                        fsm.reconnectAttempts = properties.reconnectAttempts;
                    }).initial(function onInitial() {
                        return this.transitionTo(fsm.Reconnecting.RBindSent);
                    }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                        return this.transitionTo(fsm.Reconnecting.RAwaitSessionUp);
                    }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.transitionTo(fsm.Reconnecting.RAwaitSessionUp);
                    });
                    this.Reconnecting.RAwaitSessionUp = new State({
                        name: ConsumerStateNames.RECONNECTING_AWAIT_SESSION_UP,
                        parentContext: this.Reconnecting
                    }).reaction(ConsumerFSMEventNames.SESSION_UP, function onSessionUp() {
                        fsm._connectAttempts = properties.connectAttempts;
                        return this.transitionTo(fsm.Reconnecting.RBindSent);
                    });
                    this.Reconnecting.RBindSent = new State({
                        name: ConsumerStateNames.RECONNECTING_BIND_SENT,
                        parentContext: this.Reconnecting
                    }, this.BindSentExtensions).entry(function onEntry() {
                        fsm._connectAttempts--;
                        this.sendBindRequest();
                        this.bindRequestTimer = Timer.newTimeout(properties.connectTimeoutInMsecs, this.handleBindTimeout);
                    }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                        return this.transitionTo(fsm.UnbindSent);
                    }).reaction(ConsumerFSMEventNames.BIND_TIMEOUT, function onBindTimeout() {
                        LOG_TRACE(`Bind timeout during reconnect, connectAttempts left: ${fsm._connectAttempts}`);
                        if (fsm._connectAttempts > 0) {
                            return this.externalTransitionTo(fsm.Reconnecting.RBindSent);
                        }
                        LOG_TRACE("Running out of rebinds is a non rebindable failure, so break the reconect loop.");
                        return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(new OperationError("Rebind failed due to timeout", ErrorSubcode.TIMEOUT)));
                    }).reaction(ConsumerFSMEventNames.FLOW_FAILED, function onFlowFailed(evt) {
                        if (fsm.reconnectAttempts > 0 || fsm.reconnectAttempts === -1) {
                            if (evt && evt.details && evt.details.subcode) {
                                if (evt.details.subcode === ErrorSubcode.QUEUE_SHUTDOWN || evt.details.subcode === ErrorSubcode.TOPIC_ENDPOINT_SHUTDOWN || evt.details.subcode === ErrorSubcode.GM_UNAVAILABLE) {
                                    LOG_TRACE(`ReconnectAttempts left: ${fsm.reconnectAttempts} subcode: ${evt.details.subcode}, giving it another shot.`);
                                    return this.transitionTo(fsm.Reconnecting.RAwaitTimer);
                                }
                            } else {
                                LOG_DEBUG(`Hmm, no subcode in FLOW_FAILED? ${evt}`);
                            }
                        } else {
                            LOG_TRACE(`Ran out of reconnectAttempts: ${fsm.reconnectAttempts}`);
                        }
                        return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitRebindFailed(evt.details));
                    }).reaction(ConsumerFSMEventNames.BIND_RESPONSE, function onBindResponse(event) {
                        this.handleExpectedBind(event.details);
                        return this.transitionTo(fsm.FlowUp, () => fsm._addEventToEmit(MessageConsumerEventName.RECONNECTED));
                    }).reaction(ConsumerFSMEventNames.FLOW_UP, function onFlowUp() {
                        return this.transitionTo(fsm.FlowUp, () => fsm._addEventToEmit(MessageConsumerEventName.RECONNECTED));
                    }).exit(function onExit() {
                        this.cancelBindRequestTimer();
                    });
                    this.Reconnecting.RAwaitTimer = new State({
                        name: ConsumerStateNames.RECONNECTING_AWAIT_TIMER,
                        parentContext: this.Reconnecting
                    }, {
                        handleReconnectIntervalTimeout() {
                            LOG_DEBUG("Reconnect interval timeout (expected)");
                            fsm.processEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.RECONNECT_INTERVAL_TIMEOUT
                            }));
                        },
                        cancelReconnectIntervalTimer() {
                            this.reconnectIntervalTimer.cancel();
                        }
                    }).entry(function onEntry() {
                        if (fsm.reconnectAttempts > 0) {
                            --fsm.reconnectAttempts;
                        }
                        LOG_TRACE(`Setting up timer for ${properties.reconnectIntervalInMsecs}. reconnectAttempts left: ${fsm.reconnectAttempts}`);
                        this.reconnectIntervalTimer = Timer.newTimeout(properties.reconnectIntervalInMsecs, this.handleReconnectIntervalTimeout);
                    }).exit(function onExit() {
                        this.cancelReconnectIntervalTimer();
                    }).reaction(ConsumerFSMEventNames.RECONNECT_INTERVAL_TIMEOUT, function onTimeout() {
                        fsm._connectAttempts = properties.connectAttempts;
                        return this.transitionTo(fsm.Reconnecting.RBindSent);
                    });
                    const flowUpFSM = this.FlowUp = new State({
                        name: ConsumerStateNames.FLOW_UP,
                        parentContext: fsm
                    }).initial(function onInitial() {
                        return this.transitionTo(fsm._active === 0 ? flowUpFSM.XferInactive : flowUpFSM.Xfer);
                    }).entry(() => {
                        fsm._replayStartLocation = undefined;
                        if (!fsm._errorCausingReconnect) {
                            LOG_TRACE("Emittging UP, because there is no errorCausingReconnect");
                            fsm._addEventToEmit(MessageConsumerEventName.UP);
                        } else {
                            LOG_TRACE("Not emittging UP, because there is errorCausingReconnect");
                            fsm._errorCausingReconnect = null;
                        }
                    }).reaction(ConsumerFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.transitionTo(fsm.Unbound.AwaitSessionUp);
                    }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDisconnect() {
                        return this.transitionTo(fsm.Unbound.AwaitSessionUp, () => fsm._addEventToEmit(MessageConsumerEventName.DOWN));
                    }).reaction(ConsumerFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                        return this.transitionTo(fsm.UnbindSent);
                    }).reaction(ConsumerFSMEventNames.FLOW_UNBOUND, event => fsm.transitionToUnboundFromUp(properties, MessageConsumerEventName.DOWN_ERROR, event.details));
                    flowUpFSM.Xfer = new State({
                        name: ConsumerStateNames.FLOW_UP_XFER,
                        parentContext: flowUpFSM
                    }).entry(() => {
                        fsm._addEventToEmit(MessageConsumerEventName.ACTIVE);
                        fsm._sendAcks(true);
                        fsm._requestStartDispatch();
                    }).exit(() => {
                        fsm._addEventToEmit(MessageConsumerEventName.INACTIVE);
                        fsm._requestStopDispatch();
                    }).reaction(ConsumerFSMEventNames.SESSION_DISCONNECT, function onSessionDown() {
                        fsm._sendAcks(true);
                        return this.eventUnhandled();
                    });
                    flowUpFSM.XferInactive = new State({
                        name: ConsumerStateNames.FLOW_UP_XFER_INACTIVE,
                        parentContext: flowUpFSM
                    }).reaction(ConsumerFSMEventNames.FLOW_ACTIVE_IND, function onFlowActiveIndication() {
                        return this.transitionTo(flowUpFSM.Xfer);
                    });
                    this.UnbindSent = new State({
                        name: ConsumerStateNames.UNBIND_SENT,
                        parentContext: fsm
                    }, {
                        sendUnbindRequest() {
                            fsm._endpointClear();
                            try {
                                const correlationTag = sessionInterface.getCorrelationTag();
                                const message = SMFLib.AdProtocolMessage.getCloseMessageConsumer(consumer.flowId, correlationTag);
                                sessionInterface.sendControl(message);
                                sessionInterface.enqueueRequest(correlationTag, () => this.handleUnbindTimeout(), properties.connectTimeoutInMsecs, null, response => this.handleUnbindResponse(response));
                                LOG_INFO("Sent consumer unbind request with arguments", {
                                    flowId: consumer.flowId,
                                    correlationTag: correlationTag
                                });
                            } catch (e) {
                                LOG_INFO(`Exception in sendUnbindRequest while trying to send unbind request: ${e}`);
                                LOG_DEBUG(`Session (${sessionInterface.getCurrentStateName()}) assumed lost before flow unbind could be sent. Considering this flow unbound.`);
                                fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.FLOW_UNBOUND
                                }));
                            }
                        },
                        handleUnbindTimeout() {
                            LOG_INFO("Unbind timeout");
                            return fsm.processEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.UNBIND_TIMEOUT
                            }));
                        },
                        handleUnbindResponse(msg) {
                            if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.UNBIND) {
                                LOG_INFO(`Unexpected message type in bind response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`);
                            }
                            const responseCode = msg.smfHeader.pm_respcode;
                            const description = msg.smfHeader.pm_respstr;
                            const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                            consumer.endpointErrorId = msg.getEndpointErrorId();
                            LOG_INFO("Flow failed (unbind):", responseCode, description, ErrorSubcode.describe(errorSubcode));
                            return fsm.processEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.FLOW_UNBOUND
                            }, new OperationError(description, errorSubcode, responseCode)));
                        }
                    }).entry(function onEntry() {
                        this.sendUnbindRequest();
                    }).reaction(ConsumerFSMEventNames.UNBIND_TIMEOUT, function onUnbindTimeout() {
                        return this.externalTransitionTo(fsm.UnbindSent);
                    }).reaction(ConsumerFSMEventNames.FLOW_UNBOUND, () => fsm.transitionToUnbound(MessageConsumerEventName.DOWN));
                    this.CreateSent = new State({
                        name: ConsumerStateNames.CREATE_SENT,
                        parentContext: fsm
                    }, {
                        sendCreateRequest() {
                            const correlationTag = sessionInterface.getCorrelationTag();
                            const message = SMFLib.AdProtocolMessage.getCreate(properties.queueDescriptor, properties.queueProperties, correlationTag);
                            sessionInterface.sendControl(message);
                            sessionInterface.enqueueRequest(correlationTag, this.handleCreateTimeout.bind(this), properties.connectTimeoutInMsecs, null, this.handleCreateResponse.bind(this));
                        },
                        handleCreateTimeout() {
                            LOG_INFO("Create timeout");
                            fsm.processEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.CREATE_TIMEOUT
                            }));
                        },
                        handleCreateResponse(msg) {
                            LOG_TRACE(`handleCreateResponse called for message ${msg}`);
                            if (msg.msgType !== SMFLib.SMFAdProtocolMessageType.CREATE) {
                                LOG_INFO(`Unexpected message type in create response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`);
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.CREATE_FAILED
                                }, new OperationError(`Unexpected create response: ${SMFLib.SMFAdProtocolMessageType.describe(msg.msgType)}`, ErrorSubcode.PROTOTOCOL_ERROR)));
                            }
                            const header = msg.smfHeader;
                            const responseCode = header.pm_respcode;
                            if (responseCode !== 200) {
                                const description = header.pm_respstr;
                                const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                                LOG_INFO("Endpoint create failed:", responseCode, description, ErrorSubcode.describe(errorSubcode));
                                LOG_DEBUG("subcode:", errorSubcode);
                                if (errorSubcode === ErrorSubcode.ENDPOINT_ALREADY_EXISTS) {
                                    LOG_TRACE("subcode recognized as ALREADY EXISTS:", errorSubcode);
                                    const respEvent = {
                                        name: ConsumerFSMEventNames.CREATE_SUCCESS
                                    };
                                    return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                                }
                                LOG_TRACE("subcode not recognized as ALREADY EXISTS:", errorSubcode);
                                return fsm.processEvent(new ConsumerFSMEvent({
                                    name: ConsumerFSMEventNames.CREATE_FAILED
                                }, new OperationError(description, errorSubcode, {
                                    responseCode: responseCode
                                })));
                            }
                            const respEvent = {
                                name: ConsumerFSMEventNames.CREATE_SUCCESS
                            };
                            return fsm.processEvent(new ConsumerFSMEvent(respEvent, msg));
                        }
                    }).entry(function onEntry() {
                        this.sendCreateRequest();
                    }).reaction(ConsumerFSMEventNames.CREATE_TIMEOUT, function onCreateTimeout() {
                        LOG_DEBUG("Create timeout, just moving on to bind and hoping for the best.");
                        return this.externalTransitionTo(fsm.BindSent);
                    }).reaction(ConsumerFSMEventNames.CREATE_SUCCESS, function onCreateSuccess() {
                        return this.externalTransitionTo(fsm.BindSent);
                    }).reaction(ConsumerFSMEventNames.CREATE_FAILED, function onCreateFailed(evt) {
                        return this.transitionTo(fsm.Unbound.AwaitFlowOpen, () => emitBindFailed(evt.details));
                    });
                }
                acceptMessage(message) {
                    const {
                        LOG_TRACE,
                        LOG_DEBUG
                    } = this.logger;
                    const messageID = message.getGuaranteedMessageId();
                    const idstr = messageID.toString();
                    const consumer = this._consumer;
                    if (!this._fsmDispatch) {
                        LOG_TRACE("Dropping message because this flow cannot acknowledge it");
                        consumer.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                        return false;
                    }
                    if (!consumer.deliveryCountSent) {
                        message.setDeliveryCount(-1);
                    }
                    const messageSuid = message._getSpoolerUniqueId();
                    if (RgmidFactory.INVALID_SUID.eq(messageSuid)) {
                        message._setSpoolerUniqueId(consumer.spoolerUniqueId);
                    } else if (consumer.spoolerUniqueId !== undefined && !RgmidFactory.INVALID_SUID.eq(consumer.spoolerUniqueId)) {
                        const consumerSuidStr = consumer.spoolerUniqueId.toString();
                        const msgSuidStr = messageSuid.toString();
                        LOG_DEBUG("Updating Consumer message spoolerUniqueId from ", consumerSuidStr, " to ", msgSuidStr);
                        consumer.spoolerUniqueId = messageSuid;
                    } else if ((consumer.spoolerUniqueId === undefined || RgmidFactory.INVALID_SUID.eq(consumer.spoolerUniqueId)) && !RgmidFactory.INVALID_SUID.eq(messageSuid)) {
                        message._setSpoolerUniqueId(RgmidFactory.INVALID_SUID);
                    }
                    const transportAcks = this._transportAcks;
                    const ackResult = transportAcks.tryReceive(messageID, message.getGuaranteedPreviousMessageId());
                    const transportAckRequired = transportAcks.acksPending > this.maxPendingAcks;
                    switch (ackResult) {
                      case TransportAckResult.OK:
                        break;

                      case TransportAckResult.DUPLICATE:
                        consumer.incStat(StatType.RX_DISCARD_DUPLICATE);
                        if (!this._applicationAcks.has(messageID) && !this._oldUnacked.has(idstr)) {
                            LOG_TRACE("Will application ack unknown duplicate ID", idstr);
                            this._sendAck([ [ messageID, messageID ] ]);
                        } else if (transportAckRequired) {
                            this._sendAcks(transportAckRequired);
                        } else {
                            this._setTransportAckTimer();
                        }
                        return false;

                      case TransportAckResult.OUT_OF_ORDER:
                        consumer.incStat(StatType.RX_DISCARD_OUT_OF_ORDER);
                        return false;

                      default:
                        assert(false, "Unhandled transport ack result", ackResult);
                        return false;
                    }
                    return this._applicationAcks.insert(messageID, evicting => {
                        let applicationAckRequired = false;
                        if (evicting) {
                            switch (evicting.state) {
                              case ApplicationAckState.UNACKED:
                                this._oldUnacked.add(evicting.key);
                                break;

                              case ApplicationAckState.ACKED_NOT_SENT:
                                applicationAckRequired = true;
                                break;

                              case ApplicationAckState.ACKED_SENT:
                                break;

                              default:
                                assert(false, "Unhandled application ack state", ApplicationAckState.describe(evicting.state));
                            }
                        }
                        this._midDispatch = true;
                        this._messageDispatch.push(message);
                        this._midDispatch = false;
                        if (transportAckRequired || applicationAckRequired) {
                            LOG_TRACE("Need to send acks:", "transport", transportAckRequired, "application", applicationAckRequired);
                            this._sendAcks(transportAckRequired);
                        } else {
                            this._setTransportAckTimer();
                        }
                        return true;
                    });
                }
                applicationAck(messageId) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    const idstr = messageId.toString();
                    this._consumer.incStat(StatType.RX_ACKED);
                    if (this._oldUnacked.delete(idstr)) {
                        LOG_TRACE("Application acking old message immediately");
                        this._sendAck([ [ messageId, messageId ] ]);
                        return;
                    }
                    this._applicationAcks.updateAckState(messageId, ApplicationAckState.ACKED_NOT_SENT);
                    this._setTransportAckTimer();
                }
                getDestination() {
                    this._endpointEnsure();
                    return this._destination;
                }
                isDisconnected() {
                    if (!this.getCurrentState()) return true;
                    return this.getActiveState(ConsumerStateNames.UNBOUND) || this.getActiveState(ConsumerStateNames.UNBOUND_AWAITING_FLOWOPEN);
                }
                requestStartDispatchUser() {
                    this._userDispatch = true;
                    this.applyStartDispatch();
                }
                requestStartDispatchFSM() {
                    this._fsmDispatch = true;
                    this.applyStartDispatch();
                }
                applyStartDispatch() {
                    if (this._userDispatch && this._fsmDispatch) {
                        this.log(`Starting message dispatch (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                        this._messageDispatch.start();
                        this._localMaxWindowSize = this._localPreferredWindowSize;
                        this._sendAcks(true);
                    } else {
                        this.log(`Not starting message dispatch (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                    }
                }
                transitionToUnbound(eventName, error) {
                    const consumer = this._consumer;
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Flow down, user disconnected?", consumer.userDisconnected);
                    return this.transitionTo(this.Unbound.AwaitFlowOpen, () => this._addEventToEmit(eventName, error));
                }
                transitionToUnboundFromUp(properties, eventName, error) {
                    const consumer = this._consumer;
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Choice point for FLOW_UNBOUND in FlowUp state.");
                    if (error && error instanceof OperationError && error.subcode) {
                        if (error.subcode === ErrorSubcode.REPLAY_STARTED) {
                            this._transportAcks.reset();
                            this._applicationAcks.reset();
                        }
                    }
                    if (consumer.endpointErrorId && this._sessionInterface.isCapable(CapabilityType.MESSAGE_REPLAY)) {
                        LOG_TRACE(`Acking unsolicited unbind with endpointErrorId ${consumer.endpointErrorId}`);
                        const unbindAck = SMFLib.AdProtocolMessage.getUnbindAck(consumer._flowId, consumer.endpointErrorId, this._transportAcks.lastAcked);
                        this._sessionInterface.sendControl(unbindAck);
                    }
                    if (properties.reconnectAttempts === -1 || properties.reconnectAttempts > 0) {
                        if (error && error instanceof OperationError && error.subcode) {
                            if (error.subcode === ErrorSubcode.REPLAY_STARTED || error.subcode === ErrorSubcode.GM_UNAVAILABLE) {
                                LOG_TRACE(`Saving errorCausingReconnect: ${error}`);
                                this._errorCausingReconnect = error;
                                return this.transitionTo(this.Reconnecting);
                            }
                        }
                    }
                    return this.transitionTo(this.Unbound.AwaitFlowOpen, () => this._addEventToEmit(eventName, error));
                }
                requestStopDispatchUser() {
                    this._userDispatch = false;
                    this.log(`Stop dispatch user (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                    this._messageDispatch.stop();
                }
                requestStopDispatchFSM() {
                    this._fsmDispatch = false;
                    this.log(`Stop dispatch FSM (fsm ${this._fsmDispatch}, user ${this._userDispatch})`);
                    this._sendAcks(true);
                }
                _clearTransportAckTimer() {
                    if (!this._transportAckTimer) return;
                    clearTimeout(this._transportAckTimer);
                    this._transportAckTimer = null;
                }
                _dispose() {
                    this._clearTransportAckTimer();
                    this._endpointClear();
                    this._destination = undefined;
                    this._unacked = null;
                    this._messageDispatch = null;
                    this._transportAcks = null;
                    this._consumer = null;
                    this._sessionInterface = null;
                }
                _endpointClear() {
                    this._endpoint = undefined;
                    this._subscription = undefined;
                }
                _endpointEnsure() {
                    if (this._endpoint) {
                        return;
                    }
                    const sessionInterface = this._sessionInterface;
                    const properties = this._consumer._properties;
                    const {
                        queueDescriptor
                    } = properties;
                    let destination;
                    let endpoint;
                    let subscription;
                    if (queueDescriptor.type === QueueType.QUEUE) {
                        destination = sessionInterface.createDestinationFromDescriptor(queueDescriptor);
                        endpoint = new Queue({
                            name: destination.name,
                            type: DestinationType.QUEUE,
                            offset: 0,
                            bytes: destination.bytes.substr(destination.offset)
                        });
                        subscription = undefined;
                    } else {
                        endpoint = queueDescriptor.name ? sessionInterface.createDestinationFromDescriptor(queueDescriptor) : new Topic({
                            name: "\0?",
                            offset: 0,
                            bytes: "\0"
                        });
                        subscription = properties.topicEndpointSubscription || sessionInterface.createTemporaryDestination(DestinationType.TOPIC);
                        destination = subscription;
                    }
                    Object.assign(this, {
                        _destination: destination,
                        _endpoint: endpoint,
                        _subscription: subscription
                    });
                    properties.queueDescriptor = new QueueDescriptor({
                        name: endpoint.name,
                        type: queueDescriptor.type,
                        durable: queueDescriptor.durable
                    });
                }
                _resetLocalConnectionState() {
                    Object.assign(this, {
                        _remoteWindowSize: 0,
                        _active: undefined,
                        _fsmDispatch: false,
                        _userDispatch: true
                    });
                }
                _resetRemoteConnectionState() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Initializing transport acks");
                    this._transportAcks = new TransportAcks();
                    LOG_TRACE("Initializing application acks");
                    this._applicationAcks = new ApplicationAckRingBuffer(RING_BUFFER_SIZE);
                    this._oldUnacked = new Set();
                    LOG_TRACE("Initializing endpointErrorId");
                    this._consumer.endpointErrorId = undefined;
                }
                _sendAck(applicationAcks) {
                    const transportAck = SMFLib.AdProtocolMessage.getAck(this._consumer.flowId, this._transportAcks.lastReceived, this.windowSize, applicationAcks);
                    this._sessionInterface.sendControl(transportAck);
                }
                _addAckToRanges(acksPendingState, applicationAck = null) {
                    const currentRange = acksPendingState.currentRange;
                    const ackRanges = acksPendingState.ackRanges;
                    if (applicationAck && applicationAck.state !== ApplicationAckState.UNACKED) {
                        currentRange.push(applicationAck);
                        return;
                    }
                    if (currentRange.length) {
                        ackRanges.push(currentRange);
                    }
                    if (applicationAck === null || ackRanges.length === SMFLib.AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
                        const bareRanges = ackRanges.map(range => [ range[0].id, range[range.length - 1].id ]);
                        if (bareRanges.length || acksPendingState.forceTransportAck) {
                            const {
                                LOG_TRACE
                            } = this.logger;
                            this._sendAck(bareRanges);
                            LOG_TRACE("Sent ack: ", `Transport ack: ${this._transportAcks.lastReceived}`, `Application acks: ${bareRanges.length ? bareRanges.map(g => `[${g[0]}..${g[1]}]`) : "[]"}`);
                            this._transportAcks.setAcked();
                            acksPendingState.forceTransportAck = false;
                        }
                        ackRanges.forEach(ackRange => {
                            ackRange.forEach(ack => {
                                if (ack.state !== ApplicationAckState.ACKED_SENT) {
                                    try {
                                        this._applicationAcks.updateAckState(ack.id, ApplicationAckState.ACKED_SENT);
                                    } catch (e) {
                                        const {
                                            LOG_ERROR
                                        } = this.logger;
                                        LOG_ERROR(`Marking ack ${ack.id} as sent failed: ${e}`);
                                    }
                                }
                            });
                        });
                        acksPendingState.ackRanges = [];
                    }
                    acksPendingState.currentRange = [];
                }
                _sendAcks(forceTransportAck = false) {
                    this._clearTransportAckTimer();
                    const applicationAcks = this._applicationAcks;
                    const transportAcks = this._transportAcks;
                    const acksPendingState = {
                        forceTransportAck: forceTransportAck || transportAcks.acksPending > 0,
                        ackRanges: [],
                        currentRange: []
                    };
                    const front = this._applicationAcks.front();
                    if (this._oldUnacked.size === 0 && front && front.state !== ApplicationAckState.UNACKED) {
                        this._addAckToRanges(acksPendingState, ZERO_APP_ACK);
                    }
                    applicationAcks.forEach(ack => this._addAckToRanges(acksPendingState, ack));
                    this._addAckToRanges(acksPendingState);
                    assert(acksPendingState.forceTransportAck === false);
                    assert(acksPendingState.currentRange.length === 0);
                    assert(acksPendingState.ackRanges.length === 0);
                }
                _setTransportAckTimer() {
                    if (this._transportAckTimer) return;
                    if (this._consumer.disposed) return;
                    this._transportAckTimer = setTimeout(() => this._sendAcks(true), this._acknowledgeTimeoutInMsecs);
                }
                get maxWindowSize() {
                    return Math.min(this._localMaxWindowSize, this._remoteWindowSize || Number.POSITIVE_INFINITY);
                }
                get windowSize() {
                    return this.maxWindowSize - this._messageDispatch.length;
                }
                get maxPendingAcks() {
                    return this.windowSize * this._acknowledgeThreshold / 100;
                }
            }
            module.exports.ConsumerFSM = ConsumerFSM;
        },
        "./modules/solclient-message-consumer/lib/consumer-state-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const ConsumerStateNames = {
                UNBOUND: "UNBOUND",
                UNBOUND_AWAIT_SESSION_UP: "UNBOUND_AWAIT_SESSION_UP",
                UNBOUND_AWAIT_FLOWOPEN: "UNBOUND_AWAIT_FLOWOPEN",
                UNBOUND_AWAIT_ANY: "UNBOUND_AWAIT_ANY",
                BIND_SENT: "BIND_SENT",
                FLOW_UP: "FLOW_UP",
                FLOW_UP_XFER: "FLOW_UP_XFER",
                FLOW_UP_XFER_INACTIVE: "FLOW_UP_XFER_INACTIVE",
                UNBIND_SENT: "UNBIND_SENT",
                RECONNECTING: "RECONNECTING",
                RECONNECTING_BIND_SENT: "RECONNECTING_BIND_SENT",
                RECONNECTING_AWAIT_SESSION_UP: "RECONNECTING_AWAIT_SESSION_UP",
                RECONNECTING_AWAIT_TIMER: "RECONNECTING_AWAIT_TIMER",
                CREATE_SENT: "CREATE_SENT"
            };
            module.exports.ConsumerStateNames = Enum.new(ConsumerStateNames);
        },
        "./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageConsumerAcknowledgeMode = {
                AUTO: "AUTO",
                CLIENT: "CLIENT"
            };
            module.exports.MessageConsumerAcknowledgeMode = Enum.new(MessageConsumerAcknowledgeMode);
        },
        "./modules/solclient-message-consumer/lib/message-consumer-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageConsumerEventName = {
                UP: "MessageConsumerEventName_up",
                DOWN: "MessageConsumerEventName_down",
                ACTIVE: "MessageConsumerEventName_active",
                INACTIVE: "MessageConsumerEventName_inactive",
                DOWN_ERROR: "MessageConsumerEventName_downError",
                RECONNECTING: "MessageConsumerEventName_reconnecting",
                RECONNECTED: "MessageConsumerEventName_reconnected",
                CONNECT_FAILED_ERROR: "MessageConsumerEventName_connectFailedError",
                GM_DISABLED: "MessageConsumerEventName_GMDisabled",
                DISPOSED: "MessageConsumerEventName_disposed",
                MESSAGE: "MessageConsumerEventName_message",
                SUBSCRIPTION_OK: "MessageConsumerEventName_ok",
                SUBSCRIPTION_ERROR: "MessageConsumerEventName_error"
            };
            module.exports.MessageConsumerEventName = Enum.new(MessageConsumerEventName);
        },
        "./modules/solclient-message-consumer/lib/message-consumer-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            class MessageConsumerEvent {
                constructor(messageConsumerEventName, infoStr, responseCode = undefined, errorSubcode = 0, correlationKey = undefined, reason = undefined) {
                    this._messageConsumerEventName = messageConsumerEventName;
                    this._infoStr = infoStr;
                    this._responseCode = responseCode;
                    this._errorSubcode = errorSubcode;
                    this._correlationKey = correlationKey;
                    this._reason = reason;
                }
                get messageConsumerEventName() {
                    return this._messageConsumerEventName;
                }
                get name() {
                    return this._messageConsumerEventName;
                }
                get infoStr() {
                    return this._infoStr;
                }
                get responseCode() {
                    return this._responseCode;
                }
                get errorSubcode() {
                    return this._errorSubcode;
                }
                get subcode() {
                    return this._errorSubcode;
                }
                get correlationKey() {
                    return this._correlationKey;
                }
                get reason() {
                    return this._reason;
                }
                set reason(value) {
                    this._reason = value;
                }
                get requestEventCode() {
                    return undefined;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        messageConsumerEventName: this.messageConsumerEventName,
                        infoStr: this.infoStr,
                        responseCode: this.responseCode,
                        errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                        correlationKey: this.correlationKey ? this.correlationKey.toString() : null,
                        reason: this.reason ? this.reason : null
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.MessageConsumerEvent = MessageConsumerEvent;
        },
        "./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                AbstractQueueDescriptor,
                QueueDescriptor,
                QueueDescriptorValidator,
                QueueProperties,
                QueuePropertiesValidator,
                QueueType
            } = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                APIPropertiesValidators
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                MessageConsumerAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
            const {
                OperationError,
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                ReplayStartLocation
            } = __webpack_require__("./modules/solclient-replaystart/api.js");
            const {
                validateInstance,
                valBoolean,
                valInstance,
                valIsMember,
                valNumber,
                valRange,
                valTopicStringOrEmpty
            } = APIPropertiesValidators;
            function valTopicEndpointSubscription(typeDesc, instance) {
                if (instance.queueDescriptor.getType() === QueueType.TOPIC_ENDPOINT) {
                    if (instance.queueDescriptor.isDurable() && !instance.createIfMissing) {
                        if (!instance.topicEndpointSubscription) {
                            throw new OperationError("topicEndpointSubscription must be set when queueDescriptor " + "refers to a durable topic endpoint and not allowed to create.", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                    }
                } else if (instance.topicEndpointSubscription) {
                    throw new OperationError("topicEndpointSubscription is set, but queueDescriptor " + "refers to a queue that is not of type QueueType.TOPIC_ENDPOINT", ErrorSubcode.PARAMETER_CONFLICT);
                }
            }
            const MessageConsumerPropertiesValidator = {
                validate(prefix, instance, rawProperties) {
                    if (Object.prototype.hasOwnProperty.call(rawProperties, "transportAcknowledgeTimeoutInMsecs") && Object.prototype.hasOwnProperty.call(rawProperties, "acknowledgeTimeoutInMsecs")) {
                        throw new OperationError(`${prefix} validation: transportAcknowledgeTimeoutInMsecs and acknowledgeTimeoutInMsecs are mutually exclusive`, ErrorSubcode.PARAMETER_CONFLICT);
                    }
                    if (Object.prototype.hasOwnProperty.call(rawProperties, "transportAcknowledgeThresholdPercentage") && Object.prototype.hasOwnProperty.call(rawProperties, "acknowledgeThreshold")) {
                        throw new OperationError(`${prefix} validation: transportAcknowledgeThresholdPercentage and acknowledgeThreshold are mutually exclusive`, ErrorSubcode.PARAMETER_CONFLICT);
                    }
                    const v = validateInstance.bind(null, prefix, instance);
                    if (!(instance.queueDescriptor instanceof AbstractQueueDescriptor || instance.queueDescriptor instanceof QueueDescriptor)) {
                        throw new OperationError(`${prefix} validation: queue descriptor must be ` + "an AbstractQueueDescriptor or a QueueDescriptor", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    QueueDescriptorValidator.validate(instance.queueDescriptor);
                    if (instance.queueProperties) {
                        if (instance.queueDescriptor.durable && !instance.createIfMissing) {
                            throw new OperationError(`${prefix} validation: queueProperties cannot be set unless ` + "queueDescriptor refers to a temporary queue, or createIfMissing is set.", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        v("queueProperties", [ valInstance, QueueProperties, "QueueProperties" ]);
                        QueuePropertiesValidator.validate(instance.queueProperties);
                        if (!instance.queueDescriptor.durable && Check.something(instance.queueProperties.accessType)) {
                            throw new OperationError(`${prefix} validation: queueProperties cannot specify accessType ` + "in creation of a temporary queue", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                    }
                    if (instance.queueDescriptor.type === QueueType.TOPIC_ENDPOINT) {
                        if (instance.queueDescriptor.durable && !instance.createIfMissing && !instance.topicEndpointSubscription) {
                            throw new OperationError(`${prefix} validation: topicEndpointSubscription must be set for durable ` + "topic endpoints unless creation is allowed.", ErrorSubcode.PARAMETER_CONFLICT);
                        }
                    } else if (instance.topicEndpointSubscription) {
                        throw new OperationError(`${prefix} validation: topicEndpointSubscription cannot be set unless ` + "descriptor.type is TOPIC_ENDPOINT", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                    v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                    v("connectAttempts", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                    v("topicEndpointSubscription", [ valTopicEndpointSubscription ], [ valTopicStringOrEmpty ]);
                    v("acknowledgeMode", [ valIsMember, MessageConsumerAcknowledgeMode, "MessageConsumerAcknowledgeMode" ]);
                    v("transportAcknowledgeTimeoutInMsecs", [ valNumber ], [ valRange, 20, 1500 ]);
                    v("transportAcknowledgeThresholdPercentage", [ valNumber ], [ valRange, 1, 75 ]);
                    v("activeIndicationEnabled", [ valBoolean ]);
                    v("noLocal", [ valBoolean ]);
                    v("windowSize", [ valNumber ], [ valRange, 1, 255 ]);
                    v("reconnectIntervalInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                    if (instance.activeIndicationEnabled && instance.queueDescriptor.type !== QueueType.QUEUE) {
                        throw new OperationError(`${prefix} validation: activeIndicationEnabled may only be true for ` + "QUEUE destinations", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                    if (instance.replayStartLocation && !(instance.replayStartLocation instanceof ReplayStartLocation)) {
                        throw new OperationError(`${prefix} validation: replayStartLocation must be ` + "an instance of ReplayStartLocation", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                }
            };
            module.exports.MessageConsumerPropertiesValidator = MessageConsumerPropertiesValidator;
        },
        "./modules/solclient-message-consumer/lib/message-consumer-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const QueueLib = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                MessageConsumerAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-acknowledge-modes.js");
            const {
                Topic
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const DEFAULTS = {
                queueDescriptor: undefined,
                queueProperties: undefined,
                connectTimeoutInMsecs: 1e4,
                connectAttempts: 3,
                topicEndpointSubscription: undefined,
                acknowledgeMode: MessageConsumerAcknowledgeMode.AUTO,
                transportAcknowledgeTimeoutInMsecs: 1e3,
                transportAcknowledgeThresholdPercentage: 60,
                activeIndicationEnabled: false,
                noLocal: false,
                windowSize: 255,
                _browser: false,
                replayStartLocation: undefined,
                reconnectAttempts: -1,
                reconnectIntervalInMsecs: 3e3,
                createIfMissing: false
            };
            class MessageConsumerProperties extends APIProperties {
                constructor(options) {
                    super(DEFAULTS, options);
                }
                get queueDescriptor() {
                    return Check.something(this._queueDescriptor) ? this._queueDescriptor : DEFAULTS.queueDescriptor;
                }
                set queueDescriptor(value) {
                    if (value instanceof QueueLib.AbstractQueueDescriptor) {
                        this._queueDescriptor = value;
                    } else if (value) {
                        this._queueDescriptor = value.name ? new QueueLib.QueueDescriptor(value) : new QueueLib.AbstractQueueDescriptor(value);
                    } else {
                        this._queueDescriptor = value;
                    }
                }
                get queueProperties() {
                    return Check.something(this._queueProperties) ? this._queueProperties : DEFAULTS.queueProperties;
                }
                set queueProperties(value) {
                    if (value) {
                        this._queueProperties = new QueueLib.QueueProperties(value);
                    } else {
                        this._queueProperties = value;
                    }
                }
                get connectTimeoutInMsecs() {
                    return Check.something(this._bindTimeoutInMsecs) ? this._bindTimeoutInMsecs : DEFAULTS.connectTimeoutInMsecs;
                }
                set connectTimeoutInMsecs(value) {
                    this._bindTimeoutInMsecs = value;
                }
                get connectAttempts() {
                    return Check.something(this._connectAttempts) ? this._connectAttempts : DEFAULTS.connectAttempts;
                }
                set connectAttempts(val) {
                    this._connectAttempts = val;
                }
                get topicEndpointSubscription() {
                    return this._topicEndpointSubscription;
                }
                set topicEndpointSubscription(val) {
                    if (typeof val === "string") {
                        this._topicEndpointSubscription = Topic.createFromName(val);
                    } else {
                        this._topicEndpointSubscription = val;
                    }
                }
                get acknowledgeMode() {
                    return Check.something(this._acknowledgeMode) ? this._acknowledgeMode : DEFAULTS.acknowledgeMode;
                }
                set acknowledgeMode(value) {
                    this._acknowledgeMode = value;
                }
                get acknowledgeTimeoutInMsecs() {
                    return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                }
                set acknowledgeTimeoutInMsecs(val) {
                    this._transportAcknowledgeTimeoutInMsecs = val;
                }
                get acknowledgeThreshold() {
                    return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                }
                set acknowledgeThreshold(value) {
                    this._transportAcknowledgeThresholdPercentage = value;
                }
                get transportAcknowledgeTimeoutInMsecs() {
                    return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                }
                set transportAcknowledgeTimeoutInMsecs(val) {
                    this._transportAcknowledgeTimeoutInMsecs = val;
                }
                get transportAcknowledgeThresholdPercentage() {
                    return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                }
                set transportAcknowledgeThresholdPercentage(value) {
                    this._transportAcknowledgeThresholdPercentage = value;
                }
                get activeIndicationEnabled() {
                    return Check.something(this._activeIndicationEnabled) ? this._activeIndicationEnabled : DEFAULTS.activeIndicationEnabled;
                }
                set activeIndicationEnabled(newValue) {
                    this._activeIndicationEnabled = newValue;
                }
                get noLocal() {
                    return Check.something(this._noLocal) ? this._noLocal : DEFAULTS.noLocal;
                }
                set noLocal(newValue) {
                    this._noLocal = newValue;
                }
                get windowSize() {
                    return Check.something(this._windowSize) ? this._windowSize : DEFAULTS.windowSize;
                }
                set windowSize(val) {
                    this._windowSize = val;
                }
                get browser() {
                    return Check.something(this._browser) ? this._browser : DEFAULTS._browser;
                }
                set browser(newValue) {
                    this._browser = newValue;
                }
                get replayStartLocation() {
                    return Check.something(this._replayStartLocation) ? this._replayStartLocation : DEFAULTS.replayStartLocation;
                }
                set replayStartLocation(newValue) {
                    this._replayStartLocation = newValue;
                }
                get reconnectAttempts() {
                    return Check.something(this._reconnectAttempts) ? this._reconnectAttempts : DEFAULTS.reconnectAttempts;
                }
                set reconnectAttempts(newValue) {
                    this._reconnectAttempts = newValue;
                }
                get reconnectIntervalInMsecs() {
                    return Check.something(this._reconnectIntervalInMsecs) ? this._reconnectIntervalInMsecs : DEFAULTS.reconnectIntervalInMsecs;
                }
                set reconnectIntervalInMsecs(newValue) {
                    this._reconnectIntervalInMsecs = newValue;
                }
                get createIfMissing() {
                    return Check.something(this._createIfMissing) ? this._createIfMissing : DEFAULTS.createIfMissing;
                }
                set createIfMissing(newValue) {
                    this._createIfMissing = newValue;
                }
            }
            module.exports.MessageConsumerProperties = MessageConsumerProperties;
        },
        "./modules/solclient-message-consumer/lib/message-consumer.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                CapabilityType
            } = __webpack_require__("./modules/solclient-session/api.js");
            const {
                ConsumerFSM
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm.js");
            const {
                ConsumerFSMEvent
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event.js");
            const {
                ConsumerFSMEventNames
            } = __webpack_require__("./modules/solclient-message-consumer/lib/consumer-fsm-event-names.js");
            const {
                ErrorResponseSubcodeMapper,
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Flow,
                FlowOperation
            } = __webpack_require__("./modules/solclient-flow/api.js");
            const {
                MessageConsumerEvent
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event.js");
            const {
                MessageConsumerEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
            const {
                MessageConsumerProperties
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-properties.js");
            const {
                MessageConsumerPropertiesValidator
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-properties-validator.js");
            const {
                Queue,
                Topic
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                QueueAccessType,
                QueuePermissions,
                QueueDiscardBehavior
            } = __webpack_require__("./modules/solclient-queue/api.js");
            function formatEventName(eventName) {
                return `MessageConsumerEventName.${MessageConsumerEventName.describe(eventName)}`;
            }
            let localCounter = 0;
            function getConsumerLocalName() {
                return `ConsumerFSM ${localCounter++}`;
            }
            class MessageConsumer extends Flow {
                constructor({
                    properties,
                    sessionInterfaceFactory
                } = {}) {
                    const applyProperties = new MessageConsumerProperties(properties);
                    MessageConsumerPropertiesValidator.validate(applyProperties.browser ? "QueueBrowserProperties" : "MessageConsumerProperties", applyProperties, properties);
                    super(applyProperties, sessionInterfaceFactory, {
                        direct: MessageConsumerEventName.MESSAGE,
                        emits: MessageConsumerEventName.values,
                        formatEventName: formatEventName
                    });
                    const superFormatter = this.logger.formatter;
                    this.logger.formatter = (...args) => superFormatter("[message-consumer]", ...args);
                    this._active = undefined;
                    this._fsm = this._makeFSM();
                    this.endpointErrorId = undefined;
                    this._on(MessageConsumerEventName.ACTIVE, () => this._onFlowActive(true));
                    this._on(MessageConsumerEventName.INACTIVE, () => this._onFlowActive(false));
                    this._on(MessageConsumerEventName.DOWN_ERROR, this._onFlowDisconnected.bind(this));
                    this._on(MessageConsumerEventName.UP, this._onFlowUp.bind(this));
                    this._fsm.start();
                }
                _makeFSM() {
                    const properties = this._properties;
                    const name = `${getConsumerLocalName()}`;
                    return new ConsumerFSM({
                        name: name,
                        consumer: this,
                        sessionInterface: this._sessionInterface,
                        properties: properties
                    });
                }
                start() {
                    this._operationCheck(FlowOperation.START);
                    this._fsm.requestStartDispatchUser();
                }
                stop() {
                    this._operationCheck(FlowOperation.STOP);
                    this._fsm.requestStopDispatchUser();
                }
                connect() {
                    if (this._sessionInterface.getCapability(CapabilityType.GUARANTEED_MESSAGE_CONSUME) !== null && !this._sessionInterface.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME)) {
                        throw new OperationError("Consumer is not supported by router for this client", ErrorSubcode.INVALID_OPERATION, null);
                    }
                    super.connect();
                    this.processFSMEvent(new ConsumerFSMEvent({
                        name: ConsumerFSMEventNames.FLOW_OPEN
                    }));
                }
                disconnect() {
                    super.disconnect();
                    this.processFSMEvent(new ConsumerFSMEvent({
                        name: ConsumerFSMEventNames.FLOW_CLOSE
                    }));
                }
                getDestination() {
                    const destination = this._fsm.getDestination();
                    if (destination instanceof Queue) {
                        return new Queue(destination);
                    }
                    return new Topic(destination);
                }
                _disconnectSession() {
                    super._disconnectSession();
                    this.processFSMEvent(new ConsumerFSMEvent({
                        name: ConsumerFSMEventNames.SESSION_DISCONNECT
                    }));
                }
                _operationCheck(operation) {
                    super._operationCheck(operation);
                    switch (operation) {
                      case FlowOperation.GET_DESTINATION:
                        if (this._isDisconnected()) {
                            throw new OperationError("Cannot get destination of a disconnected flow", ErrorSubcode.INVALID_OPERATION);
                        }
                        break;

                      default:
                    }
                }
                applicationAck(messageId) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE(`Adding application ack for ${messageId}`);
                    this._fsm.applicationAck(messageId);
                }
                getDisposedEvent() {
                    return MessageConsumerEventName.DISPOSED;
                }
                handleDataMessage(message) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Handling data message");
                    message.setMessageConsumer(this);
                    this._fsm.acceptMessage(message);
                }
                handleUncorrelatedControlMessage(message) {
                    const {
                        LOG_INFO,
                        LOG_DEBUG,
                        LOG_TRACE
                    } = this.logger;
                    LOG_INFO("Handling uncorrelated control message");
                    const msgType = message.msgType;
                    const {
                        SMFAdProtocolMessageType
                    } = SMFLib;
                    switch (msgType) {
                      case SMFAdProtocolMessageType.UNBIND:
                        {
                            const responseCode = message.smfHeader.pm_respcode;
                            const description = message.smfHeader.pm_respstr;
                            const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, description);
                            LOG_TRACE(`Handling uncorrelated UNBIND. endpointErrorId: ${message.getEndpointErrorId()}`);
                            if (message.getEndpointErrorId() !== undefined) {
                                this.endpointErrorId = message.getEndpointErrorId();
                            }
                            this.processFSMEvent(new ConsumerFSMEvent({
                                name: ConsumerFSMEventNames.FLOW_UNBOUND
                            }, new OperationError(description, errorSubcode, responseCode)));
                        }
                        break;

                      case SMFAdProtocolMessageType.FLOWCHANGEUPDATE:
                        this.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.FLOW_ACTIVE_IND
                        }, {
                            active: message.getActiveFlow()
                        }));
                        break;

                      default:
                        LOG_DEBUG("Dropping unhandled AD control message: ", SMFAdProtocolMessageType.describe(msgType));
                    }
                }
                getProperties() {
                    return super.getProperties();
                }
                onVRNChanged() {
                    this.processFSMEvent(new ConsumerFSMEvent({
                        name: ConsumerFSMEventNames.VIRTUALROUTER_NAME_CHANGED
                    }));
                }
                get accessType() {
                    return this._accessType;
                }
                set accessType(value) {
                    this._accessType = value;
                }
                get active() {
                    return this._active;
                }
                set active(value) {
                    if (value !== this._active) {
                        this._emit(value ? MessageConsumerEventName.ACTIVE : MessageConsumerEventName.INACTIVE);
                    }
                    this._active = value;
                }
                get queueDiscardBehavior() {
                    return this._queueDiscardBehavior;
                }
                set queueDiscardBehavior(value) {
                    this._queueDiscardBehavior = value;
                }
                get respectsTTL() {
                    return this._respectsTTL;
                }
                set respectsTTL(value) {
                    this._respectsTTL = value;
                }
                get flowId() {
                    return this._flowId;
                }
                set flowId(value) {
                    this._flowId = value;
                }
                get permissions() {
                    return this._permissions || 0;
                }
                set permissions(value) {
                    this._permissions = value;
                }
                _onFlowActive(isActive) {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    LOG_DEBUG(`Flow (flowId = ${this._flowId}) became ${isActive ? "active" : "inactive"}`);
                    this._active = isActive;
                }
                _onFlowDisconnected(error) {
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO(`${this} disconnected: ${error}.message`);
                }
                _disposeFSM() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO("Disposing FSM");
                    this.processFSMEvent(new ConsumerFSMEvent({
                        name: ConsumerFSMEventNames.DISPOSE
                    }));
                }
                _onFlowUp() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO(`Flow is up: flowId = ${this._flowId}`);
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return Object.assign(super[Symbol.for("nodejs.util.inspect.custom")](), {
                        destination: this._destination,
                        accessType: QueueAccessType.describe(this.accessType),
                        permissions: QueuePermissions.describe(this.permissions),
                        respectsTTL: this.respectsTTL,
                        active: this.wantFlowChangeNotify ? this.active : "(indications disabled)",
                        wantFlowChangeNotify: this.wantFlowChangeNotify,
                        queueDiscardBehavior: QueueDiscardBehavior.describe(this.queueDiscardBehavior),
                        maxWindowSize: this._fsm.maxWindowSize
                    });
                }
                toString() {
                    return util_inspect(this);
                }
                _isDisconnected() {
                    return this._fsm.isDisconnected();
                }
                addSubscription(topic, correlationKey, requestTimeout) {
                    const callback = (success, subCode, respCode, respText) => {
                        if (success) {
                            const event = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_OK, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                            this._emit(MessageConsumerEventName.SUBSCRIPTION_OK, event);
                        } else {
                            const error = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_ERROR, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                            this._emit(MessageConsumerEventName.SUBSCRIPTION_ERROR, error);
                        }
                    };
                    this._sessionInterface.updateQueueSubscription(topic, this._fsm.getDestination(), true, this, callback, requestTimeout);
                }
                removeSubscription(topic, correlationKey, requestTimeout) {
                    const callback = (success, subCode, respCode, respText) => {
                        if (success) {
                            const event = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_OK, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                            this._emit(MessageConsumerEventName.SUBSCRIPTION_OK, event);
                        } else {
                            const error = new MessageConsumerEvent(MessageConsumerEventName.SUBSCRIPTION_ERROR, respText, respCode, subCode, correlationKey, `Topic: ${topic.getName()}`);
                            this._emit(MessageConsumerEventName.SUBSCRIPTION_ERROR, error);
                        }
                    };
                    this._sessionInterface.updateQueueSubscription(topic, this._fsm.getDestination(), false, this, callback, requestTimeout);
                }
            }
            module.exports.MessageConsumer = MessageConsumer;
        },
        "./modules/solclient-message-consumer/lib/message-dispatcher.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                MessageConsumerEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
            function formatEventName(x) {
                return `MessageConsumerEventName.${MessageConsumerEventName.describe(x)}`;
            }
            class MessageDispatcher {
                constructor({
                    emitter,
                    autoAck,
                    logger
                } = {}) {
                    Object.assign(this, {
                        emitter: emitter,
                        queue: [],
                        dispatch: true,
                        formatEventName: formatEventName,
                        logger: logger
                    });
                    this._dispatchOne = autoAck ? this._dispatchOneAutoAck : this._dispatchOneBare;
                    this.emitter.setOnFirstDirectListener(this._onFirstMessageListener.bind(this));
                    this._availableListener = true;
                }
                start() {
                    this.dispatch = true;
                    this._flush();
                }
                stop() {
                    this.dispatch = false;
                }
                get length() {
                    return this.queue.length;
                }
                push(message) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    this.queue.push(message);
                    if (this.dispatch) {
                        this._flush();
                    } else {
                        LOG_TRACE(`Dispatch disabled, message ${message.getGuaranteedMessageId()} queued locally`);
                    }
                }
                _onFirstMessageListener() {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    if (!this._availableListener) {
                        LOG_DEBUG(`Message listener available for dispatcher, ${this.queue.length} messages queued`);
                        LOG_DEBUG(`Dispatcher started and connected: ${this.dispatch ? "true" : "false"}`);
                        this._availableListener = true;
                    }
                    this._flush();
                }
                _flush() {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    while (this.queue.length && this.dispatch && this.emitter.directListenerCount() > 0) {
                        this._dispatchOne(this.queue.shift());
                    }
                    if (this.queue.length && this.dispatch && this.emitter.directListenerCount() === 0 && this._availableListener) {
                        LOG_DEBUG("Message dispatching stopped: No message listener registered");
                        this._availableListener = false;
                    }
                }
                _dispatchOneAutoAck(message) {
                    const {
                        LOG_WARN
                    } = this.logger;
                    let caught = null;
                    caught = this._dispatchOneBare(message);
                    if (caught) {
                        LOG_WARN(`Suppressing message acknowledgement for message ${message.getGuaranteedMessageId()} because client threw exception from listener`, caught);
                    } else {
                        if (message.isAcknowledged) {
                            LOG_WARN(`Consumer configured to auto-acknowledge messages, but message ${message.getGuaranteedMessageId()} was application acknowledged`);
                            return;
                        }
                        message.acknowledge();
                    }
                }
                _dispatchOneBare(message) {
                    const {
                        LOG_WARN
                    } = this.logger;
                    let caught;
                    if (this.listenerCount === 0) {
                        LOG_WARN(`No listeners to dispatch message ${message.getGuaranteedMessageId()}`);
                    }
                    try {
                        this.emitter.emitDirect(message);
                    } catch (ex) {
                        caught = this.emitter.formatErrorEvent(ex, MessageConsumerEventName.MESSAGE, message);
                        this.emitter.emit("error", caught);
                    }
                    return caught;
                }
            }
            module.exports = {
                MessageDispatcher: MessageDispatcher
            };
        },
        "./modules/solclient-message-consumer/lib/queue-browser-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const QueueBrowserEventName = {
                UP: "QueueBrowserEventName_up",
                DOWN: "QueueBrowserEventName_down",
                DOWN_ERROR: "QueueBrowserEventName_downError",
                CONNECT_FAILED_ERROR: "QueueBrowserEventName_connectFailedError",
                GM_DISABLED: "QueueBrowserEventName_GMDisabled",
                DISPOSED: "QueueBrowserEventName_disposed",
                MESSAGE: "QueueBrowserEventName_message"
            };
            module.exports.QueueBrowserEventName = Enum.new(QueueBrowserEventName);
        },
        "./modules/solclient-message-consumer/lib/queue-browser-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const QueueLib = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const DEFAULTS = {
                queueDescriptor: undefined,
                connectTimeoutInMsecs: 1e4,
                connectAttempts: 3,
                windowSize: 255,
                transportAcknowledgeTimeoutInMsecs: 1e3,
                transportAcknowledgeThresholdPercentage: 60
            };
            class QueueBrowserProperties extends APIProperties {
                constructor(options) {
                    super(DEFAULTS, options);
                }
                get queueDescriptor() {
                    return Check.something(this._queueDescriptor) ? this._queueDescriptor : DEFAULTS.queueDescriptor;
                }
                set queueDescriptor(value) {
                    if (value) {
                        this._queueDescriptor = new QueueLib.QueueDescriptor(value);
                    } else {
                        this._queueDescriptor = value;
                    }
                }
                get connectTimeoutInMsecs() {
                    return Check.something(this._bindTimeoutInMsecs) ? this._bindTimeoutInMsecs : DEFAULTS.connectTimeoutInMsecs;
                }
                set connectTimeoutInMsecs(value) {
                    this._bindTimeoutInMsecs = value;
                }
                get connectAttempts() {
                    return Check.something(this._connectAttempts) ? this._connectAttempts : DEFAULTS.connectAttempts;
                }
                set connectAttempts(val) {
                    this._connectAttempts = val;
                }
                get windowSize() {
                    return Check.something(this._windowSize) ? this._windowSize : DEFAULTS.windowSize;
                }
                set windowSize(val) {
                    this._windowSize = val;
                }
                get transportAcknowledgeTimeoutInMsecs() {
                    return Check.something(this._transportAcknowledgeTimeoutInMsecs) ? this._transportAcknowledgeTimeoutInMsecs : DEFAULTS.transportAcknowledgeTimeoutInMsecs;
                }
                set transportAcknowledgeTimeoutInMsecs(val) {
                    this._transportAcknowledgeTimeoutInMsecs = val;
                }
                get transportAcknowledgeThresholdPercentage() {
                    return Check.something(this._transportAcknowledgeThresholdPercentage) ? this._transportAcknowledgeThresholdPercentage : DEFAULTS.transportAcknowledgeThresholdPercentage;
                }
                set transportAcknowledgeThresholdPercentage(value) {
                    this._transportAcknowledgeThresholdPercentage = value;
                }
            }
            module.exports.QueueBrowserProperties = QueueBrowserProperties;
        },
        "./modules/solclient-message-consumer/lib/queue-browser.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                EventEmitter
            } = __webpack_require__("./modules/solclient-events/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                MessageConsumerEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/message-consumer-event-names.js");
            const {
                QueueBrowserEventName
            } = __webpack_require__("./modules/solclient-message-consumer/lib/queue-browser-event-names.js");
            function formatEventName(eventName) {
                return `QueueBrowserEventName.${QueueBrowserEventName.describe(eventName)}`;
            }
            class QueueBrowser extends EventEmitter {
                constructor(messageConsumer) {
                    super({
                        direct: QueueBrowserEventName.MESSAGE,
                        emits: QueueBrowserEventName.values,
                        formatEventName: formatEventName
                    });
                    this._messageConsumer = messageConsumer;
                    this.logger = new LogFormatter((...args) => [ "[queue-browser]", ...args ]);
                    this._setupEventListers();
                }
                _setupEventListers() {
                    this._messageConsumer.on(MessageConsumerEventName.UP, this._onConsumerUp.bind(this));
                    this._messageConsumer.on(MessageConsumerEventName.CONNECT_FAILED_ERROR, this._onConsumerConnectFailed.bind(this));
                    this._messageConsumer.on(MessageConsumerEventName.DOWN, this._onConsumerDown.bind(this));
                    this._messageConsumer.on(MessageConsumerEventName.DOWN_ERROR, this._onConsumerDownError.bind(this));
                    this._messageConsumer.on(MessageConsumerEventName.MESSAGE, this._onConsumerMessage.bind(this));
                    this._messageConsumer.on(MessageConsumerEventName.DISPOSED, this._onConsumerDisposed.bind(this));
                    this._messageConsumer.on(MessageConsumerEventName.GM_DISABLED, this._onConsumerGMDisabled.bind(this));
                }
                _onConsumerMessage(event) {
                    this.emit(QueueBrowserEventName.MESSAGE, event);
                }
                _onConsumerUp(event) {
                    this.emit(QueueBrowserEventName.UP, event);
                }
                _onConsumerConnectFailed(event) {
                    this.emit(QueueBrowserEventName.CONNECT_FAILED_ERROR, event);
                }
                _onConsumerDown(event) {
                    this.emit(QueueBrowserEventName.DOWN, event);
                }
                _onConsumerDownError(event) {
                    this.emit(QueueBrowserEventName.DOWN_ERROR, event);
                }
                _onConsumerDisposed(event) {
                    this.emit(QueueBrowserEventName.DISPOSED, event);
                }
                _onConsumerGMDisabled(event) {
                    this.emit(QueueBrowserEventName.GM_DISABLED, event);
                }
                connect() {
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    try {
                        LOG_DEBUG("Connecting the queue browser's message consumer");
                        this._messageConsumer.connect();
                    } catch (error) {
                        LOG_ERROR(error.toString());
                        throw error;
                    }
                }
                disconnect() {
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    try {
                        LOG_DEBUG("Disconnecting the queue browser's message consumer");
                        this._messageConsumer.disconnect();
                    } catch (error) {
                        LOG_ERROR(error.toString());
                        throw error;
                    }
                }
                start() {
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    try {
                        LOG_DEBUG("Starting the queue browser's message consumer");
                        this._messageConsumer.start();
                    } catch (error) {
                        LOG_ERROR(error.toString());
                        throw error;
                    }
                }
                stop() {
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    try {
                        LOG_DEBUG("Stopping the queue browser's message consumer");
                        this._messageConsumer.stop();
                    } catch (error) {
                        LOG_ERROR(error.toString());
                        throw error;
                    }
                }
                removeMessageFromQueue(message) {
                    this._messageConsumer.applicationAck(message._guaranteedMsgId);
                    message._acked = true;
                }
            }
            module.exports.QueueBrowser = QueueBrowser;
        },
        "./modules/solclient-message-consumer/lib/transport-acks.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const TransportAckResult = Enum.new({
                OK: 0,
                DUPLICATE: 1,
                OUT_OF_ORDER: 2
            });
            class TransportAcks {
                constructor(id = 0) {
                    const base = typeof id === "number" ? Long.fromNumber(id, true) : Long.fromValue(id);
                    this.lastAcked = base;
                    this._acksPending = 0;
                }
                reset() {
                    this._acksPending = 0;
                    this.lastAcked = Long.ZERO;
                }
                tryReceive(messageID, prevMessageID) {
                    if (this._lastReceived.lt(prevMessageID)) {
                        LOG_DEBUG(`Rejecting out of order message: ${prevMessageID} (last received: ${this._lastReceived})`);
                        return TransportAckResult.OUT_OF_ORDER;
                    }
                    if (this._lastReceived.gte(messageID)) {
                        LOG_DEBUG(`Rejecting duplicate message: ${messageID} (last received: ${this._lastReceived})`);
                        this._acksPending++;
                        return TransportAckResult.DUPLICATE;
                    }
                    LOG_TRACE(`Accepting message: ${messageID}`);
                    this._lastReceived = messageID;
                    this._acksPending++;
                    return TransportAckResult.OK;
                }
                setAcked() {
                    this._lastAcked = Long.fromValue(this._lastReceived);
                    this._acksPending = 0;
                }
                get acksPending() {
                    return this._acksPending;
                }
                get lastAcked() {
                    return this._lastAcked;
                }
                set lastAcked(value) {
                    LOG_TRACE("Setting last acked:", value.toString());
                    Object.assign(this, {
                        _lastAcked: Long.fromValue(value),
                        _lastReceived: Long.fromValue(value)
                    });
                }
                get lastReceived() {
                    return this._lastReceived;
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports = {
                TransportAcks: TransportAcks,
                TransportAckResult: TransportAckResult
            };
        },
        "./modules/solclient-message-publisher/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                MessagePublisher
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher.js");
            const {
                MessagePublisherAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
            const {
                MessagePublisherEventName
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-event-names.js");
            const {
                MessagePublisherProperties
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-properties.js");
            const {
                MessagePublisherPropertiesValidator
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js");
            const {
                PublisherFSMEvent
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event.js");
            const {
                PublisherFSMEventNames
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js");
            module.exports.MessagePublisherAcknowledgeMode = MessagePublisherAcknowledgeMode;
            module.exports.MessagePublisher = MessagePublisher;
            module.exports.MessagePublisherProperties = MessagePublisherProperties;
            module.exports.PublisherFSMEvent = PublisherFSMEvent;
            module.exports.PublisherFSMEventNames = PublisherFSMEventNames;
            module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
            module.exports.MessagePublisherEventName = MessagePublisherEventName;
        },
        "./modules/solclient-message-publisher/lib/message-ids.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const DEFAULTS = {
                _lastAcked: Long.fromNumber(0, true),
                _lastSent: Long.fromNumber(0, true),
                _next: Long.fromNumber(1, true)
            };
            const longToString = v => v.toString(10);
            class MessageIds {
                constructor(attrs) {
                    Object.assign(this, DEFAULTS, attrs);
                }
                get lastAcked() {
                    return this._lastAcked;
                }
                set lastAcked(value) {
                    this._lastAcked = Long.fromValue(value);
                }
                get lastSent() {
                    return this._lastSent;
                }
                setLastSent(id) {
                    this._lastSent = Long.fromValue(id);
                    this._next = this._lastSent.add(1);
                }
                get next() {
                    return this._next;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        lastAcked: longToString(this.lastAcked),
                        lastSent: longToString(this.lastSent),
                        next: longToString(this.next)
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.MessageIds = MessageIds;
        },
        "./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessagePublisherAcknowledgeMode = {
                PER_MESSAGE: "PER_MESSAGE",
                WINDOWED: "WINDOWED"
            };
            module.exports.MessagePublisherAcknowledgeMode = Enum.new(MessagePublisherAcknowledgeMode);
        },
        "./modules/solclient-message-publisher/lib/message-publisher-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessagePublisherEventName = Enum.new({
                ACKNOWLEDGED_MESSAGE: "MessagePublisherEventName_acknowledgedMessage",
                CONNECT_FAILED_ERROR: "MessagePublisherEventName_connectFailedError",
                CAN_SEND: "MessagePublisherEventName_canSend",
                DISPOSED: "MessagePublisherEventName_disposed",
                DOWN: "MessagePublisherEventName_down",
                FLOW_NAME_CHANGED: "MessagePublisherEventName_flowNameChanged",
                GUARANTEED_MESSAGING_DOWN: "MessagePublisherEventName_guaranteedMessagingDown",
                REJECTED_MESSAGE: "MessagePublisherEventName_rejectedMessage",
                DISCONNECT_FAILED_ERROR: "MessagePublisherEventName_disconnectFailedError",
                UP: "MessagePublisherEventName_up",
                TRANSPORT_FULL: "MessagePublisherEventName_transportFull"
            });
            module.exports.MessagePublisherEventName = MessagePublisherEventName;
        },
        "./modules/solclient-message-publisher/lib/message-publisher-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                APIPropertiesValidators
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                MessagePublisherAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
            const {
                validateInstance,
                valBoolean,
                valIsMember,
                valNumber,
                valRange
            } = APIPropertiesValidators;
            const MessagePublisherPropertiesValidator = {
                validate(instance) {
                    const v = validateInstance.bind(null, "MessagePublisherProperties", instance);
                    v("enabled", [ valBoolean ]);
                    v("windowSize", [ valNumber ], [ valRange, 1, 255 ]);
                    v("acknowledgeTimeoutInMsecs", [ valNumber ], [ valRange, 20, 6e4 ]);
                    v("acknowledgeMode", [ valIsMember, MessagePublisherAcknowledgeMode, "MessagePublisherAcknowledgeMode" ]);
                    v("connectRetryCount", [ valNumber ], [ valRange, 0, Number.MAX_VALUE ]);
                    v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 50, Number.MAX_VALUE ]);
                }
            };
            module.exports.MessagePublisherPropertiesValidator = MessagePublisherPropertiesValidator;
        },
        "./modules/solclient-message-publisher/lib/message-publisher-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                MessagePublisherAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
            const {
                TransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/api.js");
            function defaultEnablePublisher() {
                const {
                    ProfileBinding
                } = SolclientFactoryLib;
                const binding = ProfileBinding.value;
                const globallyEnabled = binding.guaranteedMessagingEnabled;
                const webSocketAvailable = TransportCapabilities.web.webSocket();
                return globallyEnabled && webSocketAvailable;
            }
            function getDefaults() {
                return {
                    enabled: defaultEnablePublisher(),
                    windowSize: 50,
                    acknowledgeTimeoutInMsecs: 2e3,
                    acknowledgeMode: MessagePublisherAcknowledgeMode.PER_MESSAGE,
                    connectRetryCount: 3,
                    connectTimeoutInMsecs: 5e3
                };
            }
            class MessagePublisherProperties extends APIProperties {
                constructor(options) {
                    super(getDefaults(), options || {});
                }
                get enabled() {
                    return this._enabled;
                }
                set enabled(newValue) {
                    this._enabled = newValue;
                }
                get windowSize() {
                    return Check.defined(this._windowSize) ? this._windowSize : getDefaults().windowSize;
                }
                set windowSize(newValue) {
                    this._windowSize = newValue;
                }
                get acknowledgeTimeoutInMsecs() {
                    return Check.defined(this._acknowledgeTimeoutInMsecs) ? this._acknowledgeTimeoutInMsecs : getDefaults().acknowledgeTimeoutInMsecs;
                }
                set acknowledgeTimeoutInMsecs(newValue) {
                    this._acknowledgeTimeoutInMsecs = newValue;
                }
                get acknowledgeMode() {
                    return this._acknowledgeMode || MessagePublisherAcknowledgeMode.PER_MESSAGE;
                }
                set acknowledgeMode(newValue) {
                    this._acknowledgeMode = newValue;
                }
                get connectRetryCount() {
                    return Check.defined(this._connectRetryCount) ? this._connectRetryCount : getDefaults().connectRetryCount;
                }
                set connectRetryCount(newValue) {
                    this._connectRetryCount = newValue;
                }
                get connectTimeoutInMsecs() {
                    return Check.defined(this._connectTimeoutInMsecs) ? this._connectTimeoutInMsecs : getDefaults().connectTimeoutInMsecs;
                }
                set connectTimeoutInMsecs(newValue) {
                    this._connectTimeoutInMsecs = newValue;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        enabled: this.enabled,
                        windowSize: this.windowSize,
                        acknowledgeTimeoutInMsecs: this.acknowledgeTimeoutInMsecs,
                        acknowledgeMode: MessagePublisherAcknowledgeMode.describe(this.acknowledgeMode),
                        connectRetryCount: this.connectRetryCount,
                        connectTimeoutInMsecs: this.connectTimeoutInMsecs
                    };
                }
            }
            module.exports.MessagePublisherProperties = MessagePublisherProperties;
        },
        "./modules/solclient-message-publisher/lib/message-publisher.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                Flow,
                PrivateFlowEventName
            } = __webpack_require__("./modules/solclient-flow/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                MessagePublisherEventName
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-event-names.js");
            const {
                MessagePublisherProperties
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-properties.js");
            const {
                PublisherFSM
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm.js");
            const {
                PublisherFSMEvent
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event.js");
            const {
                PublisherFSMEventNames
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js");
            const {
                LOG_WARN
            } = new LogFormatter();
            class MessagePublisher extends Flow {
                constructor({
                    properties,
                    sessionInterfaceFactory
                } = {}) {
                    const applyProperties = new MessagePublisherProperties(properties);
                    super(applyProperties, sessionInterfaceFactory, {
                        direct: MessagePublisherEventName.ACKNOWLEDGED_MESSAGE,
                        emits: MessagePublisherEventName.values
                    });
                    this._fsm = this._makeFSM();
                    const logger = new LogFormatter();
                    logger.formatter = function formatter(...args) {
                        return [ "[message-publisher]", ...args ];
                    };
                    this.log = logger.wrap(this.log, this);
                    this._bindWaiting = true;
                    this.on(PrivateFlowEventName.BIND_WAITING, this._onBindWaiting.bind(this));
                    this.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, this._onBindFailed.bind(this));
                    this.on(MessagePublisherEventName.DOWN, this._onDown.bind(this));
                    this.on(MessagePublisherEventName.UP, this._onUp.bind(this));
                }
                _onBindFailed() {
                    this._bindWaiting = false;
                }
                _onBindWaiting() {
                    this._bindWaiting = true;
                }
                _onDown() {
                    this._bindWaiting = false;
                }
                _onUp() {
                    this._bindWaiting = false;
                }
                _makeFSM() {
                    return new PublisherFSM({
                        publisher: this,
                        name: "PublisherFSM",
                        sessionInterface: this._sessionInterface,
                        properties: this._properties
                    });
                }
                get flowId() {
                    return this._flowId;
                }
                set flowId(value) {
                    this._flowId = value;
                }
                get name() {
                    return this._flowName;
                }
                set name(value) {
                    this._flowName = value;
                }
                get publisherId() {
                    return this._publisherId;
                }
                set publisherId(value) {
                    this._publisherId = value;
                }
                get properties() {
                    return this._properties.clone();
                }
                connect() {
                    super.connect();
                    if (!this._fsm.getCurrentState()) {
                        this._fsm.start();
                    }
                }
                _disconnectSession() {
                    super._disconnectSession();
                    this.processFSMEvent(new PublisherFSMEvent({
                        name: PublisherFSMEventNames.FLOW_CLOSE
                    }));
                }
                getDisposedEvent() {
                    return MessagePublisherEventName.DISPOSED;
                }
                handleAck(id) {
                    this.processFSMEvent(new PublisherFSMEvent({
                        name: PublisherFSMEventNames.ACK
                    }, {
                        ack: id
                    }));
                }
                handleNack(id, ctrlMessage) {
                    this.processFSMEvent(new PublisherFSMEvent({
                        name: PublisherFSMEventNames.ACK
                    }, {
                        nack: id,
                        ctrlMessage: ctrlMessage
                    }));
                }
                handleUncorrelatedControlMessage(message) {
                    const msgType = message.msgType;
                    const {
                        SMFAdProtocolMessageType
                    } = SMFLib;
                    switch (msgType) {
                      case SMFAdProtocolMessageType.CLIENTACK:
                        {
                            const id = message.getLastMsgIdAcked();
                            if (message.smfHeader.pm_respcode > 299) {
                                this.handleNack(id, message);
                            } else {
                                this.handleAck(id);
                            }
                            break;
                        }

                      case SMFAdProtocolMessageType.CLIENTNACK:
                        {
                            const id = message.getLastMsgIdAcked();
                            this.handleNack(id, message);
                            break;
                        }

                      case SMFAdProtocolMessageType.CLOSEPUBFLOW:
                        this.processFSMEvent(new PublisherFSMEvent({
                            name: PublisherFSMEventNames.FLOW_UNBOUND
                        }));
                        break;

                      default:
                        LOG_WARN(`Dropping unhandled AD control message for ${this}`, SMFAdProtocolMessageType.describe(msgType));
                    }
                }
                prepareAdMessageAndSend(dataMsg) {
                    return this._fsm.prepareAdMessageAndSend(dataMsg);
                }
                isBindWaiting() {
                    return this._bindWaiting;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return Object.assign(super[Symbol.for("nodejs.util.inspect.custom")](), {
                        name: this.name,
                        publisherId: this.publisherId
                    });
                }
                toString() {
                    return util_inspect(this);
                }
                _disposeFSM() {
                    this.processFSMEvent(new PublisherFSMEvent({
                        name: PublisherFSMEventNames.DISPOSE
                    }));
                }
                _isDisconnected() {
                    return this._fsm.isDisconnected();
                }
            }
            module.exports.MessagePublisher = MessagePublisher;
        },
        "./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const PublisherFSMEventNames = {
                SESSION_UP: "PublisherSessionUp",
                SESSION_UP_NO_AD: "PublisherSessionUpNoAD",
                SESSION_DOWN: "PublisherSessionDown",
                FLOW_FAILED: "MessagePublisherFailed",
                FLOW_UP: "MessagePublisherUp",
                FLOW_CLOSE: "MessagePublisherClose",
                FLOW_UNBOUND: "MessagePublisherUnbound",
                TRANSPORT_FULL: "PublisherTransportFull",
                ACK: "PublisherAck",
                ACK_TIMEOUT: "PublisherAckTimeout",
                BIND_TIMEOUT: "PublisherBindTimeout",
                UNBIND_TIMEOUT: "PublisherUnbindTimeout",
                CAN_SEND: "PublisherCanSend",
                TRANSPORT_ERROR: "PublisherTransportError",
                RESEND_COMPLETE: "PublisherResendComplete",
                DISPOSE: "PublisherDispose"
            };
            module.exports.PublisherFSMEventNames = Enum.new(PublisherFSMEventNames);
        },
        "./modules/solclient-message-publisher/lib/publisher-fsm-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                FsmEvent
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            class PublisherFSMEvent extends FsmEvent {
                constructor(spec, details, smfmessage) {
                    super(spec);
                    Object.assign(this, details);
                    Object.assign(this, smfmessage);
                }
                getEventText() {
                    return this._eventText;
                }
            }
            module.exports.PublisherFSMEvent = PublisherFSMEvent;
        },
        "./modules/solclient-message-publisher/lib/publisher-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const SolclientSession = __webpack_require__("./modules/solclient-session/api.js");
            const {
                ErrorResponseSubcodeMapper,
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                MessageIds
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-ids.js");
            const {
                MessagePublisherAcknowledgeMode
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-acknowledge-modes.js");
            const {
                MessagePublisherEventName
            } = __webpack_require__("./modules/solclient-message-publisher/lib/message-publisher-event-names.js");
            const {
                PrivateFlowEventName
            } = __webpack_require__("./modules/solclient-flow/api.js");
            const {
                PublisherFSMEvent
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event.js");
            const {
                PublisherFSMEventNames
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-fsm-event-names.js");
            const {
                PublisherStateNames
            } = __webpack_require__("./modules/solclient-message-publisher/lib/publisher-state-names.js");
            const {
                State,
                StateMachine
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            const {
                StatType
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/api.js");
            const ConnectReason = {
                INIT: 0,
                RESUME: 1,
                FAILOVER: 2
            };
            class PublisherFSM extends StateMachine {
                constructor({
                    publisher,
                    name,
                    sessionInterface,
                    properties
                } = {}) {
                    super({
                        name: name
                    });
                    const fsm = this;
                    const currentState = () => {
                        const state = fsm.getCurrentState();
                        return state ? state.getName() : "<not running>";
                    };
                    this.logger = new LogFormatter((...args) => [ `[session=${sessionInterface.sessionIdHex}]`, `[message-publisher-fsm=${publisher.flowIdDec}]`, `[${currentState()}]`, ...args ]);
                    this.log = this.logger.wrap(this.log, this);
                    const {
                        LOG_TRACE,
                        LOG_DEBUG,
                        LOG_INFO,
                        LOG_WARN
                    } = this.logger;
                    Object.assign(this, {
                        _publisher: publisher,
                        _acknowledgeMode: properties.acknowledgeMode,
                        _acknowledgeTimeoutInMsecs: properties.acknowledgeTimeoutInMsecs,
                        _sessionInterface: sessionInterface,
                        _windowSize: properties.windowSize,
                        _stateEvents: []
                    });
                    this._guaranteedEnabled = properties.enabled;
                    this._sendWindow = properties.windowSize;
                    this._resetConnectedInfo();
                    this._notifiedWindowClosed = false;
                    this._transportFlowControlled = true;
                    this.initial(function onInitial() {
                        return this.transitionTo(fsm.PublisherUnbound, context => {
                            LOG_TRACE(`Starting ${context.getStateMachine().getName()}`);
                        });
                    });
                    fsm.unhandledEventReaction(function onUnhandledEvent(event) {
                        switch (event.getName()) {
                          case PublisherFSMEventNames.FLOW_UNBOUND:
                            this._guaranteedEnabled = false;
                            this._publisher.emit(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN);
                            return this.transitionTo(fsm.PublisherUnbound, context => {
                                LOG_TRACE(`Received close publisher for ${context.getStateMachine().getName()}`);
                            });

                          case PublisherFSMEventNames.DISPOSE:
                            LOG_TRACE("Received dispose request");
                            break;

                          case PublisherFSMEventNames.TRANSPORT_FULL:
                            LOG_TRACE("Received TRANSPORT_FULL");
                            break;

                          case PublisherFSMEventNames.CAN_SEND:
                            LOG_TRACE("Received CAN_SEND when not flow controlled");
                            break;

                          default:
                            LOG_TRACE(`Ignoring event ${event.getName()}`);
                        }
                        return this;
                    });
                    fsm.PublisherUnbound = new State({
                        name: PublisherStateNames.UNBOUND,
                        parentContext: fsm
                    }, {
                        emitDownAndBindWaiting() {
                            LOG_TRACE("Emit down and bind waiting");
                            publisher.emit(MessagePublisherEventName.DOWN);
                            publisher.emit(PrivateFlowEventName.BIND_WAITING);
                        }
                    }).entry(function onEntry() {
                        this.emitDownAndBindWaiting();
                        fsm._connectRetryCount = properties.connectRetryCount;
                    }).reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbind() {
                        return this.internalTransition();
                    }).reaction(PublisherFSMEventNames.SESSION_UP, function onSessionUp() {
                        return this.transitionTo(fsm.PublisherOpenFlowSent);
                    });
                    fsm.PublisherOpenFlowSent = new State({
                        name: PublisherStateNames.OPENFLOWSENT,
                        parentContext: fsm
                    }, {
                        emitOpenFlowFailedError(details) {
                            publisher.emit(MessagePublisherEventName.CONNECT_FAILED_ERROR, details);
                        },
                        handleOpenFlowResponse(adpMsg) {
                            const smfRespHeader = adpMsg.smfHeader;
                            const respCode = smfRespHeader.pm_respcode;
                            if (adpMsg.msgType !== SMFLib.SMFAdProtocolMessageType.OPENPUBFLOW) {
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    returnCode: respCode,
                                    description: `Unexpected response: ${SMFLib.SMFAdProtocolMessageType.describe(adpMsg.msgType)}`
                                }));
                            }
                            if (respCode === null) {
                                publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                LOG_DEBUG(`Drop Open-Publisher-Flow Request message on sessionId 0x${sessionInterface.sessionIdHex}`);
                                return null;
                            }
                            if (respCode !== 200) {
                                const respStr = smfRespHeader.pm_respstr;
                                const mappedSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respStr);
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    subcode: mappedSubcode,
                                    returnCode: respCode,
                                    description: respStr
                                }));
                            }
                            LOG_TRACE("Handling OPENPUBFLOW message");
                            const lastMsgIDAcked = adpMsg.getLastMsgIdAcked();
                            const window = adpMsg.getWindow();
                            const flowId = adpMsg.getFlowId();
                            const flowName = adpMsg.getFlowName();
                            const publisherId = adpMsg.getPublisherId();
                            LOG_DEBUG(`OPENPUBFLOW response attributes: lastMsgIDAcked=${lastMsgIDAcked} window=${window} flowId=${flowId} flowName=${flowName} publisherId=${publisherId}`);
                            LOG_TRACE(`Local before handling response: ${fsm._messageIds}`);
                            if (window === undefined) {
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    description: "Window parameter not found"
                                }));
                            }
                            if (window > this._windowSize) {
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    description: "Invalid window negotiation"
                                }));
                            }
                            fsm._sendWindow = window - fsm._unackedList.length;
                            if (fsm._sendWindow < 0) fsm._sendWindow = 0;
                            Object.assign(fsm._publisher, {
                                name: flowName,
                                flowId: flowId,
                                publisherId: publisherId
                            });
                            fsm._guaranteedEnabled = true;
                            if (fsm._connectReason === ConnectReason.INIT || fsm._connectReason === ConnectReason.FAILOVER) {
                                fsm._messageIds.setLastSent(lastMsgIDAcked);
                                LOG_DEBUG(`Renumbering unacked/unsent messages: fsm._messageIds=${fsm._messageIds}, lastMsgIDAcked=${lastMsgIDAcked}, type=${fsm._connectReason}`);
                                if (fsm._connectReason === ConnectReason.FAILOVER) {
                                    publisher.emit(MessagePublisherEventName.FLOW_NAME_CHANGED, {
                                        messages: [ ...fsm._unackedList ],
                                        count: fsm._unackedList.length
                                    });
                                }
                                fsm._connectReason = ConnectReason.RESUME;
                                fsm._unackedList.forEach(message => {
                                    const oldId = message.getGuaranteedMessageId();
                                    fsm._renumber(message);
                                    LOG_TRACE(`Renumbering message ID: from ${oldId} to ${message.getGuaranteedMessageId()}`);
                                    fsm._messageIds.setLastSent(message.getGuaranteedMessageId());
                                });
                            } else {
                                fsm._unackedList.forEach(message => {
                                    message.setFlowId(flowId);
                                    message.setPublisherId(publisher.publisherId);
                                    LOG_TRACE(`Set FlowId to ${flowId} in msg# ${message.getGuaranteedMessageId()}`);
                                });
                            }
                            const payloadSizeLimit = fsm._sessionInterface.getCapability(SolclientSession.CapabilityType.MAX_GUARANTEED_MSG_SIZE).getValue();
                            fsm._unackedList.forEach(message => {
                                if (payloadSizeLimit < message._memoized_payload.length) {
                                    LOG_WARN(`Message size ${message._memoized_payload.length} above broker limit ${payloadSizeLimit}`);
                                }
                            });
                            if (fsm._unackedList.length) {
                                fsm._handleAck(lastMsgIDAcked, false, adpMsg, true);
                                fsm._firstUnackedToSend = fsm._unackedList[0];
                            } else {
                                fsm._messageIds.lastAcked = Long.fromValue(lastMsgIDAcked);
                            }
                            LOG_TRACE(`Local after applying lastMsgIDAcked: ${fsm._messageIds}`);
                            return fsm.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.FLOW_UP
                            }));
                        },
                        handleOpenFlowTimeout() {
                            LOG_INFO("Open publisher connection timeout");
                            return fsm.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.BIND_TIMEOUT
                            }));
                        },
                        handleUnknownFlowName() {
                            LOG_INFO("Flow name unknown, republish required");
                            fsm._resetConnectedInfo(true);
                            return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
                        },
                        sendOpenFlow() {
                            const correlationTag = sessionInterface.getCorrelationTag();
                            LOG_TRACE(`sendOpenFlow correlationTag: ${correlationTag}`);
                            const openPubFlowMsg = SMFLib.AdProtocolMessage.getOpenMessagePublisher(fsm._messageIds.lastAcked, fsm._messageIds.lastSent, properties.windowSize, fsm._publisher._flowName, correlationTag);
                            LOG_TRACE("sendOpenFlow openPubFlowMsg constituents:");
                            LOG_TRACE(`fsm._messageIds.lastAcked:${fsm._messageIds.lastAcked} fsm._messageIds.lastSent:${fsm._messageIds.lastSent} properties.windowSize:${properties.windowSize} fsm._publisher._flowName:${fsm._publisher._flowName} `);
                            sessionInterface.sendControl(openPubFlowMsg);
                            sessionInterface.enqueueRequest(correlationTag, () => this.handleOpenFlowTimeout(), properties.connectTimeoutInMsecs, null, rxMsgObj => this.handleOpenFlowResponse(rxMsgObj));
                            LOG_TRACE("Sent open publisher connection");
                        }
                    }).entry(function onEntry() {
                        try {
                            this.sendOpenFlow();
                        } catch (e) {
                            LOG_WARN(`Exception during bind attempt: ${e}`);
                            fsm.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.SESSION_DOWN
                            }));
                        }
                    }).reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                        return this.transitionTo(fsm.PublisherCloseFlowSent);
                    }).reaction(PublisherFSMEventNames.FLOW_UP, function onFlowUp() {
                        return this.transitionTo(fsm.PublisherUp);
                    }).reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.transitionTo(fsm.PublisherUnbound);
                    }).reaction(PublisherFSMEventNames.BIND_TIMEOUT, function onOpenFlowTimeout() {
                        if (fsm._connectRetryCount > 0) {
                            fsm._connectRetryCount--;
                            return this.externalTransitionTo(fsm.PublisherOpenFlowSent);
                        }
                        this.emitOpenFlowFailedError({
                            subcode: ErrorSubcode.TIMEOUT,
                            description: "Open publisher connection failed due to timeout"
                        });
                        return this.transitionTo(fsm.PublisherUnbound);
                    }).reaction(PublisherFSMEventNames.FLOW_FAILED, function onFlowFailed(pEvent) {
                        const {
                            subcode,
                            returnCode,
                            description
                        } = pEvent;
                        LOG_TRACE(`FLOW_FAILED in PublisherOpenFlowSent state: subcode: ${subcode}, returnCode: ${returnCode}, description: ${description}`);
                        switch (pEvent.subcode) {
                          case ErrorSubcode.UNKNOWN_FLOW_NAME:
                            return this.handleUnknownFlowName();

                          default:
                            this.emitOpenFlowFailedError({
                                event: pEvent,
                                subcode: subcode,
                                returnCode: returnCode,
                                description: description
                            });
                            fsm._resetConnectedInfo();
                        }
                        return this.transitionTo(fsm.PublisherUnbound);
                    });
                    fsm.PublisherCloseFlowSent = new State({
                        name: PublisherStateNames.CLOSEFLOWSENT,
                        parentContext: fsm
                    }, {
                        handleCloseFlowResponse(response) {
                            const smfRespHeader = response.smfHeader;
                            const respCode = smfRespHeader.pm_respcode;
                            if (response.msgType !== SMFLib.SMFAdProtocolMessageType.CLOSEPUBFLOW) {
                                return fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    returnCode: respCode,
                                    description: `Unexpected response: ${SMFLib.SMFAdProtocolMessageType.describe(response.msgType)}`
                                }));
                            }
                            if (respCode === null) {
                                publisher.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                                LOG_DEBUG(`Drop Close-Publisher-Flow Request message on sessionId 0x${sessionInterface.sessionIdHex}`);
                                return null;
                            }
                            if (respCode !== 200) {
                                fsm.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.FLOW_FAILED
                                }, {
                                    returnCode: respCode,
                                    description: smfRespHeader.pm_respstr
                                }));
                            }
                            return fsm.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.FLOW_UNBOUND
                            }));
                        },
                        handleCloseFlowTimeout() {
                            LOG_INFO("Close publisher connection timeout.");
                            return fsm.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.UNBIND_TIMEOUT
                            }));
                        },
                        sendCloseFlow() {
                            const correlationTag = sessionInterface.getCorrelationTag();
                            const closePubFlowMsg = SMFLib.AdProtocolMessage.getCloseMessagePublisher(fsm._publisher.flowId, correlationTag);
                            sessionInterface.sendControl(closePubFlowMsg);
                            sessionInterface.enqueueRequest(correlationTag, () => this.handleCloseFlowTimeout(), properties.connectTimeoutInMsecs, null, rxMsgObj => this.handleCloseFlowResponse(rxMsgObj));
                            LOG_TRACE("Sent close publisher connection");
                        }
                    }).entry(function onEntry() {
                        this.sendCloseFlow();
                        return this;
                    }).reaction(PublisherFSMEventNames.ACK, function onAck(event) {
                        fsm._handleAckEvent(event);
                        return this.internalTransition();
                    }).reaction(PublisherFSMEventNames.FLOW_UNBOUND, function onFlowUnbound() {
                        return this.transitionTo(fsm.PublisherUnbound);
                    }).reaction(PublisherFSMEventNames.FLOW_FAILED, function onCloseFlowFailed() {
                        this.transitionTo(fsm.PublisherUnbound);
                    }).reaction(PublisherFSMEventNames.UNBIND_TIMEOUT, function onCloseFlowTimeout() {
                        return this.transitionTo(fsm.PublisherCloseFlowSent);
                    });
                    fsm.PublisherUp = new State({
                        name: PublisherStateNames.UP,
                        parentContext: fsm
                    }, {
                        emitFlowUp() {
                            publisher.emit(MessagePublisherEventName.UP);
                        }
                    }).initial(function initial() {
                        return this.transitionTo(fsm._unackedList.length ? fsm.PublisherRetransmitting : fsm.PublisherDataXfer);
                    }).entry(function onEntry() {
                        LOG_DEBUG("Flow is UP");
                        fsm._scheduleStateEvents(fsm.PublisherUp, () => this.emitFlowUp());
                        return this;
                    }).reaction(PublisherFSMEventNames.ACK, function onAck(event) {
                        LOG_DEBUG("Ack received");
                        fsm._handleAckEvent(event);
                        return this.internalTransition();
                    }).reaction(PublisherFSMEventNames.ACK_TIMEOUT, function onAckTimeout() {
                        fsm._firstUnackedToSend = fsm._unackedList[0];
                        return this.transitionTo(fsm.PublisherRetransmitting);
                    }).reaction(PublisherFSMEventNames.FLOW_CLOSE, function onFlowClose() {
                        return this.transitionTo(fsm.PublisherCloseFlowSent);
                    }).reaction(PublisherFSMEventNames.SESSION_DOWN, function onSessionDown() {
                        return this.transitionTo(fsm.PublisherUnbound);
                    }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onWindowClosed() {
                        return this.internalTransition();
                    });
                    fsm.PublisherDataXfer = new State({
                        name: PublisherStateNames.DATA_XFER,
                        parentContext: fsm.PublisherUp
                    }).entry(() => {
                        fsm._transportFlowControlled = false;
                        fsm._scheduleStateEvents(fsm.PublisherDataXfer, () => fsm._maybeEmitCanSend());
                    }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
                        return this.transitionTo(fsm.PublisherFlowControlled);
                    }).exit(() => {
                        fsm._transportFlowControlled = true;
                    });
                    fsm.PublisherFlowControlled = new State({
                        name: PublisherStateNames.FLOW_CONTROLLED,
                        parentContext: fsm.PublisherUp
                    }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
                        LOG_INFO("Attempt to send while flow controlled");
                        return this.internalTransition();
                    }).reaction(PublisherFSMEventNames.CAN_SEND, function onCanSend() {
                        return this.transitionTo(fsm.PublisherRetransmitting);
                    });
                    fsm.PublisherRetransmitting = new State({
                        name: PublisherStateNames.RETRANSMITTING,
                        parentContext: fsm.PublisherUp
                    }, {
                        retransmit() {
                            try {
                                fsm._resendFromUnacked();
                            } catch (ex) {
                                if (ex instanceof OperationError && ex.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
                                    LOG_DEBUG("Publisher resendFromUnacked blocked due to insufficient space, wait for CAN_SEND");
                                    fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.TRANSPORT_FULL
                                    }));
                                } else {
                                    LOG_INFO(`Publisher resendFromUnacked failed: ${ex}`);
                                    fsm.processEvent(new PublisherFSMEvent({
                                        name: PublisherFSMEventNames.FLOW_FAILED
                                    }));
                                }
                            }
                        }
                    }).entry(function onEntry() {
                        this.retransmit();
                    }).reaction(PublisherFSMEventNames.RESEND_COMPLETE, function onResendComplete() {
                        return this.transitionTo(fsm.PublisherDataXfer);
                    }).reaction(PublisherFSMEventNames.TRANSPORT_FULL, function onTransportFull() {
                        LOG_DEBUG(`Transport full while retransmitting, unacked remaining: ${fsm._unackedList.length}`);
                        return this.transitionTo(fsm.PublisherFlowControlled);
                    });
                }
                isDisconnected() {
                    if (!this.getCurrentState()) return true;
                    return !!this.getActiveState(PublisherStateNames.UNBOUND);
                }
                prepareAdMessageAndSend(dataMsg) {
                    if (!this._guaranteedEnabled) {
                        throw new OperationError("Session does not provide Guaranteed Message Publish capability", ErrorSubcode.GM_UNAVAILABLE, "close flow received from message-router");
                    }
                    if (this._sendWindow <= 0) {
                        this._publisher.incStat(StatType.TX_WINDOW_CLOSED);
                        this._notifiedWindowClosed = true;
                        throw new OperationError("Guaranteed Message Window Closed", ErrorSubcode.INSUFFICIENT_SPACE);
                    }
                    const unackedList = this._unackedList;
                    const {
                        LOG_TRACE,
                        LOG_DEBUG,
                        LOG_INFO,
                        LOG_WARN
                    } = this.logger;
                    if (dataMsg._payload_is_memoized) {
                        dataMsg._payload_is_memoized = false;
                        dataMsg._memoized_csumm = undefined;
                        dataMsg._memoized_payload = undefined;
                    }
                    const dupMsg = dataMsg.clone();
                    const payloadSize = SMFLib.Codec.Encode.adaptMessageToSmf_payloadMemoize(dupMsg);
                    var payloadSizeLimit = 0;
                    try {
                        payloadSizeLimit = this._sessionInterface.getCapability(SolclientSession.CapabilityType.MAX_GUARANTEED_MSG_SIZE).getValue();
                        LOG_TRACE(`Payload size limit: ${payloadSizeLimit}`);
                    } catch (e) {
                        LOG_INFO("Can't pre-check payload size, broker not connected yet?");
                        LOG_TRACE(e.stack);
                    }
                    if (0 < payloadSizeLimit && payloadSize > payloadSizeLimit) {
                        throw new OperationError(`Encoded payload size (${payloadSize}) exceeds broker size limit (MAX_GUARANTEED_MSG_SIZE, ${payloadSizeLimit})`, ErrorSubcode.MESSAGE_TOO_LARGE);
                    }
                    --this._sendWindow;
                    this._renumber(dupMsg);
                    this._cloneNumbers(dupMsg, dataMsg);
                    unackedList.push(dupMsg);
                    const msgId = dupMsg.getGuaranteedMessageId();
                    this._messageIds.setLastSent(msgId);
                    LOG_TRACE(`Prepare and send AD message ID = ${msgId}, 
      unackedListSize = ${unackedList.length}, sendWindow = ${this._sendWindow}`);
                    if (this._transportFlowControlled) {
                        if (this._firstUnackedToSend === undefined) {
                            this._firstUnackedToSend = dupMsg;
                        }
                        return TransportReturnCode.OK;
                    }
                    let returnCode;
                    try {
                        returnCode = this._sessionInterface.sendToTransport(dupMsg);
                        if (returnCode !== TransportReturnCode.OK) {
                            if (returnCode === TransportReturnCode.NO_SPACE) {
                                returnCode = TransportReturnCode.OK;
                                this._firstUnackedToSend = dupMsg;
                                this.processEvent(new PublisherFSMEvent({
                                    name: PublisherFSMEventNames.TRANSPORT_FULL
                                }));
                            } else {
                                LOG_DEBUG(`prepareAdMessageAndSend: saw returnCode = ${returnCode}`);
                            }
                        } else {
                            dupMsg.setRedelivered(true);
                        }
                        this._startAckTimer();
                    } catch (ex) {
                        if (ex instanceof OperationError) {
                            LOG_DEBUG(`prepareAdMessageAndSend: caught OperationError: ${ErrorSubcode.describe(ex.subcode)} - ${ex.message}`);
                            unackedList.pop();
                            this._messageIds.setLastSent(dupMsg.getGuaranteedPreviousMessageId());
                            ++this._sendWindow;
                            throw ex;
                        } else {
                            LOG_DEBUG(`prepareAdMessageAndSend: caught ${ex.message}`);
                            throw ex;
                        }
                    }
                    return TransportReturnCode.OK;
                }
                _handleAckEvent(event) {
                    this._publisher.incStat(StatType.TX_ACKS_RXED);
                    this._handleAck(event.ack || event.nack, !!event.nack, event.ctrlMessage);
                }
                _handleAck(id, nack, ctrlMessage = undefined, openFlow = false) {
                    const {
                        _messageIds: messageIds,
                        _unackedList: unackedList
                    } = this;
                    const {
                        LOG_DEBUG,
                        LOG_INFO
                    } = this.logger;
                    if (messageIds.lastAcked.gte(id)) {
                        if (openFlow) {
                            LOG_DEBUG(`Implicit acks up to date: remote ack for ${id}, local ids ${this._messageIds}`);
                        } else {
                            LOG_INFO(`Dropping ack: remote ack for ${id}, local ids ${this._messageIds}`);
                        }
                        return;
                    }
                    const reportAcked = [];
                    while (unackedList.length && id.gte(unackedList[0].getGuaranteedMessageId())) {
                        reportAcked.push(unackedList.shift());
                    }
                    if (unackedList.indexOf(this._firstUnackedToSend) === -1) {
                        this._firstUnackedToSend = unackedList[0];
                    }
                    this._sendWindow += reportAcked.length;
                    LOG_DEBUG("Send window size is now", this._sendWindow);
                    messageIds.lastAcked = id;
                    const reportNacked = nack ? reportAcked.pop() : null;
                    const numAcked = reportAcked.length;
                    if (numAcked) {
                        if (this._acknowledgeMode === MessagePublisherAcknowledgeMode.PER_MESSAGE) {
                            LOG_DEBUG(`Ack received: lastAckedMsgId=${id}, numAckedMsgs=${numAcked}, numUnackedMsgs=${unackedList.length}`);
                            for (let i = 0; i < numAcked; ++i) {
                                this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, reportAcked[i]);
                            }
                        } else {
                            const lastAckedMessage = reportAcked[numAcked - 1];
                            LOG_DEBUG(`Acking single message with ID ${lastAckedMessage.getGuaranteedMessageId()} from router ack on ${id}`);
                            this._publisher.emit(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, lastAckedMessage);
                        }
                    }
                    if (reportNacked) {
                        LOG_DEBUG(`Nacking single message with ID ${reportNacked.getGuaranteedMessageId()} from router ack on ${id}`);
                        this._publisher.emit(MessagePublisherEventName.REJECTED_MESSAGE, reportNacked, ctrlMessage);
                    }
                    LOG_DEBUG("Unacked messages remaining: ", unackedList.length);
                    if (unackedList.length) {
                        this._resetAckTimer();
                    } else {
                        this._clearAckTimer();
                    }
                    this._maybeEmitCanSend();
                }
                _maybeEmitCanSend() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    if (!this._notifiedWindowClosed) return;
                    if (this._sendWindow === 0) {
                        LOG_TRACE("Suppressing CAN_SEND with zero window available");
                        return;
                    }
                    this._notifiedWindowClosed = false;
                    this._publisher.emit(MessagePublisherEventName.CAN_SEND);
                }
                _resendFromUnacked() {
                    const {
                        LOG_ERROR,
                        LOG_INFO,
                        LOG_DEBUG
                    } = this.logger;
                    const list = this._unackedList;
                    let resendIndex = list.indexOf(this._firstUnackedToSend);
                    if (resendIndex === -1) {
                        if (this._firstUnackedToSend) {
                            LOG_ERROR(`Could not find first Unacked Messages in unacked message list: msgId = ${this._firstUnackedToSend.getGuaranteedMessageId}`);
                        }
                        if (list.length === 0) {
                            LOG_DEBUG(`Nothing to resend: ${this._messageIds.toString()}`);
                            this.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.RESEND_COMPLETE
                            }));
                        }
                        return;
                    }
                    LOG_DEBUG(`Resending unacked messages from ${resendIndex} to ${list.length - 1}: `, list.map(m => m.getGuaranteedMessageId().toString()));
                    while (resendIndex < list.length) {
                        if (list[resendIndex].getPublisherId() !== this._publisher.publisherId) {
                            LOG_ERROR(`Resending on invalid publisherId '${list[resendIndex].getPublisherId()}'when it should be '${this._publisher.publisherId}'`);
                        }
                        const returnCode = this._sessionInterface.sendData(list[resendIndex]);
                        if (returnCode === TransportReturnCode.NO_SPACE) {
                            this._firstUnackedToSend = list[resendIndex];
                            LOG_INFO("Publisher sendMessage blocked due to insufficient space, wait for CAN_SEND");
                            this.processEvent(new PublisherFSMEvent({
                                name: PublisherFSMEventNames.TRANSPORT_FULL
                            }));
                            return;
                        }
                        if (returnCode !== TransportReturnCode.OK) {
                            return;
                        }
                        list[resendIndex].setRedelivered(true);
                        resendIndex++;
                        this._startAckTimer();
                    }
                    LOG_DEBUG(`Resend complete: ${this._messageIds.toString()}`);
                    this.processEvent(new PublisherFSMEvent({
                        name: PublisherFSMEventNames.RESEND_COMPLETE
                    }));
                }
                _resetConnectedInfo(failover = false) {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    LOG_DEBUG("Resetting connected flow info");
                    if (this._ackTimer) this._clearAckTimer();
                    Object.assign(this, {
                        _messageIds: new MessageIds()
                    });
                    Object.assign(this._publisher, {
                        publisherId: undefined,
                        flowId: undefined,
                        flowName: null
                    });
                    if (failover) {
                        this._connectReason = ConnectReason.FAILOVER;
                    } else {
                        this._unackedList = [];
                        this._connectReason = ConnectReason.INIT;
                    }
                }
                _clearAckTimer() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE(`Clear ack timer ${this._ackTimer ? this._ackTimer : "undefined or null or zero"}`);
                    if (!this._ackTimer) return;
                    clearTimeout(this._ackTimer);
                    this._ackTimer = null;
                }
                _emitStateEvents() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Emitting deferred state events");
                    while (this._stateEvents.length) {
                        const pair = this._stateEvents.shift();
                        const state = pair[0];
                        const event = pair[1];
                        if (this.getActiveState(state.getName())) {
                            event.apply(state);
                        }
                    }
                }
                _handleAckTimeout() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Ack Timeout");
                    this._ackTimer = null;
                    this._publisher.incStat(StatType.TX_ACK_TIMEOUT);
                    this.processEvent(new PublisherFSMEvent({
                        name: PublisherFSMEventNames.ACK_TIMEOUT
                    }));
                }
                _renumber(message) {
                    const messageIds = this._messageIds;
                    const current = messageIds.next;
                    message.setGuaranteedPreviousMessageId(messageIds.lastSent);
                    message.setGuaranteedMessageId(current);
                    const publisher = this._publisher;
                    message.setFlowId(publisher.flowId);
                    message.setPublisherId(publisher.publisherId);
                }
                _cloneNumbers(fromMsg, toMsg) {
                    toMsg.setGuaranteedPreviousMessageId(fromMsg.getGuaranteedPreviousMessageId());
                    toMsg.setGuaranteedMessageId(fromMsg.getGuaranteedMessageId());
                    toMsg.setFlowId(fromMsg.getFlowId());
                    toMsg.setPublisherId(fromMsg.getPublisherId());
                }
                _resetAckTimer() {
                    this._clearAckTimer();
                    this._startAckTimer();
                }
                _scheduleStateEvents(state, event) {
                    this._stateEvents.push([ state, event ]);
                    this._setPostEventAction(() => this._emitStateEvents(), "Emit state events");
                }
                _setPostEventAction(action, desc = "No action") {
                    const {
                        LOG_DEBUG,
                        LOG_WARN
                    } = this.logger;
                    if (this._postEventAction && this._postEventAction.desc === desc) {
                        LOG_DEBUG("Keeping same post event action");
                        return;
                    }
                    if (this._postEventAction && this._postEventAction.desc) {
                        LOG_WARN(`Replacing post event action ${this._postEventAction.desc} with ${desc}`);
                    }
                    this._postEventAction = {
                        action: action || (() => {}),
                        desc: desc
                    };
                    this.setPostEventAction(() => {
                        this._postEventAction.action();
                        this._postEventAction = null;
                    });
                }
                _startAckTimer() {
                    if (this._ackTimer) return;
                    this._ackTimer = setTimeout(() => this._handleAckTimeout(), this._acknowledgeTimeoutInMsecs);
                }
            }
            module.exports.PublisherFSM = PublisherFSM;
        },
        "./modules/solclient-message-publisher/lib/publisher-state-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const PublisherStateNames = {
                UNBOUND: "PublisherUnbound",
                OPENFLOWSENT: "PublisherOpenFlowSent",
                UP: "PublisherUp",
                FAILED: "PublisherFailed",
                CLOSEFLOWSENT: "PublisherCloseFlowSent",
                DATA_XFER: "PublisherDataXfer",
                FLOW_CONTROLLED: "MessagePublisherFlowControlled",
                RETRANSMITTING: "PublisherRetransmitting"
            };
            module.exports.PublisherStateNames = Enum.new(PublisherStateNames);
        },
        "./modules/solclient-message/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ReplicationGroupMessageId,
                RgmidFactory
            } = __webpack_require__("./modules/solclient-message/lib/replication-group-message-id.js");
            const {
                Message
            } = __webpack_require__("./modules/solclient-message/lib/message.js");
            const {
                MessageCacheStatus
            } = __webpack_require__("./modules/solclient-message/lib/message-cache-status.js");
            const {
                MessageDeliveryModeType
            } = __webpack_require__("./modules/solclient-message/lib/message-delivery-mode-types.js");
            const {
                MessageDumpFlag
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js");
            const {
                MessageDumpStandardProvider
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-standard-provider.js");
            const {
                MessageDumpUtil
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-util.js");
            const {
                MessageType
            } = __webpack_require__("./modules/solclient-message/lib/message-types.js");
            const {
                MessageUserCosType
            } = __webpack_require__("./modules/solclient-message/lib/message-user-cos-types.js");
            const {
                SolclientFactory
            } = __webpack_require__("./modules/solclient-factory/api.js");
            SolclientFactory.createMessage = SolclientFactory.createFactory(() => new Message());
            SolclientFactory.createReplicationGroupMessageId = SolclientFactory.createFactory(id => RgmidFactory.fromString(id));
            module.exports.Message = Message;
            module.exports.MessageCacheStatus = MessageCacheStatus;
            module.exports.MessageDeliveryModeType = MessageDeliveryModeType;
            module.exports.MessageDumpFlag = MessageDumpFlag;
            module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
            module.exports.MessageDumpUtil = MessageDumpUtil;
            module.exports.MessageType = MessageType;
            module.exports.MessageUserCosType = MessageUserCosType;
            module.exports.ReplicationGroupMessageId = ReplicationGroupMessageId;
            module.exports.RgmidFactory = RgmidFactory;
        },
        "./modules/solclient-message/lib/message-cache-status.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageCacheStatus = {
                LIVE: 0,
                CACHED: 1,
                SUSPECT: 2
            };
            module.exports.MessageCacheStatus = Enum.new(MessageCacheStatus);
        },
        "./modules/solclient-message/lib/message-delivery-mode-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageDeliveryModeType = {
                DIRECT: 0,
                PERSISTENT: 1,
                NON_PERSISTENT: 2
            };
            module.exports.MessageDeliveryModeType = Enum.new(MessageDeliveryModeType);
        },
        "./modules/solclient-message/lib/message-dump-flags.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageDumpFlag = {
                MSGDUMP_BRIEF: 0,
                MSGDUMP_FULL: 1
            };
            module.exports.MessageDumpFlag = Enum.new(MessageDumpFlag);
        },
        "./modules/solclient-message/lib/message-dump-standard-provider.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const MessageDumpUtilLib = __webpack_require__("./modules/solclient-message/lib/message-dump-util.js");
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                MessageCacheStatus
            } = __webpack_require__("./modules/solclient-message/lib/message-cache-status.js");
            const {
                MessageDeliveryModeType
            } = __webpack_require__("./modules/solclient-message/lib/message-delivery-mode-types.js");
            const {
                MessageDumpFlag
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js");
            const {
                MessageUserCosType
            } = __webpack_require__("./modules/solclient-message/lib/message-user-cos-types.js");
            const {
                SDTMapContainer,
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const MessageDumpStandardProvider = {
                fpDestination(message) {
                    const dest = message.getDestination();
                    if (dest !== null && dest instanceof Destination) {
                        return [ "Destination", true, dest.toString(), null ];
                    }
                    return [ "Destination", false, "", null ];
                },
                fpSenderId(message) {
                    return [ "SenderId", message.getSenderId() !== undefined && message.getSenderId() !== null, message.getSenderId(), null ];
                },
                fpAppmsgType(message) {
                    return [ "AppMessageType", message.getApplicationMessageType() !== undefined && message.getApplicationMessageType() !== null, message.getApplicationMessageType(), null ];
                },
                fpAppMsgId(message) {
                    return [ "AppMessageID", message.getApplicationMessageId() !== undefined && message.getApplicationMessageId() !== null, message.getApplicationMessageId(), null ];
                },
                fpSequenceNumber(message) {
                    const sequenceNum = message.getSequenceNumber();
                    if (typeof sequenceNum === "number") {
                        return [ "SequenceNumber", true, sequenceNum, null ];
                    }
                    return [ "SequenceNumber", false, "", null ];
                },
                fpTopicSequenceNumber(message) {
                    const topicSeqNo = message.getTopicSequenceNumber();
                    if (Long.isLong(topicSeqNo)) {
                        return [ "TopicSequenceNumber", true, topicSeqNo.toString(), null ];
                    }
                    return [ "TopicequenceNumber", false, "", null ];
                },
                fpCorrelationId(message) {
                    return [ "CorrelationId", message.getCorrelationId() !== undefined && message.getCorrelationId() !== null, message.getCorrelationId(), null ];
                },
                fpHttpContentType() {
                    return [ "HTTP Content Type", false, undefined, null ];
                },
                fpHttpContentEncoding() {
                    return [ "HTTP Content Encoding", false, undefined, null ];
                },
                fpSendTimestamp(message) {
                    const timestamp = message.getSenderTimestamp();
                    if (typeof timestamp === "number") {
                        const mdu = MessageDumpUtilLib.MessageDumpUtil;
                        return [ "SendTimestamp", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                    }
                    return [ "SendTimestamp", false, "", null ];
                },
                fpRcvTimestamp(message) {
                    const timestamp = message.getReceiverTimestamp();
                    if (typeof timestamp === "number") {
                        const mdu = MessageDumpUtilLib.MessageDumpUtil;
                        return [ "RcvTimestamp", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                    }
                    return [ "RcvTimestamp", false, "", null ];
                },
                fpClassOfService(message) {
                    const cos = message.getUserCos();
                    if (typeof cos === "number") {
                        return [ "Class Of Service", true, MessageUserCosType.nameOf(message.getUserCos()), null ];
                    }
                    return [ "Class Of Service", false, "", null ];
                },
                fpDeliveryMode(message) {
                    const mode = message.getDeliveryMode();
                    if (typeof mode === "number") {
                        return [ "DeliveryMode", true, MessageDeliveryModeType.nameOf(message.getDeliveryMode()), null ];
                    }
                    return [ "DeliveryMode", false, "", null ];
                },
                fpGuaranteedMsgId(message) {
                    const msgId = message.getGuaranteedMessageId();
                    if (Long.isLong(msgId)) {
                        return [ "Message Id", true, msgId.toString(10), null ];
                    }
                    return [ "Message Id", false, "", null ];
                },
                fpReplicationGroupMessageId(message) {
                    const rgmid = message.getReplicationGroupMessageId();
                    if (rgmid === undefined) {
                        return [ "Replication Group Message Id", false, "", null ];
                    }
                    return [ "Replication Group Message Id", true, rgmid.toString(), null ];
                },
                fpTimeToLive(message) {
                    const timeToLive = message.getTimeToLive();
                    if (typeof timeToLive === "number") {
                        const mdu = MessageDumpUtilLib.MessageDumpUtil;
                        const d = new Date();
                        return [ "TimeToLive", true, `${timeToLive} (${mdu.formatDate(d.getTime() + timeToLive)})`, null ];
                    }
                    return [ "TimeToLive", false, "", null ];
                },
                fpExpiration(message) {
                    const timestamp = message.getGMExpiration();
                    if (typeof timestamp === "number") {
                        const mdu = MessageDumpUtilLib.MessageDumpUtil;
                        return [ "Expiration", true, `${timestamp} (${mdu.formatDate(timestamp)})`, null ];
                    }
                    return [ "Expiration", false, "", null ];
                },
                fpMessageDMQEligible(message) {
                    return [ "DMQ Eligible", message.isDMQEligible(), "", null ];
                },
                fpMessageRedelivered(message) {
                    return [ "Message Re-delivered", message.isRedelivered(), "", null ];
                },
                fpMessageDeliveryCount(message) {
                    try {
                        return [ "Message Delivery Count", true, message.getDeliveryCount(), null ];
                    } catch (e) {
                        return [ "Message Delivery Count", false, "", null ];
                    }
                },
                fpDiscardIndication(message) {
                    return [ "Discard Indication", message.isDiscardIndication(), "", null ];
                },
                fpAckImmediately(message) {
                    return [ "ACK Immediately", message.isAcknowledgeImmediately(), "", null ];
                },
                fpElidingEligible(message) {
                    return [ "Eliding Eligible", message.isElidingEligible(), "", null ];
                },
                fpReplyMessage(message) {
                    return [ "Reply Message", message.isReplyMessage(), "", null ];
                },
                fpReplyTo(message) {
                    const replyTo = message.getReplyTo();
                    if (replyTo !== null && replyTo instanceof Destination) {
                        return [ "ReplyTo", true, replyTo.toString(), null ];
                    }
                    return [ "ReplyTo", false, "", null ];
                },
                fpDeliverToOne(message) {
                    return [ "Deliver To One", message.isDeliverToOne(), "", null ];
                },
                fpCacheMessage(message) {
                    return [ "Message from cache", message.getCacheStatus() !== MessageCacheStatus.LIVE, "", null ];
                },
                fpCacheRequestId(message) {
                    const cacheRequestId = message.getCacheRequestId();
                    if (Long.isLong(cacheRequestId)) {
                        return [ "Cache Request Id", true, cacheRequestId.toString, null ];
                    }
                    return [ "Cache Request Id", false, "", null ];
                },
                fpUserPropertyMap(message, flags) {
                    const propMap = message.getUserPropertyMap();
                    if (propMap !== null && propMap instanceof SDTMapContainer) {
                        const value = `${propMap.getKeys().length} entries`;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                            try {
                                const mdu = MessageDumpUtilLib.MessageDumpUtil;
                                detailValue = mdu.printMap(propMap, 2);
                            } catch (e) {
                                LOG_ERROR(e.message, e.stack);
                                detailValue = "Error";
                            }
                        }
                        return [ "User Property Map", true, value, detailValue ];
                    }
                    return [ "User Property Map", false, "", null ];
                },
                fpCorrelationTag(message) {
                    const strValue = message.getCorrelationKey();
                    return [ "Correlation Tag Pointer", strValue !== undefined && strValue !== null, strValue, null ];
                },
                fpUserData(message) {
                    if (StringUtils.notEmpty(message.getUserData())) {
                        return [ "User Data", true, `len=${message.getUserData().length}`, DebugLib.Debug.formatDumpBytes(message.getUserData(), true, 2) ];
                    }
                    return [ "User Data", false, "", null ];
                },
                fpSdtStream(message, flags) {
                    const sdtFieldValue = message.getSdtContainer();
                    if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.STREAM) {
                        const mdu = MessageDumpUtilLib.MessageDumpUtil;
                        const value = `${mdu.countItems(sdtFieldValue.getValue())} entries`;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                            try {
                                detailValue = mdu.printStream(sdtFieldValue.getValue(), 2);
                            } catch (e) {
                                LOG_ERROR(e.message, e.stack);
                                detailValue = "Error";
                            }
                        }
                        return [ "SDT Stream", true, value, detailValue ];
                    }
                    return [ "SDT Stream", false, "", null ];
                },
                fpSdtMap(message, flags) {
                    const sdtFieldValue = message.getSdtContainer();
                    if (sdtFieldValue !== null && sdtFieldValue.getType() === SDTFieldType.MAP) {
                        const value = `${sdtFieldValue.getValue().getKeys().length} entries`;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                            try {
                                const mdu = MessageDumpUtilLib.MessageDumpUtil;
                                detailValue = mdu.printMap(sdtFieldValue.getValue(), 2);
                            } catch (e) {
                                LOG_ERROR(e.message, e.stack);
                                detailValue = "Error";
                            }
                        }
                        return [ "SDT Map", true, value, detailValue ];
                    }
                    return [ "SDT Map", false, "", null ];
                },
                fpBinaryAttachment(message, flags) {
                    if (!message._binaryAttachment || message._binaryAttachment.length < 1) {
                        return [ "Binary Attachment", false, "", null ];
                    }
                    const att = message._binaryAttachment.toString("latin1");
                    const value = `len=${att.length}`;
                    let detailValue = null;
                    if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                        detailValue = DebugLib.Debug.formatDumpBytes(att, true, 2);
                    }
                    return [ "Binary Attachment", true, value, detailValue ];
                },
                fpXmlContent(message, flags) {
                    const xml = message.getXmlContent();
                    if (StringUtils.notEmpty(xml)) {
                        const value = `len=${xml.length}`;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                            detailValue = DebugLib.Debug.formatDumpBytes(xml, true, 2);
                        }
                        return [ "XML", true, value, detailValue ];
                    }
                    return [ "XML", false, "", null ];
                },
                fpXmlMetadata(message, flags) {
                    const xmlMetadata = message.getXmlMetadata();
                    if (StringUtils.notEmpty(xmlMetadata)) {
                        const value = `len=${xmlMetadata.length}`;
                        let detailValue = null;
                        if (flags === MessageDumpFlag.MSGDUMP_FULL) {
                            detailValue = DebugLib.Debug.formatDumpBytes(xmlMetadata, true, 2);
                        }
                        return [ "XML Metadata", true, value, detailValue ];
                    }
                    return [ "XML Metadata", false, "", null ];
                }
            };
            module.exports.MessageDumpStandardProvider = MessageDumpStandardProvider;
        },
        "./modules/solclient-message/lib/message-dump-util.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const MessageDumpStandardProviderLib = __webpack_require__("./modules/solclient-message/lib/message-dump-standard-provider.js");
            const {
                SDTFieldType,
                SDTMapContainer,
                SDTStreamContainer,
                SDTUnsupportedValueError,
                SDTValueErrorSubcode
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                MessageDumpFlag
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js");
            const {
                StringBuffer,
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const MessageDumpState = {
                get dumpProviders() {
                    const providers = MessageDumpStandardProviderLib.MessageDumpStandardProvider;
                    return Object.keys(providers).map(k => providers[k]);
                }
            };
            const MessageDumpUtil = {
                getOutOfRangeValue(rawData) {
                    if (typeof rawData === "string") {
                        return `<out of range>\n${DebugLib.Debug.formatDumpBytes(rawData)}`;
                    }
                    return `<out of range>\n${DebugLib.Debug.formatDumpBytes(rawData.toString("latin1"))}`;
                },
                getValue(sdtField) {
                    let value = null;
                    try {
                        value = sdtField.getValue();
                        return value;
                    } catch (e) {
                        if (e instanceof SDTUnsupportedValueError) {
                            if (e.getSubcode() === SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE) {
                                return this.getOutOfRangeValue(e.getSourceData());
                            }
                        } else if (e instanceof OperationError && e.subcode === ErrorSubcode.PARAMETER_INVALID_TYPE) {
                            return "<invalid type>";
                        }
                        throw e;
                    }
                },
                printMap(sdtMap, indent) {
                    if (Check.nothing(sdtMap) || !(sdtMap instanceof SDTMapContainer)) {
                        return null;
                    }
                    const lines = [];
                    const strIndent = StringUtils.padRight("", indent, " ");
                    const keys = sdtMap.getKeys().sort();
                    keys.forEach(key => {
                        const sdtFieldValue = sdtMap.getField(key);
                        const type = sdtFieldValue.getType();
                        const value = this.getValue(sdtFieldValue);
                        let strValue;
                        switch (type) {
                          case SDTFieldType.MAP:
                            strValue = `\n${this.printMap(value, indent + 2)}`;
                            break;

                          case SDTFieldType.STREAM:
                            strValue = `\n${this.printStream(value, indent + 2)}`;
                            break;

                          case SDTFieldType.BYTEARRAY:
                            strValue = DebugLib.Debug.formatDumpBytes(value.toString("latin1"), false, 0);
                            if (strValue !== null && strValue.substr(-1) === "\n") {
                                strValue = strValue.substring(0, strValue.length - 1);
                            }
                            break;

                          default:
                            strValue = value !== null ? value.toString() : null;
                        }
                        lines.push(`${strIndent}Key '${key}' (${SDTFieldType.nameOf(type)}): ${strValue}`);
                    });
                    return lines.join("\n");
                },
                printStream(sdtStream, indent) {
                    if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) {
                        return null;
                    }
                    sdtStream.rewind();
                    const lines = [];
                    const strIndent = StringUtils.padRight("", indent, " ");
                    while (sdtStream.hasNext()) {
                        const sdtFieldValue = sdtStream.getNext();
                        const type = sdtFieldValue.getType();
                        const value = this.getValue(sdtFieldValue);
                        let strValue;
                        switch (type) {
                          case SDTFieldType.MAP:
                            strValue = `\n${this.printMap(value, indent + 2)}`;
                            break;

                          case SDTFieldType.STREAM:
                            strValue = `\n${this.printStream(value, indent + 2)}`;
                            break;

                          case SDTFieldType.BYTEARRAY:
                            strValue = DebugLib.Debug.formatDumpBytes(value.toString("latin1"), false, 0);
                            if (strValue !== null && strValue.substr(-1) === "\n") {
                                strValue = strValue.substring(0, strValue.length - 1);
                            }
                            break;

                          case SDTFieldType.DESTINATION:
                            strValue = value.toString();
                            break;

                          default:
                            strValue = value !== null ? value.toString() : null;
                        }
                        lines.push(`${strIndent}(${SDTFieldType.nameOf(type)}): ${strValue}`);
                    }
                    sdtStream.rewind();
                    return lines.join("\n");
                },
                countItems(sdtStream) {
                    if (Check.nothing(sdtStream) || !(sdtStream instanceof SDTStreamContainer)) {
                        return 0;
                    }
                    sdtStream.rewind();
                    let count = 0;
                    while (sdtStream.hasNext()) {
                        sdtStream.getNext();
                        count++;
                    }
                    sdtStream.rewind();
                    return count;
                },
                formatDate(timeStamp) {
                    return new Date(timeStamp).toString();
                },
                dump(message, flags, separator, colPadding) {
                    const sb = new StringBuffer();
                    let theSeparator = "\n";
                    let needSeparator = false;
                    let theColPadding = 40;
                    if (separator !== undefined && separator !== null && typeof separator === "string") {
                        theSeparator = separator;
                    }
                    if (colPadding !== undefined && colPadding !== null && typeof colPadding === "number") {
                        theColPadding = colPadding;
                    }
                    MessageDumpState.dumpProviders.forEach((provider, index) => {
                        const [ key, isPresent, value, detailValue ] = provider(message, flags);
                        if (!isPresent) {
                            return;
                        }
                        if (needSeparator) {
                            sb.append(theSeparator);
                        }
                        if (value === null || value.length === 0) {
                            sb.append(key);
                        } else {
                            sb.append(StringUtils.padRight(`${key}:`, theColPadding, " "));
                            sb.append(value);
                        }
                        if (detailValue !== null && flags & MessageDumpFlag.MSGDUMP_FULL) {
                            sb.append("\n");
                            if (detailValue.indexOf("  ") !== 0) {
                                sb.append("  ");
                            }
                            sb.append(detailValue);
                            if (detailValue.substr(-1) !== "\n" && index < MessageDumpState.dumpProviders.length - 1) {
                                sb.append("\n");
                            }
                        }
                        needSeparator = true;
                    });
                    return sb.toString();
                }
            };
            module.exports.MessageDumpUtil = MessageDumpUtil;
        },
        "./modules/solclient-message/lib/message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageType = {
                BINARY: 0,
                MAP: 1,
                STREAM: 2,
                TEXT: 3
            };
            module.exports.MessageType = Enum.new(MessageType);
        },
        "./modules/solclient-message/lib/message-user-cos-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MessageUserCosType = {
                COS1: 0,
                COS2: 1,
                COS3: 2
            };
            module.exports.MessageUserCosType = Enum.new(MessageUserCosType);
        },
        "./modules/solclient-message/lib/message.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const clone = __webpack_require__("./node_modules/clone/clone.js");
            const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                Codec: SDTCodec
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LOG_DEBUG
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                MessageCacheStatus
            } = __webpack_require__("./modules/solclient-message/lib/message-cache-status.js");
            const {
                MessageDeliveryModeType
            } = __webpack_require__("./modules/solclient-message/lib/message-delivery-mode-types.js");
            const {
                MessageDumpFlag
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-flags.js");
            const {
                MessageDumpUtil
            } = __webpack_require__("./modules/solclient-message/lib/message-dump-util.js");
            const {
                MessageType
            } = __webpack_require__("./modules/solclient-message/lib/message-types.js");
            const {
                MessageUserCosType
            } = __webpack_require__("./modules/solclient-message/lib/message-user-cos-types.js");
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                RgmidFactory
            } = __webpack_require__("./modules/solclient-message/lib/replication-group-message-id.js");
            const {
                SDTField,
                SDTFieldType,
                SDTMapContainer,
                SDTUnsupportedValueError
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                ProfileBinding
            } = SolclientFactoryLib;
            const {
                utf8ToUcs2,
                anythingToBuffer
            } = Convert;
            const {
                isBoolean,
                isEnumMember,
                isInstanceOf,
                isInstanceOfOrNothing,
                isNumberOrNothing,
                isStringOrNothing
            } = Parameter;
            const MESSAGE_CLONE_OPTIONS = {
                circular: false,
                includeNonEnumerable: false
            };
            function initMessage(message) {
                message._deliveryMode = MessageDeliveryModeType.DIRECT;
                message._userCos = MessageUserCosType.COS1;
                message._cacheStatus = MessageCacheStatus.LIVE;
                message._spoolerUniqueId = undefined;
                message._priority = undefined;
                message._deliveryCount = -1;
            }
            function clearMessage(message) {
                const fields = Object.keys(message);
                fields.forEach(f => delete message[f]);
            }
            class Message {
                constructor() {
                    initMessage(this);
                }
                getType() {
                    return this._messageType || MessageType.BINARY;
                }
                setApplicationMessageId(value) {
                    this._applicationMessageId = isStringOrNothing("applicationMessageId", value);
                }
                getApplicationMessageId() {
                    return this._applicationMessageId;
                }
                setApplicationMessageType(value) {
                    this._applicationMessageType = isStringOrNothing("applicationMessageType", value);
                }
                getApplicationMessageType() {
                    return this._applicationMessageType;
                }
                getBinaryAttachment() {
                    if (this._binaryAttachment && ProfileBinding.value.byteArrayAsString) {
                        return this._binaryAttachment.toString("latin1");
                    }
                    return this._binaryAttachment;
                }
                setBinaryAttachment(value) {
                    if (value) {
                        this._messageType = MessageType.BINARY;
                    }
                    this._setBinaryAttachment(anythingToBuffer(value));
                }
                _setBinaryAttachment(value) {
                    this._binaryAttachment = value;
                }
                getCacheRequestId() {
                    return this._cacheRequestId;
                }
                _setCacheRequestID(cacheRequestID) {
                    this._cacheRequestId = cacheRequestID;
                }
                getCorrelationId() {
                    return this._correlationId;
                }
                setCorrelationId(value) {
                    this._correlationId = isStringOrNothing("correlationId", value);
                }
                getCorrelationKey() {
                    return this._correlationKey || null;
                }
                setCorrelationKey(value) {
                    this._correlationKey = value;
                }
                isDeliverToOne() {
                    return this._deliverToOne || false;
                }
                setDeliverToOne(value) {
                    this._setDeliverToOne(this._deliverToOne = isBoolean("deliverToOne", value));
                }
                _setDeliverToOne(value) {
                    this._deliverToOne = value;
                }
                getDeliveryMode() {
                    return this._deliveryMode;
                }
                setDeliveryMode(value) {
                    this._setDeliveryMode(isEnumMember("deliveryMode", value, MessageDeliveryModeType));
                }
                _setDeliveryMode(value) {
                    this._deliveryMode = value;
                }
                getDestination() {
                    return this._destination;
                }
                setDestination(value) {
                    this._setDestination(isInstanceOf("destination", value, Destination));
                }
                _setDestination(value) {
                    this._destination = value;
                }
                isDiscardIndication() {
                    return this._discardIndication || false;
                }
                setDiscardIndication(value) {
                    this._setDiscardIndication(isBoolean("discardIndication", value));
                }
                _setDiscardIndication(value) {
                    this._discardIndication = value;
                }
                isElidingEligible() {
                    return this._elidingEligible || false;
                }
                setElidingEligible(value) {
                    this._setElidingEligible(isBoolean("setElidingEligible", value));
                }
                _setElidingEligible(value) {
                    this._elidingEligible = value;
                }
                getPublisherId() {
                    return this._publisherId;
                }
                setPublisherId(value) {
                    this._publisherId = value;
                }
                getPublisherMessageId() {
                    return this._publisherMsgId;
                }
                setPublisherMessageId(value) {
                    this._publisherMsgId = value;
                }
                getTimeToLive() {
                    return this._timeToLive;
                }
                setTimeToLive(value) {
                    const MAX_MESSAGE_TTL_MS = 10 * 365 * 24 * 60 * 60 * 1e3;
                    if (value === null || value === undefined) {
                        this._timeToLive = value;
                        return;
                    }
                    if (typeof value !== "number" || isNaN(value)) {
                        throw new OperationError("Invalid type for time to live", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (value < 0 || value > MAX_MESSAGE_TTL_MS) {
                        throw new OperationError("Invalid time to live value", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    this._timeToLive = value;
                }
                getGMExpiration() {
                    return this._expiration;
                }
                setGMExpiration(value) {
                    this._expiration = isNumberOrNothing("GMExpiration", value);
                }
                isDMQEligible() {
                    return this._dmqEligible || false;
                }
                setDMQEligible(value) {
                    this._setDMQEligible(isBoolean("DMQEligible", value));
                }
                _setDMQEligible(value) {
                    this._dmqEligible = value;
                }
                getFlowId() {
                    return this._flowId;
                }
                setFlowId(value) {
                    this._flowId = value;
                }
                getGuaranteedPreviousMessageId() {
                    return this._guaranteedPrevMsgId;
                }
                setGuaranteedPreviousMessageId(value) {
                    this._guaranteedPrevMsgId = value;
                }
                _setSpoolerUniqueId(value) {
                    this._spoolerUniqueId = value;
                }
                _getSpoolerUniqueId() {
                    if (this._spoolerUniqueId === undefined) {
                        return RgmidFactory.INVALID_SUID;
                    }
                    return this._spoolerUniqueId;
                }
                getMessageConsumer() {
                    return this._consumer;
                }
                setMessageConsumer(value) {
                    this._consumer = value;
                }
                getGuaranteedMessageId() {
                    return this._guaranteedMsgId;
                }
                setGuaranteedMessageId(value) {
                    this._guaranteedMsgId = value;
                }
                _setSpoolerMessageId(value) {
                    this._spoolerMessageId = value;
                }
                getReplicationGroupMessageId() {
                    if (this._spoolerUniqueId === undefined || RgmidFactory.INVALID_SUID.eq(this._spoolerUniqueId)) {
                        return undefined;
                    }
                    const smid = this._spoolerMessageId || this._guaranteedMsgId;
                    return RgmidFactory.from({
                        suid: this._spoolerUniqueId,
                        msgid: smid
                    });
                }
                getTopicSequenceNumber() {
                    return this._topicSequenceNumber;
                }
                setTopicSequenceNumber(topicSeqNo) {
                    this._topicSequenceNumber = topicSeqNo;
                }
                getDeliveryCount() {
                    if (this._deliveryCount === -1) {
                        throw new OperationError("Endpoint does not report delivery count.", ErrorSubcode.INVALID_OPERATION);
                    }
                    return this._deliveryCount;
                }
                setDeliveryCount(deliveryCount) {
                    this._deliveryCount = deliveryCount;
                }
                acknowledge() {
                    if (this._consumer.getProperties().browser) {
                        throw new OperationError("Messages delivered to a Queue Browser can only be deleted by calling QueueBrowser.removeMessageFromQueue()", ErrorSubcode.INVALID_OPERATION);
                    }
                    if (this._acked) {
                        throw new OperationError("Message can only be acknowledged once", ErrorSubcode.MESSAGE_ALREADY_ACKNOWLEDGED);
                    }
                    if (this._deliveryMode === MessageDeliveryModeType.DIRECT) {
                        throw new OperationError("Cannot acknowledge a DIRECT message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                    }
                    if (!this._consumer) {
                        throw new OperationError("Cannot acknowledge a locally-created message", ErrorSubcode.MESSAGE_DELIVERY_MODE_MISMATCH);
                    }
                    if (!this._consumer._sessionInterface.canAck) {
                        throw new OperationError("Cannot acknowledge using associated session", ErrorSubcode.SESSION_NOT_CONNECTED);
                    }
                    if (!this._consumer.canAck) {
                        throw new OperationError("Cannot acknowledge using associated Message Consumer", ErrorSubcode.INVALID_OPERATION);
                    }
                    this._consumer.applicationAck(this._guaranteedMsgId);
                    this._acked = true;
                }
                get isAcknowledged() {
                    return this._acked || false;
                }
                isAcknowledgeImmediately() {
                    return this._ackImmediately || false;
                }
                setAcknowledgeImmediately(value) {
                    this._setAcknowledgeImmediately(isBoolean("acknowledgeImmediately", value));
                }
                _setAcknowledgeImmediately(value) {
                    this._ackImmediately = value;
                }
                getCacheStatus() {
                    return this._cacheStatus;
                }
                _setCacheStatus(cacheStatus) {
                    this._cacheStatus = cacheStatus;
                }
                isReplyMessage() {
                    return this._replyMessage || false;
                }
                isRedelivered() {
                    return this._redelivered || false;
                }
                setRedelivered(value) {
                    this._redelivered = value;
                }
                setAsReplyMessage(value) {
                    this._replyMessage = isBoolean("asReplyMessage", value);
                }
                getReceiverTimestamp() {
                    return this._receiverTimestamp;
                }
                getReplyTo() {
                    return this._replyTo;
                }
                setReplyTo(value) {
                    this._replyTo = isInstanceOfOrNothing("replyTo", value, Destination);
                }
                getSenderId() {
                    return this._senderId;
                }
                setSenderId(value) {
                    this._senderId = isStringOrNothing("senderId", value);
                }
                getSenderTimestamp() {
                    return this._senderTimestamp;
                }
                setSenderTimestamp(value) {
                    this._senderTimestamp = isNumberOrNothing("senderTimestamp", value);
                }
                getSequenceNumber() {
                    if (this._sequenceNumberError) {
                        throw this._sequenceNumberError;
                    }
                    return this._sequenceNumber;
                }
                setSequenceNumber(value) {
                    if (value instanceof SDTUnsupportedValueError) {
                        this._sequenceNumberError = value;
                    } else {
                        this._sequenceNumber = isNumberOrNothing("sequenceNumber", value);
                        this._sequenceNumberError = undefined;
                        this._autoSequenceNumber = false;
                    }
                }
                getUserCos() {
                    return this._userCos;
                }
                getPriority() {
                    return this._priority;
                }
                setUserCos(value) {
                    this._setUserCos(isEnumMember("userCos", value, MessageUserCosType));
                }
                _setUserCos(value) {
                    this._userCos = value;
                }
                setPriority(value) {
                    if (value === undefined || value === null) {
                        this._setPriority(undefined);
                        return;
                    }
                    if (typeof value !== "number" || isNaN(value)) {
                        throw new OperationError("Invalid type for message priority", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (value < 0 || value > 255) {
                        throw new OperationError("Invalid priority value", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    this._setPriority(value);
                }
                _setPriority(value) {
                    this._priority = value;
                }
                getUserData() {
                    return this._userData;
                }
                setUserData(value) {
                    this._setUserData(isStringOrNothing("userData", value));
                }
                _setUserData(value) {
                    this._userData = value;
                }
                getXmlContent() {
                    return this._xmlContent;
                }
                getXmlContentDecoded() {
                    return this._xmlContent ? utf8ToUcs2(this._xmlContent) : this._xmlContent;
                }
                setXmlContent(value) {
                    const setValue = isStringOrNothing("xmlContent", value);
                    this._xmlContent = setValue ? unescape(encodeURIComponent(setValue)) : setValue;
                }
                _setXmlContentInternal(value) {
                    this._xmlContent = isStringOrNothing("xmlContentInternal", value);
                }
                setXmlMetadata(value) {
                    this._setXmlMetadata(isStringOrNothing("xmlMetadata", value));
                }
                _setXmlMetadata(value) {
                    this._xmlMetadata = value;
                }
                getXmlMetadata() {
                    return this._xmlMetadata;
                }
                get binaryMetadataChunk() {
                    return this._binaryMetaChunk || null;
                }
                set binaryMetadataChunk(meta) {
                    this._binaryMetaChunk = meta;
                }
                get smfHeader() {
                    return this._smfHeader;
                }
                set smfHeader(val) {
                    this._smfHeader = val;
                }
                get hasAutoSequenceNumber() {
                    return this._autoSequenceNumber || false;
                }
                set hasAutoSequenceNumber(value) {
                    this._autoSequenceNumber = value;
                }
                get hasAutoSenderTimestamp() {
                    return this._autoSenderTimestamp || false;
                }
                set hasAutoSenderTimestamp(value) {
                    this._autoSenderTimestamp = value;
                }
                getUserPropertyMap() {
                    return this._userPropertyMap;
                }
                setUserPropertyMap(value) {
                    this._userPropertyMap = isInstanceOfOrNothing("userPropertyMap", value, SDTMapContainer);
                }
                setSdtContainer(container) {
                    const structuredContainer = isInstanceOfOrNothing("sdtContainer", container, SDTField);
                    if (structuredContainer === null || structuredContainer === undefined) {
                        this._structuredContainer = null;
                        this.setBinaryAttachment(null);
                        return;
                    }
                    this._setBinaryAttachment(null);
                    const sdtType = structuredContainer.getType();
                    switch (sdtType) {
                      case SDTFieldType.MAP:
                        this._messageType = MessageType.MAP;
                        break;

                      case SDTFieldType.STREAM:
                        this._messageType = MessageType.STREAM;
                        break;

                      case SDTFieldType.STRING:
                        this._messageType = MessageType.TEXT;
                        break;

                      default:
                        throw new OperationError("Invalid parameter: expected SDTField Type of " + "MAP, STREAM, or STRING.", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    this._structuredContainer = structuredContainer;
                }
                getSdtContainer() {
                    const msgType = this.getType();
                    const binaryAttachment = this._binaryAttachment;
                    const binaryAttachmentLength = binaryAttachment ? binaryAttachment.length : 0;
                    if (msgType === MessageType.BINARY) {
                        LOG_DEBUG(`getSdtContainer returned null, reason: msgType=${msgType}`);
                        return null;
                    }
                    if (typeof this._structuredContainer !== "undefined") {
                        return this._structuredContainer;
                    }
                    if (binaryAttachmentLength === 0) {
                        LOG_DEBUG(`getSdtContainer returned null, reason: len=${binaryAttachmentLength}`);
                        this._structuredContainer = null;
                    } else {
                        this._structuredContainer = SDTCodec.parseSingleElement(binaryAttachment, 0);
                    }
                    return this._structuredContainer;
                }
                dump(flags = MessageDumpFlag.MSGDUMP_FULL) {
                    const validFlags = isEnumMember("flags", flags, MessageDumpFlag);
                    return MessageDumpUtil.dump(this, validFlags);
                }
                clone() {
                    return clone(this, MESSAGE_CLONE_OPTIONS);
                }
                reset() {
                    clearMessage(this);
                    initMessage(this);
                }
            }
            module.exports.Message = Message;
        },
        "./modules/solclient-message/lib/replication-group-message-id.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ReplayStartLocation,
                ReplayStartType
            } = __webpack_require__("./modules/solclient-replaystart/api.js");
            const BufferImpl = __webpack_require__("buffer").Buffer;
            const RMID_VERSION_1_PREFIX = "rmid1:";
            const RMID_LEN = RMID_VERSION_1_PREFIX.length + 3 + 16 * 2;
            const validRmidHexRegex = /^[0-9a-fA-F]{32}$/g;
            const INVALID_SUID = Long.UZERO;
            const {
                isString,
                isValue,
                isInstanceOf
            } = Parameter;
            class ReplicationGroupMessageId extends ReplayStartLocation {
                constructor(spoolerUniqueId, effectiveMessageId) {
                    super({
                        _replayStartValue: {
                            suid: spoolerUniqueId,
                            messageId: effectiveMessageId
                        },
                        _type: ReplayStartType.RGMID
                    });
                    this._suid = spoolerUniqueId;
                    this._messageId = effectiveMessageId;
                }
                compare(otherReplicationGroupMessageId) {
                    isInstanceOf("otherReplicationGroupMessageId", otherReplicationGroupMessageId, ReplicationGroupMessageId);
                    const oId = otherReplicationGroupMessageId;
                    if (!this._suid.equals(oId._suid)) {
                        const message = "Unable to compare Replication Group Message ID from different origins";
                        throw new OperationError(`Parameter otherReplicationGroupMessageId[${oId.toString()}] failed validation`, ErrorSubcode.MESSAGE_ID_NOT_COMPARABLE, message);
                    }
                    if (this._messageId.gt(oId._messageId)) {
                        return 1;
                    } else if (this._messageId.lt(oId._messageId)) {
                        return -1;
                    }
                    return 0;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return `[Replication Group Message Id: ${this.toString()}]`;
                }
                toString() {
                    const idBuffer = BufferImpl.from(this._suid.toBytesBE().concat(this._messageId.toBytesBE()));
                    const hexString = idBuffer.toString("hex");
                    const sep = "-";
                    return `${RMID_VERSION_1_PREFIX}${hexString.substring(0, 5)}${sep}${hexString.substring(5, 16)}${sep}${hexString.substring(16, 24)}${sep}${hexString.substring(24, 32)}`;
                }
            }
            function createReplicationGroupMessageId(spec) {
                return new ReplicationGroupMessageId(spec.suid, spec.msgid);
            }
            function fromString(rgmidStr) {
                isString("id", rgmidStr);
                isValue("id", rgmidStr.length, RMID_LEN, ErrorSubcode.PARAMETER_OUT_OF_RANGE, `length expected: ${RMID_LEN} but is ${rgmidStr.length}`);
                if (!rgmidStr.startsWith(RMID_VERSION_1_PREFIX)) {
                    throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, does not start with ${RMID_VERSION_1_PREFIX}`);
                }
                const rmidBufs = rgmidStr.substring(RMID_VERSION_1_PREFIX.length).split("-");
                if (rmidBufs.length !== 4 || rmidBufs[0].length !== 5 || rmidBufs[1].length !== 11 || rmidBufs[2].length !== 8 || rmidBufs[3].length !== 8) {
                    throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, does not have valid separation of components`);
                }
                const rmidHex = rmidBufs.join("").trim();
                validRmidHexRegex.test("");
                if (!validRmidHexRegex.test(rmidHex)) {
                    throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, invalid data string value`);
                }
                let rmidBuffer;
                try {
                    rmidBuffer = BufferImpl.from(rmidHex, "hex");
                } catch (ex) {
                    throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, failed to read data, cause: ${ex.message}`);
                }
                const buflen = rmidBuffer ? rmidBuffer.length : 0;
                if (buflen !== 16) {
                    throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, failed to read data from id expected length of 16 got ${buflen}`);
                }
                const suid = Long.fromBits(rmidBuffer.readUInt32BE(4), rmidBuffer.readUInt32BE(0), true);
                if (suid.eq(INVALID_SUID)) {
                    throw new OperationError("Parameter id has invalid Replication Group Message ID format", ErrorSubcode.PARAMETER_OUT_OF_RANGE, `id: ${rgmidStr}, has invalid origin`);
                }
                const msgid = Long.fromBits(rmidBuffer.readUInt32BE(12), rmidBuffer.readUInt32BE(8), true);
                return createReplicationGroupMessageId({
                    suid: suid,
                    msgid: msgid
                });
            }
            const RgmidFactory = {};
            RgmidFactory.fromString = fromString;
            RgmidFactory.from = createReplicationGroupMessageId;
            RgmidFactory.INVALID_SUID = INVALID_SUID;
            module.exports.ReplicationGroupMessageId = ReplicationGroupMessageId;
            module.exports.RgmidFactory = RgmidFactory;
        },
        "./modules/solclient-queue/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                AbstractQueueDescriptor
            } = __webpack_require__("./modules/solclient-queue/lib/abstract-queue-descriptor.js");
            const {
                QueueAccessType
            } = __webpack_require__("./modules/solclient-queue/lib/queue-access-types.js");
            const {
                QueueDescriptor
            } = __webpack_require__("./modules/solclient-queue/lib/queue-descriptor.js");
            const {
                QueueDescriptorValidator
            } = __webpack_require__("./modules/solclient-queue/lib/queue-descriptor-validator.js");
            const {
                QueueDiscardBehavior
            } = __webpack_require__("./modules/solclient-queue/lib/queue-discard-behaviors.js");
            const {
                QueuePermissions
            } = __webpack_require__("./modules/solclient-queue/lib/queue-permissions.js");
            const {
                QueueProperties
            } = __webpack_require__("./modules/solclient-queue/lib/queue-properties.js");
            const {
                QueuePropertiesValidator
            } = __webpack_require__("./modules/solclient-queue/lib/queue-properties-validator.js");
            const {
                QueueType
            } = __webpack_require__("./modules/solclient-queue/lib/queue-types.js");
            module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
            module.exports.QueueAccessType = QueueAccessType;
            module.exports.QueueDescriptor = QueueDescriptor;
            module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
            module.exports.QueueDiscardBehavior = QueueDiscardBehavior;
            module.exports.QueuePermissions = QueuePermissions;
            module.exports.QueueProperties = QueueProperties;
            module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
            module.exports.QueueType = QueueType;
        },
        "./modules/solclient-queue/lib/abstract-queue-descriptor.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                OperationError,
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                QueueType
            } = __webpack_require__("./modules/solclient-queue/lib/queue-types.js");
            const DEFAULTS = {
                durable: true,
                type: undefined
            };
            const TYPE_DESCRIPTION = {
                [QueueType.QUEUE]: "queue",
                [QueueType.TOPIC_ENDPOINT]: "topic endpoint"
            };
            const DESINATION_TYPE_TO_DESCRIPTOR_TYPE = {
                [DestinationType.TOPIC]: null,
                [DestinationType.QUEUE]: QueueType.QUEUE,
                [DestinationType.TEMPORARY_QUEUE]: QueueType.QUEUE
            };
            function maybeAdaptFromDestination(spec) {
                if (spec && spec.name && spec.type && DestinationType.values.includes(spec.type)) {
                    const targetType = DESINATION_TYPE_TO_DESCRIPTOR_TYPE[spec.type];
                    if (!targetType) {
                        throw new OperationError(`Cannot create a descriptor from a ${DestinationType.describe(spec.type)} destination`, ErrorSubcode.PARAMETER_CONFLICT);
                    }
                    return {
                        name: spec.name,
                        type: QueueType.QUEUE,
                        durable: spec.type !== DestinationType.TEMPORARY_QUEUE
                    };
                }
                return spec;
            }
            class AbstractQueueDescriptor extends APIProperties {
                constructor(queueSpec) {
                    super(DEFAULTS, maybeAdaptFromDestination(queueSpec));
                }
                getType() {
                    return this._type;
                }
                get type() {
                    return this.getType();
                }
                set type(value) {
                    this._type = value;
                }
                isDurable() {
                    return this._durable;
                }
                get durable() {
                    return this.isDurable();
                }
                set durable(value) {
                    this._durable = value;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        type: this.type,
                        durable: this.durable
                    };
                }
                toString() {
                    return `${!this.isDurable() ? "non" : ""}-durable ` + `${TYPE_DESCRIPTION[this.getType()]}`;
                }
            }
            module.exports.AbstractQueueDescriptor = AbstractQueueDescriptor;
        },
        "./modules/solclient-queue/lib/queue-access-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const QueueAccessType = {
                EXCLUSIVE: "EXCLUSIVE",
                NONEXCLUSIVE: "NONEXCLUSIVE"
            };
            module.exports.QueueAccessType = Enum.new(QueueAccessType);
        },
        "./modules/solclient-queue/lib/queue-descriptor-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                APIPropertiesValidators
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                QueueDescriptor
            } = __webpack_require__("./modules/solclient-queue/lib/queue-descriptor.js");
            const {
                QueueType
            } = __webpack_require__("./modules/solclient-queue/lib/queue-types.js");
            const {
                validateInstance,
                valBoolean,
                valIsMember,
                valTopicString
            } = APIPropertiesValidators;
            const QueueDescriptorValidator = {
                validate(instance) {
                    const v = validateInstance.bind(null, "QueueDescriptor", instance);
                    if (instance instanceof QueueDescriptor) {
                        v("name", [ valTopicString ]);
                    }
                    v("type", [ valIsMember, QueueType, "QueueType" ]);
                    v("durable", [ valBoolean ]);
                }
            };
            module.exports.QueueDescriptorValidator = QueueDescriptorValidator;
        },
        "./modules/solclient-queue/lib/queue-descriptor.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                AbstractQueueDescriptor
            } = __webpack_require__("./modules/solclient-queue/lib/abstract-queue-descriptor.js");
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const DEFAULTS = {
                name: undefined,
                durable: true
            };
            class QueueDescriptor extends AbstractQueueDescriptor {
                constructor(queueSpec) {
                    super(queueSpec instanceof Destination ? {
                        name: queueSpec.name,
                        type: queueSpec.type
                    } : Object.assign({}, DEFAULTS, queueSpec));
                }
                getName() {
                    return this._name;
                }
                get name() {
                    return this.getName();
                }
                set name(value) {
                    this._name = value;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        name: this.name,
                        type: this.type,
                        durable: this.durable
                    };
                }
                toString() {
                    return `${super.toString()} '${this.getName()}'`;
                }
                static createFromSpec(spec) {
                    if (spec.name) return new QueueDescriptor(spec);
                    return AbstractQueueDescriptor(spec);
                }
            }
            module.exports.QueueDescriptor = QueueDescriptor;
        },
        "./modules/solclient-queue/lib/queue-discard-behaviors.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const QueueDiscardBehavior = {
                NOTIFY_SENDER_ON: "NOTIFY_SENDER_ON",
                NOTIFY_SENDER_OFF: "NOTIFY_SENDER_OFF"
            };
            module.exports.QueueDiscardBehavior = Enum.new(QueueDiscardBehavior);
        },
        "./modules/solclient-queue/lib/queue-permissions.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const QueuePermissions = {
                NONE: "NONE",
                READ_ONLY: "READ_ONLY",
                CONSUME: "CONSUME",
                MODIFY_TOPIC: "MODIFY_TOPIC",
                DELETE: "DELETE"
            };
            module.exports.QueuePermissions = Enum.new(QueuePermissions);
        },
        "./modules/solclient-queue/lib/queue-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                APIPropertiesValidators
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                QueueAccessType
            } = __webpack_require__("./modules/solclient-queue/lib/queue-access-types.js");
            const {
                QueueDiscardBehavior
            } = __webpack_require__("./modules/solclient-queue/lib/queue-discard-behaviors.js");
            const {
                QueuePermissions
            } = __webpack_require__("./modules/solclient-queue/lib/queue-permissions.js");
            const {
                validateInstance,
                valBoolean,
                valIsMember,
                valNumber,
                valRange
            } = APIPropertiesValidators;
            const QueuePropertiesValidator = {
                validate(instance) {
                    const v = validateInstance.bind(null, "QueueProperties", instance);
                    if (instance.permissions !== undefined && instance.permissions !== null) {
                        v("permissions", [ valIsMember, QueuePermissions, "QueuePermissions" ]);
                    }
                    if (instance.accessType !== undefined && instance.accessType !== null) {
                        v("accessType", [ valIsMember, QueueAccessType, "QueueAccessType" ]);
                    }
                    if (instance.quotaMB !== undefined && instance.quotaMB !== null) {
                        v("quotaMB", [ valNumber ], [ valRange, 0, Number.POSITIVE_INFINITY ]);
                    }
                    if (instance.maxMessageSize !== undefined && instance.maxMessageSize !== null) {
                        v("maxMessageSize", [ valNumber ], [ valRange, 0, Number.POSITIVE_INFINITY ]);
                    }
                    if (instance.respectsTTL !== undefined && instance.respectsTTL !== null) {
                        v("respectsTTL", [ valBoolean ]);
                    }
                    if (instance.discardBehavior !== undefined && instance.discardBehavior !== null) {
                        v("discardBehavior", [ valIsMember, QueueDiscardBehavior, "QueueDiscardBehavior" ]);
                    }
                    if (instance.maxMessageRedelivery !== undefined && instance.maxMessageRedelivery !== null) {
                        v("maxMessageRedelivery", [ valNumber ], [ valRange, 0, 255 ]);
                    }
                }
            };
            module.exports.QueuePropertiesValidator = QueuePropertiesValidator;
        },
        "./modules/solclient-queue/lib/queue-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                QueueAccessType
            } = __webpack_require__("./modules/solclient-queue/lib/queue-access-types.js");
            const {
                QueueDiscardBehavior
            } = __webpack_require__("./modules/solclient-queue/lib/queue-discard-behaviors.js");
            const {
                QueuePermissions
            } = __webpack_require__("./modules/solclient-queue/lib/queue-permissions.js");
            const DEFAULTS = {
                permissions: undefined,
                accessType: undefined,
                quotaMB: undefined,
                maxMessageSize: undefined,
                respectsTTL: undefined,
                discardBehavior: undefined,
                maxMessageRedelivery: undefined
            };
            class QueueProperties extends APIProperties {
                constructor(options) {
                    super(DEFAULTS, options);
                }
                get permissions() {
                    return this._permissions;
                }
                set permissions(newValue) {
                    this._permissions = newValue;
                }
                get accessType() {
                    return this._accessType || DEFAULTS.accessType;
                }
                set accessType(newValue) {
                    this._accessType = newValue;
                }
                get quotaMB() {
                    return this._quotaMB;
                }
                set quotaMB(newValue) {
                    this._quotaMB = newValue;
                }
                get maxMessageSize() {
                    return this._maxMessageSize;
                }
                set maxMessageSize(newValue) {
                    this._maxMessageSize = newValue;
                }
                get respectsTTL() {
                    return this._respectsTTL;
                }
                set respectsTTL(newValue) {
                    this._respectsTTL = newValue;
                }
                get discardBehavior() {
                    return this._discardBehavior;
                }
                set discardBehavior(newValue) {
                    this._discardBehavior = newValue;
                }
                get maxMessageRedelivery() {
                    return this._maxMessageRedelivery;
                }
                set maxMessageRedelivery(newValue) {
                    this._maxMessageRedelivery = newValue;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        permissions: QueuePermissions.describe(this.permissions),
                        accessType: QueueAccessType.describe(this.accessType),
                        quotaMB: this.quotaMB,
                        maxMessageSize: this.maxMessageSize,
                        respectsTTL: this.respectsTTL,
                        discardBehavior: this.discardBehavior ? QueueDiscardBehavior.describe(this.discardBehavior) : "undefined",
                        maxMessageRedelivery: this.maxMessageRedelivery
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.QueueProperties = QueueProperties;
        },
        "./modules/solclient-queue/lib/queue-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const QueueType = {
                QUEUE: "QUEUE",
                TOPIC_ENDPOINT: "TOPIC_ENDPOINT"
            };
            module.exports.QueueType = Enum.new(QueueType);
        },
        "./modules/solclient-replaystart/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ReplayStartLocation,
                ReplayStartType
            } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocation.js");
            const {
                ReplayStartLocationBeginning
            } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocationBeginning.js");
            const {
                ReplayStartLocationDate
            } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocationDate.js");
            const {
                SolclientFactory
            } = __webpack_require__("./modules/solclient-factory/api.js");
            module.exports.ReplayStartLocation = ReplayStartLocation;
            module.exports.ReplayStartLocationBeginning = ReplayStartLocationBeginning;
            module.exports.ReplayStartLocationDate = ReplayStartLocationDate;
            module.exports.ReplayStartType = ReplayStartType;
            SolclientFactory.createReplayStartLocationBeginning = SolclientFactory.createFactory(() => new ReplayStartLocationBeginning());
            SolclientFactory.createReplayStartLocationDate = SolclientFactory.createFactory(dateTime => ReplayStartLocationDate.createReplayStartLocationDate(Parameter.isInstanceOf("date", dateTime, Date)));
        },
        "./modules/solclient-replaystart/lib/replayStartLocation.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const ReplayStartType = Enum.new({
                BEGINNING: 0,
                DATE: 1,
                RGMID: 2
            });
            class ReplayStartLocation {
                constructor(spec) {
                    Object.assign(this, spec);
                    if (this._type === undefined) {
                        this._type = ReplayStartType.BEGINNING;
                    }
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.ReplayStartLocation = ReplayStartLocation;
            module.exports.ReplayStartType = ReplayStartType;
        },
        "./modules/solclient-replaystart/lib/replayStartLocationBeginning.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ReplayStartLocation,
                ReplayStartType
            } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocation.js");
            class ReplayStartLocationBeginning extends ReplayStartLocation {
                constructor() {
                    super({
                        _type: ReplayStartType.BEGINNING
                    });
                }
                static [Symbol.for("nodejs.util.inspect.custom")]() {
                    return "BEGINNING";
                }
            }
            module.exports.ReplayStartLocationBeginning = ReplayStartLocationBeginning;
        },
        "./modules/solclient-replaystart/lib/replayStartLocationDate.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ReplayStartLocation,
                ReplayStartType
            } = __webpack_require__("./modules/solclient-replaystart/lib/replayStartLocation.js");
            class ReplayStartLocationDate extends ReplayStartLocation {
                constructor(spec) {
                    super({
                        _replayStartValue: spec.getTime(),
                        _type: ReplayStartType.DATE
                    });
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return `[Epoch Time: ${this._replayStartValue}]`;
                }
                static createReplayStartLocationDate(dateTime) {
                    return new ReplayStartLocationDate(dateTime);
                }
            }
            module.exports.ReplayStartLocationDate = ReplayStartLocationDate;
        },
        "./modules/solclient-sdt/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Codec
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/api.js");
            const {
                SDTDestType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-destination-types.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                SDTMapContainer
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js");
            const {
                SDTStreamContainer
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js");
            const {
                SDTUnsupportedValueError
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-unsupported-value-error.js");
            const {
                SDTValueErrorSubcode
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-value-error-subcodes.js");
            module.exports.Codec = Codec;
            module.exports.SDTDestType = SDTDestType;
            module.exports.SDTField = SDTField;
            module.exports.SDTFieldType = SDTFieldType;
            module.exports.SDTMapContainer = SDTMapContainer;
            module.exports.SDTStreamContainer = SDTStreamContainer;
            module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
            module.exports.SDTValueErrorSubcode = SDTValueErrorSubcode;
        },
        "./modules/solclient-sdt/lib/codec/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                EncodeSingleElement
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-single-element.js");
            const {
                IEEE754LIB
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/ieee754lib.js");
            const {
                ParseSingleElement,
                StringToBuffer
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-single-element.js");
            const {
                encodeSingleElement
            } = EncodeSingleElement;
            const {
                parseSingleElement
            } = ParseSingleElement;
            const {
                stringToBuffer
            } = StringToBuffer;
            const Codec = {
                encodeSingleElement: encodeSingleElement,
                parseSingleElement: parseSingleElement,
                stringToBuffer: stringToBuffer,
                IEEE754LIB: IEEE754LIB
            };
            module.exports.Codec = Codec;
        },
        "./modules/solclient-sdt/lib/codec/encode-header.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                SDTDataTypes
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js");
            const EncodeHeader = {};
            EncodeHeader.encodeHeader = function encodeHeader(tag, valueLen) {
                let byte0 = tag << 2 & 255;
                let strSdtLen = null;
                if (tag === SDTDataTypes.Map || tag === SDTDataTypes.Stream) {
                    strSdtLen = Convert.int32ToStr(valueLen + 5);
                    byte0 |= 3;
                } else if (valueLen + 2 <= 255) {
                    strSdtLen = Convert.int8ToStr(valueLen + 2);
                    byte0 |= 0;
                } else if (valueLen + 3 <= 65535) {
                    strSdtLen = Convert.int16ToStr(valueLen + 3);
                    byte0 |= 1;
                } else {
                    strSdtLen = Convert.int32ToStr(valueLen + 5);
                    byte0 |= 3;
                }
                const ret = Convert.int8ToStr(byte0) + strSdtLen;
                return ret;
            };
            module.exports.EncodeHeader = EncodeHeader;
        },
        "./modules/solclient-sdt/lib/codec/encode-integer.js": module => {
            const EncodeInteger = {};
            EncodeInteger.int48ToStr = function int48ToStr(vIn) {
                let v = vIn;
                const bytes = [];
                for (let i = 0; i < 6; i++) {
                    const byteI = v % 256;
                    v = Math.floor(v / 256);
                    bytes.push(String.fromCharCode(byteI));
                }
                bytes.reverse();
                return bytes.join("");
            };
            module.exports.EncodeInteger = EncodeInteger;
        },
        "./modules/solclient-sdt/lib/codec/encode-map.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const EncodeSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-single-element.js");
            const UtilLib = __webpack_require__("./modules/solclient-util/api.js");
            const {
                EncodeHeader
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-header.js");
            const {
                SDTDataTypes
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js");
            const {
                SDTMapContainer
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js");
            const {
                encodeHeader
            } = EncodeHeader;
            const EncodeMap = {
                encodeMap(sdtmap) {
                    const buf = [];
                    if (!(sdtmap instanceof SDTMapContainer)) {
                        return null;
                    }
                    const keys = sdtmap.getKeys();
                    let sdtfield = null;
                    let strKeyField = null;
                    let strKeyName = null;
                    let i;
                    for (i = 0; i < keys.length; i++) {
                        sdtfield = sdtmap.getField(keys[i]);
                        if (sdtfield) {
                            strKeyName = UtilLib.StringUtils.nullTerminate(keys[i]);
                            strKeyField = encodeHeader(SDTDataTypes.String, strKeyName.length);
                            strKeyField += strKeyName;
                            buf.push(strKeyField);
                            EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
                        }
                    }
                    return buf.join("");
                }
            };
            module.exports.EncodeMap = EncodeMap;
        },
        "./modules/solclient-sdt/lib/codec/encode-single-element.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                EncodeHeader
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-header.js");
            const {
                EncodeInteger
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-integer.js");
            const {
                EncodeMap
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-map.js");
            const {
                EncodeStream
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-stream.js");
            const {
                IEEE754LIB
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/ieee754lib.js");
            const {
                SDTDataTypes
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js");
            const {
                SDTDestType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-destination-types.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                encodeHeader
            } = EncodeHeader;
            const {
                int48ToStr
            } = EncodeInteger;
            const {
                encodeMap
            } = EncodeMap;
            const {
                encodeStream
            } = EncodeStream;
            const {
                nullTerminate
            } = StringUtils;
            const C_2_48 = Math.pow(2, 48);
            function strencode(data) {
                return unescape(encodeURIComponent(data));
            }
            function encodeSingleElementToBuf(sdtfield, buf) {
                if (!(sdtfield instanceof SDTField)) {
                    return false;
                }
                const value = sdtfield.getValue();
                let fieldVal = null;
                let tag = 0;
                switch (sdtfield.getType()) {
                  case SDTFieldType.BOOL:
                    tag = SDTDataTypes.Boolean;
                    fieldVal = Convert.int8ToStr(value ? 1 : 0);
                    break;

                  case SDTFieldType.UINT8:
                    tag = SDTDataTypes.UnsignedInteger;
                    fieldVal = Convert.int8ToStr(value);
                    break;

                  case SDTFieldType.INT8:
                    tag = SDTDataTypes.Integer;
                    fieldVal = Convert.int8ToStr(value);
                    break;

                  case SDTFieldType.UINT16:
                    tag = SDTDataTypes.UnsignedInteger;
                    fieldVal = Convert.int16ToStr(value);
                    break;

                  case SDTFieldType.INT16:
                    tag = SDTDataTypes.Integer;
                    fieldVal = Convert.int16ToStr(value);
                    break;

                  case SDTFieldType.UINT32:
                    tag = SDTDataTypes.UnsignedInteger;
                    fieldVal = Convert.int32ToStr(value);
                    break;

                  case SDTFieldType.INT32:
                    tag = SDTDataTypes.Integer;
                    fieldVal = Convert.int32ToStr(value);
                    break;

                  case SDTFieldType.UINT64:
                    tag = SDTDataTypes.UnsignedInteger;
                    fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
                    break;

                  case SDTFieldType.INT64:
                    tag = SDTDataTypes.Integer;
                    if (value >= 0) {
                        fieldVal = String.fromCharCode(0) + String.fromCharCode(0) + int48ToStr(value);
                    } else {
                        fieldVal = String.fromCharCode(255) + String.fromCharCode(255) + int48ToStr(C_2_48 + value);
                    }
                    break;

                  case SDTFieldType.WCHAR:
                    tag = SDTDataTypes.Char;
                    fieldVal = Convert.int16ToStr(value.charCodeAt(0));
                    break;

                  case SDTFieldType.STRING:
                    tag = SDTDataTypes.String;
                    fieldVal = nullTerminate(strencode(value));
                    break;

                  case SDTFieldType.BYTEARRAY:
                    tag = SDTDataTypes.ByteArray;
                    fieldVal = value.toString("latin1");
                    break;

                  case SDTFieldType.FLOATTYPE:
                    tag = SDTDataTypes.Float;
                    fieldVal = IEEE754LIB.toIEEE754Single(value);
                    break;

                  case SDTFieldType.DOUBLETYPE:
                    tag = SDTDataTypes.Float;
                    fieldVal = IEEE754LIB.toIEEE754Double(value);
                    break;

                  case SDTFieldType.MAP:
                    tag = SDTDataTypes.Map;
                    fieldVal = encodeMap(value);
                    break;

                  case SDTFieldType.STREAM:
                    tag = SDTDataTypes.Stream;
                    fieldVal = encodeStream(value);
                    break;

                  case SDTFieldType.DESTINATION:
                    tag = SDTDataTypes.Destination;
                    if (value instanceof DestinationLib.Destination) {
                        fieldVal = Convert.int8ToStr(SDTDestType[value.getType()]) + value.getBytes();
                    }
                    break;

                  case SDTFieldType.NULLTYPE:
                    tag = SDTDataTypes.Null;
                    fieldVal = "";
                    break;

                  case SDTFieldType.UNKNOWN:
                    fieldVal = null;
                    break;

                  default:
                }
                if (fieldVal !== null) {
                    const hdr = encodeHeader(tag, fieldVal.length);
                    buf.push(hdr);
                    buf.push(fieldVal);
                    return true;
                }
                return false;
            }
            function encodeSingleElement(sdtfield) {
                const buf = [];
                encodeSingleElementToBuf(sdtfield, buf);
                return buf.join("");
            }
            const EncodeSingleElement = {
                encodeSingleElement: encodeSingleElement,
                encodeSingleElementToBuf: encodeSingleElementToBuf
            };
            module.exports.EncodeSingleElement = EncodeSingleElement;
        },
        "./modules/solclient-sdt/lib/codec/encode-stream.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const EncodeSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/encode-single-element.js");
            const {
                SDTStreamContainer
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js");
            const EncodeStream = {};
            EncodeStream.encodeStream = function encodeStream(sdtstream) {
                const buf = [];
                if (!(sdtstream instanceof SDTStreamContainer)) {
                    return null;
                }
                let sdtfield = null;
                while (sdtstream.hasNext()) {
                    sdtfield = sdtstream.getNext();
                    if (sdtfield) {
                        EncodeSingleElementLib.EncodeSingleElement.encodeSingleElementToBuf(sdtfield, buf);
                    }
                }
                return buf.join("");
            };
            module.exports.EncodeStream = EncodeStream;
        },
        "./modules/solclient-sdt/lib/codec/ieee754lib.js": module => {
            const IEEE754LIB = {
                toIEEE754(vIn, ebits, fbits) {
                    let v = vIn;
                    const bias = (1 << ebits - 1) - 1;
                    let s;
                    let e;
                    let f;
                    if (isNaN(v)) {
                        e = (1 << bias) - 1;
                        f = 1;
                        s = 0;
                    } else if (v === Infinity || v === -Infinity) {
                        e = (1 << bias) - 1;
                        f = 0;
                        s = v < 0 ? 1 : 0;
                    } else if (v === 0) {
                        e = 0;
                        f = 0;
                        s = 1 / v === -Infinity ? 1 : 0;
                    } else {
                        s = v < 0;
                        v = Math.abs(v);
                        if (v >= Math.pow(2, 1 - bias)) {
                            const ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
                            e = ln + bias;
                            f = v * Math.pow(2, fbits - ln) - Math.pow(2, fbits);
                        } else {
                            e = 0;
                            f = v / Math.pow(2, 1 - bias - fbits);
                        }
                    }
                    const bits = [];
                    for (let i = fbits; i; i -= 1) {
                        bits.push(f % 2 ? 1 : 0);
                        f = Math.floor(f / 2);
                    }
                    for (let i = ebits; i; i -= 1) {
                        bits.push(e % 2 ? 1 : 0);
                        e = Math.floor(e / 2);
                    }
                    bits.push(s ? 1 : 0);
                    bits.reverse();
                    let str = bits.join("");
                    const bytes = [];
                    while (str.length) {
                        bytes.push(parseInt(str.substring(0, 8), 2));
                        str = str.substring(8);
                    }
                    return bytes;
                },
                fromIEEE754(bytes, ebits, fbits) {
                    const bits = [];
                    for (let i = bytes.length; i; i -= 1) {
                        let byteI = bytes[i - 1];
                        for (let j = 8; j; j -= 1) {
                            bits.push(byteI % 2 ? 1 : 0);
                            byteI >>= 1;
                        }
                    }
                    bits.reverse();
                    const str = bits.join("");
                    const bias = (1 << ebits - 1) - 1;
                    const s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
                    const e = parseInt(str.substring(1, 1 + ebits), 2);
                    const f = parseInt(str.substring(1 + ebits), 2);
                    if (e === (1 << ebits) - 1) {
                        return f !== 0 ? NaN : s * Infinity;
                    }
                    if (e > 0) {
                        return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
                    }
                    if (f !== 0) {
                        return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
                    }
                    return 0;
                },
                strToByteArr(str) {
                    const bytes = [];
                    for (let i = 0; i < str.length; i++) {
                        bytes.push(str.charCodeAt(i) & 255);
                    }
                    return bytes;
                },
                byteArrToStr(bytes) {
                    const str = [];
                    for (let i = 0; i < bytes.length; i++) {
                        str.push(String.fromCharCode(bytes[i] & 255));
                    }
                    return str.join("");
                },
                fromIEEE754Double(b) {
                    return this.fromIEEE754(this.strToByteArr(b), 11, 52);
                },
                toIEEE754Double(v) {
                    return this.byteArrToStr(this.toIEEE754(v, 11, 52));
                },
                fromIEEE754Single(b) {
                    return this.fromIEEE754(this.strToByteArr(b), 8, 23);
                },
                toIEEE754Single(v) {
                    return this.byteArrToStr(this.toIEEE754(v, 8, 23));
                }
            };
            module.exports.IEEE754LIB = IEEE754LIB;
        },
        "./modules/solclient-sdt/lib/codec/parse-destination.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                DestinationFromNetwork,
                DestinationType,
                Queue
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                LOG_DEBUG,
                LOG_INFO
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SDTDestType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-destination-types.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                Topic
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const ParseDestination = {};
            ParseDestination.parseDestination = function parseDestination(dataBuf, pos, len) {
                const destType = dataBuf.readUInt8(pos);
                const destBytes = dataBuf.toString("latin1", pos + 1, pos + len);
                let destination = DestinationFromNetwork.createDestinationFromBytes(destBytes);
                if (SDTDestType[destination.type] !== destType) {
                    if (SDTDestType[DestinationType.QUEUE] === destType) {
                        destination = Queue.createFromLocalName(destBytes);
                    } else if (SDTDestType[DestinationType.TOPIC] === destType) {
                        LOG_DEBUG(`Found and allowed SDT field with  destination type ${destType} when decoding ${destBytes} to ${destination.type}`);
                        destination = new Topic(destBytes);
                    } else {
                        LOG_INFO(`Drop SDT field with invalid destination type ${destType} when decoding ${destBytes} to ${destination.type}`);
                        return null;
                    }
                }
                return SDTField.create(SDTFieldType.DESTINATION, destination);
            };
            module.exports.ParseDestination = ParseDestination;
        },
        "./modules/solclient-sdt/lib/codec/parse-field-header.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ParseInteger
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-integer.js");
            const {
                autoDecodeVarLengthNumber
            } = ParseInteger;
            const ParseFieldHeader = {};
            ParseFieldHeader.parseFieldHeader = function parseFieldHeader(dataBuf, offset) {
                let pos = offset;
                const onebyte = dataBuf.readUInt8(pos);
                const elemType = (onebyte & 252) >> 2;
                const lenBytes = (onebyte & 3) + 1;
                pos++;
                const elemLen = autoDecodeVarLengthNumber(dataBuf, pos, lenBytes);
                pos += lenBytes;
                const elemValLen = elemLen - (1 + lenBytes);
                return [ elemType, elemLen, elemValLen, pos - offset ];
            };
            module.exports.ParseFieldHeader = ParseFieldHeader;
        },
        "./modules/solclient-sdt/lib/codec/parse-float.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const ParseFloat = {};
            ParseFloat.parseFloatField = function parseFloatField(buf, pos, len) {
                switch (len) {
                  case 4:
                    return SDTField.create(SDTFieldType.FLOATTYPE, buf.readFloatBE(pos));

                  case 8:
                    return SDTField.create(SDTFieldType.DOUBLETYPE, buf.readDoubleBE(pos));

                  default:
                    return SDTField.create(SDTFieldType.UNKNOWN, buf.toString("latin1", pos, pos + len));
                }
            };
            module.exports.ParseFloat = ParseFloat;
        },
        "./modules/solclient-sdt/lib/codec/parse-integer.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const Long = __webpack_require__("./node_modules/long/umd/index.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                SDTUnsupportedValueError
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-unsupported-value-error.js");
            const {
                SDTValueErrorSubcode
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-value-error-subcodes.js");
            const {
                create: createField
            } = SDTField;
            const ParseInteger = {};
            ParseInteger.autoDecodeVarLengthNumber = function autoDecodeVarLengthNumber(dataBuf, pos, len) {
                if ([ 1, 2, 3, 4 ].includes(len)) {
                    return dataBuf.readUIntBE(pos, len);
                }
                return false;
            };
            ParseInteger.parseIntegerField = function parseIntegerField(isSigned, dataBuf, pos, len) {
                let val = 0;
                switch (len) {
                  case 1:
                    if (isSigned) {
                        val = dataBuf.readInt8(pos);
                        return createField(SDTFieldType.INT8, val);
                    }
                    val = dataBuf.readUInt8(pos);
                    return createField(SDTFieldType.UINT8, val);

                  case 2:
                    if (isSigned) {
                        val = dataBuf.readInt16BE(pos);
                        return createField(SDTFieldType.INT16, val);
                    }
                    val = dataBuf.readUInt16BE(pos);
                    return createField(SDTFieldType.UINT16, val);

                  case 4:
                    if (isSigned) {
                        val = dataBuf.readInt32BE(pos);
                        return createField(SDTFieldType.INT32, val);
                    }
                    val = dataBuf.readUInt32BE(pos);
                    return createField(SDTFieldType.UINT32, val);

                  case 8:
                    {
                        let error = null;
                        const longValue = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), !isSigned);
                        if (longValue.getNumBitsAbs() > 48) {
                            error = new SDTUnsupportedValueError("Value is not supported", SDTValueErrorSubcode.VALUE_OUTSIDE_SUPPORTED_RANGE, dataBuf.toString("latin1", pos, len));
                        }
                        val = longValue.toNumber();
                        const field = createField(isSigned ? SDTFieldType.INT64 : SDTFieldType.UINT64, val);
                        if (error) {
                            field.setError(error);
                        }
                        return field;
                    }

                  default:
                    return null;
                }
            };
            module.exports.ParseInteger = ParseInteger;
        },
        "./modules/solclient-sdt/lib/codec/parse-map.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const ParseSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-single-element.js");
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                ParseFieldHeader
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-field-header.js");
            const {
                SDTDataTypes
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                SDTMapContainer
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js");
            const ParseMap = {};
            ParseMap.parseMapAt = function parseMapAt(dataBuf, offset, datalen) {
                const mapObj = new SDTMapContainer();
                let pos = offset;
                while (pos < offset + datalen) {
                    const keyFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                    pos += keyFieldHeader[3];
                    if (keyFieldHeader[0] !== SDTDataTypes.String) {
                        LOG_ERROR("Error parsing SDTMAP, expected to find a string field as map key, and didn't");
                        LOG_ERROR(`Type of key: ${keyFieldHeader[0]}`);
                        return SDTField.create(SDTFieldType.MAP, null);
                    }
                    const keyString = dataBuf.toString("latin1", pos, pos + keyFieldHeader[2] - 1);
                    pos += keyFieldHeader[2];
                    const valueFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                    const valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(dataBuf, pos);
                    pos += valueFieldHeader[1];
                    if (valueField) {
                        mapObj.addField(keyString, valueField);
                    }
                }
                return SDTField.create(SDTFieldType.MAP, mapObj);
            };
            module.exports.ParseMap = ParseMap;
        },
        "./modules/solclient-sdt/lib/codec/parse-single-element.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_DEBUG
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                ParseDestination
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-destination.js");
            const {
                ParseFieldHeader
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-field-header.js");
            const {
                ParseFloat
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-float.js");
            const {
                ParseInteger
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-integer.js");
            const {
                ParseMap
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-map.js");
            const {
                ParseStream
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-stream.js");
            const {
                SDTDataTypes
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-data-types.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                utf8ToUcs2
            } = Convert;
            const {
                parseFieldHeader
            } = ParseFieldHeader;
            const {
                parseFloatField
            } = ParseFloat;
            const {
                parseIntegerField
            } = ParseInteger;
            const {
                parseMapAt
            } = ParseMap;
            const {
                parseStreamAt
            } = ParseStream;
            const {
                parseDestination
            } = ParseDestination;
            const ParseSingleElement = {
                parseSingleElement(dataBuf, offset) {
                    const fieldHeader = parseFieldHeader(dataBuf, offset);
                    if (!fieldHeader) {
                        LOG_DEBUG(`parseSingleElement return false, fieldHeader=${fieldHeader}`);
                        return null;
                    }
                    const pos = offset + fieldHeader[3];
                    const elemValLen = fieldHeader[2];
                    switch (fieldHeader[0]) {
                      case SDTDataTypes.Null:
                        return SDTField.create(SDTFieldType.NULLTYPE, null);

                      case SDTDataTypes.Boolean:
                        return SDTField.create(SDTFieldType.BOOL, dataBuf.readUInt8(pos) !== 0);

                      case SDTDataTypes.Integer:
                        return parseIntegerField(true, dataBuf, pos, elemValLen);

                      case SDTDataTypes.UnsignedInteger:
                        return parseIntegerField(false, dataBuf, pos, elemValLen);

                      case SDTDataTypes.Float:
                        return parseFloatField(dataBuf, pos, elemValLen);

                      case SDTDataTypes.Char:
                        return SDTField.create(SDTFieldType.WCHAR, String.fromCharCode(dataBuf.readUInt16BE(pos)));

                      case SDTDataTypes.ByteArray:
                        return SDTField.create(SDTFieldType.BYTEARRAY, dataBuf.slice(pos, pos + elemValLen));

                      case SDTDataTypes.String:
                        return SDTField.create(SDTFieldType.STRING, utf8ToUcs2(dataBuf.toString("latin1", pos, pos + elemValLen - 1)));

                      case SDTDataTypes.Destination:
                        return parseDestination(dataBuf, pos, elemValLen);

                      case SDTDataTypes.SMFMessage:
                        return SDTField.create(SDTFieldType.SMF_MESSAGE, dataBuf.slice(pos, pos + elemValLen));

                      case SDTDataTypes.Map:
                        return parseMapAt(dataBuf, pos, elemValLen);

                      case SDTDataTypes.Stream:
                        return parseStreamAt(dataBuf, pos, elemValLen);

                      default:
                        return SDTField.create(SDTFieldType.UNKNOWN, dataBuf.toString("latin1", pos, pos + elemValLen));
                    }
                }
            };
            const StringToBuffer = {
                stringToBuffer(str) {
                    const BufferImpl = __webpack_require__("buffer").Buffer;
                    return BufferImpl.from(str, "latin1");
                }
            };
            module.exports.ParseSingleElement = ParseSingleElement;
            module.exports.StringToBuffer = StringToBuffer;
        },
        "./modules/solclient-sdt/lib/codec/parse-stream.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const ParseSingleElementLib = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-single-element.js");
            const {
                ParseFieldHeader
            } = __webpack_require__("./modules/solclient-sdt/lib/codec/parse-field-header.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                SDTStreamContainer
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js");
            const ParseStream = {};
            ParseStream.parseStreamAt = function parseStreamAt(dataBuf, offset, datalen) {
                const streamObj = new SDTStreamContainer();
                let pos = offset;
                while (pos < offset + datalen) {
                    const valueFieldHeader = ParseFieldHeader.parseFieldHeader(dataBuf, pos);
                    const valueField = ParseSingleElementLib.ParseSingleElement.parseSingleElement(dataBuf, pos);
                    pos += valueFieldHeader[1];
                    if (valueField) {
                        streamObj.addField(valueField);
                    }
                }
                return SDTField.create(SDTFieldType.STREAM, streamObj);
            };
            module.exports.ParseStream = ParseStream;
        },
        "./modules/solclient-sdt/lib/sdt-data-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SDTDataTypes = {
                Null: 0,
                Boolean: 1,
                Integer: 2,
                UnsignedInteger: 3,
                Float: 4,
                Char: 5,
                ByteArray: 6,
                String: 7,
                Destination: 8,
                SMFMessage: 9,
                Map: 10,
                Stream: 11
            };
            module.exports.SDTDataTypes = Enum.new(SDTDataTypes);
        },
        "./modules/solclient-sdt/lib/sdt-destination-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SDTDestType = {
                [DestinationType.TOPIC]: 0,
                [DestinationType.QUEUE]: 1,
                [DestinationType.TEMPORARY_QUEUE]: 1
            };
            module.exports.SDTDestType = Enum.new(SDTDestType);
        },
        "./modules/solclient-sdt/lib/sdt-field-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SDTFieldType = {
                BOOL: 0,
                UINT8: 1,
                INT8: 2,
                UINT16: 3,
                INT16: 4,
                UINT32: 5,
                INT32: 6,
                UINT64: 7,
                INT64: 8,
                WCHAR: 9,
                STRING: 10,
                BYTEARRAY: 11,
                FLOATTYPE: 12,
                DOUBLETYPE: 13,
                MAP: 14,
                STREAM: 15,
                DESTINATION: 16,
                NULLTYPE: 17,
                UNKNOWN: 18,
                SMF_MESSAGE: 19
            };
            module.exports.SDTFieldType = Enum.new(SDTFieldType);
        },
        "./modules/solclient-sdt/lib/sdt-field.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const {
                validateSdtField
            } = __webpack_require__("./modules/solclient-sdt/lib/validate-sdt-field.js");
            const {
                anythingToBuffer
            } = Convert;
            const {
                ProfileBinding
            } = SolclientFactoryLib;
            class SDTField {
                constructor(type = SDTFieldType.NULLTYPE, value = null) {
                    const err = validateSdtField(type, value);
                    if (err !== null) {
                        throw err;
                    }
                    this._type = type;
                    if (type === SDTFieldType.BYTEARRAY) {
                        this._value = anythingToBuffer(value);
                    } else {
                        this._value = value;
                    }
                    this._error = undefined;
                }
                getType() {
                    return this._type;
                }
                getValue() {
                    if (this._error !== undefined) {
                        throw this._error;
                    }
                    return this.getValueNoThrow();
                }
                getValueNoThrow() {
                    if (this._error !== undefined) {
                        return this._error;
                    }
                    if (this._type === SDTFieldType.BYTEARRAY && ProfileBinding.value.byteArrayAsString) {
                        return this._value.toString("latin1");
                    }
                    return this._value;
                }
                setError(err) {
                    this._error = err;
                }
                toString() {
                    return `[SDTField type:${this._type} value:${this._value}]`;
                }
                static create(type, value) {
                    return new SDTField(type, value);
                }
            }
            module.exports.SDTField = SDTField;
        },
        "./modules/solclient-sdt/lib/sdt-map-container.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                SDTField
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            class SDTMapContainer {
                constructor() {
                    this._map = [];
                }
                getKeys() {
                    return Object.keys(this._map);
                }
                getField(key) {
                    return this._map[key];
                }
                deleteField(key) {
                    delete this._map[key];
                }
                addField(key, typeOrField, value = undefined) {
                    if (typeOrField instanceof SDTField) {
                        this._map[key] = typeOrField;
                        return;
                    } else if (typeof value !== "undefined") {
                        this._map[key] = SDTField.create(typeOrField, value);
                        return;
                    }
                    throw new OperationError("Invalid parameters to addField: expected SDTField, or type and value", ErrorSubcode.PARAMETER_CONFLICT);
                }
            }
            module.exports.SDTMapContainer = SDTMapContainer;
        },
        "./modules/solclient-sdt/lib/sdt-stream-container.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SDTFieldLib = __webpack_require__("./modules/solclient-sdt/lib/sdt-field.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            class SDTStreamContainer {
                constructor() {
                    this._stream = [];
                    this._writable = true;
                    this._readPt = 0;
                }
                hasNext() {
                    return this._stream.length > this._readPt;
                }
                getNext() {
                    return this._readPt < this._stream.length ? this._stream[this._readPt++] : undefined;
                }
                rewind() {
                    this._readPt = 0;
                }
                addField(typeOrField, value = undefined) {
                    if (!this._writable) return;
                    if (typeOrField instanceof SDTFieldLib.SDTField) {
                        this._stream.push(typeOrField);
                        return;
                    }
                    if (typeof value !== "undefined") {
                        this._stream.push(SDTFieldLib.SDTField.create(typeOrField, value));
                        return;
                    }
                    throw new OperationError("Invalid parameters to addField: expected SDTField, or type and value", ErrorSubcode.PARAMETER_CONFLICT);
                }
            }
            module.exports.SDTStreamContainer = SDTStreamContainer;
        },
        "./modules/solclient-sdt/lib/sdt-unsupported-value-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const {
                SolaceError
            } = __webpack_require__("./modules/solclient-error/api.js");
            class SDTUnsupportedValueError extends SolaceError {
                constructor(message, subcode, sourceData) {
                    super("SDTUnsupportedValue", message);
                    this.subcode = subcode;
                    this.sourceData = sourceData || "";
                }
                inspect() {
                    return super.inspect({
                        subcode: null,
                        sourceData: v => DebugLib.Debug.formatDumpBytes(v, false, 0)
                    });
                }
                getSubcode() {
                    return this.subcode;
                }
                getSourceData() {
                    return this.sourceData;
                }
            }
            module.exports.SDTUnsupportedValueError = SDTUnsupportedValueError;
        },
        "./modules/solclient-sdt/lib/sdt-value-error-subcodes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SDTValueErrorSubcode = {
                VALUE_OUTSIDE_SUPPORTED_RANGE: 1
            };
            module.exports.SDTValueErrorSubcode = Enum.new(SDTValueErrorSubcode);
        },
        "./modules/solclient-sdt/lib/validate-sdt-field.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
            const SDTMapContainerLib = __webpack_require__("./modules/solclient-sdt/lib/sdt-map-container.js");
            const SDTStreamContainerLib = __webpack_require__("./modules/solclient-sdt/lib/sdt-stream-container.js");
            const ValidateLib = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/lib/sdt-field-types.js");
            const baseTypes = (() => {
                const result = [];
                result[SDTFieldType.BOOL] = "boolean";
                result[SDTFieldType.UINT8] = "number";
                result[SDTFieldType.INT8] = "number";
                result[SDTFieldType.UINT16] = "number";
                result[SDTFieldType.INT16] = "number";
                result[SDTFieldType.UINT32] = "number";
                result[SDTFieldType.INT32] = "number";
                result[SDTFieldType.UINT64] = "number";
                result[SDTFieldType.INT64] = "number";
                result[SDTFieldType.WCHAR] = "string";
                result[SDTFieldType.STRING] = "string";
                result[SDTFieldType.BYTEARRAY] = "object";
                result[SDTFieldType.FLOATTYPE] = "number";
                result[SDTFieldType.DOUBLETYPE] = "number";
                return result;
            })();
            function failInvalidParameter(valueType) {
                return new OperationError(`Invalid SDT type:value combination, expected value type ${valueType}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
            }
            function validateSdtField(type, value) {
                if (baseTypes[type]) {
                    if (baseTypes[type] === "boolean" && typeof value !== "boolean" || baseTypes[type] === "number" && typeof value !== "number" || baseTypes[type] === "string" && typeof value !== "string") {
                        return failInvalidParameter(baseTypes[type]);
                    }
                }
                if (type === SDTFieldType.MAP && !ValidateLib.Check.instanceOf(value, SDTMapContainerLib.SDTMapContainer)) {
                    return failInvalidParameter("SDTMapContainer");
                }
                if (type === SDTFieldType.STREAM && !ValidateLib.Check.instanceOf(value, SDTStreamContainerLib.SDTStreamContainer)) {
                    return failInvalidParameter("SDTStreamContainer");
                }
                if (type === SDTFieldType.DESTINATION && !ValidateLib.Check.instanceOf(value, DestinationLib.Destination)) {
                    return failInvalidParameter("Destination");
                }
                return null;
            }
            module.exports.validateSdtField = validateSdtField;
        },
        "./modules/solclient-session/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                AuthenticationScheme
            } = __webpack_require__("./modules/solclient-session/lib/authentication-schemes.js");
            const {
                CapabilityType,
                ClientCapabilityType
            } = __webpack_require__("./modules/solclient-session/lib/capability-types.js");
            const {
                MessageRxCBInfo
            } = __webpack_require__("./modules/solclient-session/lib/message-rx-cb-info.js");
            const {
                MutableSessionProperty
            } = __webpack_require__("./modules/solclient-session/lib/mutable-session-properties.js");
            const {
                Session
            } = __webpack_require__("./modules/solclient-session/lib/session.js");
            const {
                SessionEvent
            } = __webpack_require__("./modules/solclient-session/lib/session-event.js");
            const {
                SessionEventCBInfo
            } = __webpack_require__("./modules/solclient-session/lib/session-event-cb-info.js");
            const {
                SessionEventCode
            } = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js");
            const {
                SessionEventName
            } = __webpack_require__("./modules/solclient-session/lib/session-event-names.js");
            const {
                SessionProperties
            } = __webpack_require__("./modules/solclient-session/lib/session-properties.js");
            const {
                SessionState
            } = __webpack_require__("./modules/solclient-session/lib/session-states.js");
            const {
                SolclientFactory
            } = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                SslDowngrade
            } = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js");
            SolclientFactory.createSession = SolclientFactory.createFactory((sessionProperties, messageCallbackInfo, eventCallbackInfo) => new Session(sessionProperties, messageCallbackInfo, eventCallbackInfo));
            module.exports.AuthenticationScheme = AuthenticationScheme;
            module.exports.CapabilityType = CapabilityType;
            module.exports.ClientCapabilityType = ClientCapabilityType;
            module.exports.MessageRxCBInfo = MessageRxCBInfo;
            module.exports.MutableSessionProperty = MutableSessionProperty;
            module.exports.Session = Session;
            module.exports.SessionEventCBInfo = SessionEventCBInfo;
            module.exports.SessionEventCode = SessionEventCode;
            module.exports.SessionEvent = SessionEvent;
            module.exports.SessionEventName = SessionEventName;
            module.exports.SessionProperties = SessionProperties;
            module.exports.SessionState = SessionState;
            module.exports.SslDowngrade = SslDowngrade;
        },
        "./modules/solclient-session/lib/authentication-schemes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const AuthenticationScheme = {
                BASIC: "AuthenticationScheme_basic",
                CLIENT_CERTIFICATE: "AuthenticationScheme_clientCertificate",
                AUTHENTICATION_SCHEME_BASIC: "AuthenticationScheme_basic",
                AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE: "AuthenticationScheme_clientCertificate",
                OAUTH2: "AuthenticationScheme_oauth2"
            };
            module.exports.AuthenticationScheme = Enum.new(AuthenticationScheme);
        },
        "./modules/solclient-session/lib/capability-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const CapabilityType = {
                PEER_SOFTWARE_VERSION: 0,
                PEER_SOFTWARE_DATE: 1,
                PEER_PLATFORM: 2,
                PEER_PORT_SPEED: 3,
                PEER_PORT_TYPE: 4,
                MAX_DIRECT_MSG_SIZE: 5,
                PEER_ROUTER_NAME: 6,
                MESSAGE_ELIDING: 7,
                NO_LOCAL: 8,
                GUARANTEED_MESSAGE_CONSUME: 9,
                TEMPORARY_ENDPOINT: 10,
                GUARANTEED_MESSAGE_PUBLISH: 11,
                GUARANTEED_MESSAGE_BROWSE: 12,
                ENDPOINT_MGMT: 13,
                SELECTOR: 14,
                MAX_GUARANTEED_MSG_SIZE: 15,
                ACTIVE_CONSUMER_INDICATION: 16,
                COMPRESSION: 17,
                CUT_THROUGH: 18,
                ENDPOINT_DISCARD_BEHAVIOR: 19,
                ENDPOINT_MESSAGE_TTL: 20,
                JNDI: 21,
                PER_TOPIC_SEQUENCE_NUMBERING: 22,
                QUEUE_SUBSCRIPTIONS: 23,
                SUBSCRIPTION_MANAGER: 24,
                TRANSACTED_SESSION: 25,
                MESSAGE_REPLAY: 26,
                COMPRESSED_SSL: 27,
                SHARED_SUBSCRIPTIONS: 28,
                BR_REPLAY_ERRORID: 29
            };
            const ClientCapabilityType = {
                UNBIND_ACK: 0,
                BR_ERRORID: 1
            };
            module.exports.CapabilityType = Enum.new(CapabilityType);
            module.exports.ClientCapabilityType = Enum.new(ClientCapabilityType);
        },
        "./modules/solclient-session/lib/correlated-request.js": module => {
            class CorrelatedRequest {
                constructor(correlationTag, timer, correlationKey, respRecvdCallback) {
                    this.correlationTag = correlationTag;
                    this.timer = timer;
                    this.correlationKey = correlationKey;
                    this.respRecvdCallback = respRecvdCallback;
                }
            }
            module.exports.CorrelatedRequest = CorrelatedRequest;
        },
        "./modules/solclient-session/lib/default-capabilities.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                CapabilityType
            } = __webpack_require__("./modules/solclient-session/lib/capability-types.js");
            module.exports.DefaultCapabilities = {
                createDefaultCapabilities(sessionProperties) {
                    const defaultCapabilities = {
                        [CapabilityType.GUARANTEED_MESSAGE_CONSUME]: true,
                        [CapabilityType.GUARANTEED_MESSAGE_PUBLISH]: true,
                        [CapabilityType.SHARED_SUBSCRIPTIONS]: true,
                        [CapabilityType.MAX_GUARANTEED_MSG_SIZE]: sessionProperties.assumedMaxAdSize
                    };
                    return defaultCapabilities;
                }
            };
        },
        "./modules/solclient-session/lib/global-context.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Process
            } = __webpack_require__("./modules/solclient-util/api.js");
            const C_2_32 = Math.pow(2, 32);
            function leftPad(str, len) {
                if (len > str.length) {
                    return "0".repeat(len - str.length) + str;
                }
                return str;
            }
            function generateRandomId() {
                const rand = (Math.random() * C_2_32).toFixed(0);
                return leftPad(rand.toString(), 10);
            }
            const GlobalContext = {
                sessionCounter: 0,
                idCounter: 0,
                RandId: generateRandomId(),
                NextSessionCounter() {
                    const count = ++this.sessionCounter;
                    return leftPad(count.toString(), 4);
                },
                NextId() {
                    return ++this.idCounter;
                },
                GenerateClientName() {
                    const {
                        product,
                        platform
                    } = Process;
                    const result = `${product}/${platform}/${this.RandId}/${this.NextSessionCounter()}`;
                    return result;
                },
                GenerateUserIdentification() {
                    const {
                        product,
                        platform
                    } = Process;
                    return `${product}/${platform}/${this.RandId}`;
                },
                GenerateClientDescription() {
                    return `solclientjs/${Process.description}`.substring(0, 254);
                }
            };
            module.exports.GlobalContext = GlobalContext;
        },
        "./modules/solclient-session/lib/host-list-dns-filter.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                parseURL
            } = __webpack_require__("./modules/solclient-util/api.js");
            let hostListDNSFilter;
            if (true) {
                const dns = __webpack_require__("dns");
                const dnsLookupPromise = (url, options) => new Promise(resolve => {
                    const host = parseURL(url).hostname;
                    LOG_TRACE("looking up", url, "=>", host);
                    dns.lookup(host, options, (error, result) => {
                        LOG_TRACE("DNS result", error, result);
                        return error === null ? resolve({
                            url: url,
                            host: host,
                            address: result,
                            resolved: true
                        }) : resolve({
                            url: url,
                            host: host,
                            resolved: true,
                            error: {
                                code: error["code"],
                                errno: error["errno"],
                                hostname: error["hostname"],
                                syscall: error["syscall"]
                            }
                        });
                    });
                });
                hostListDNSFilter = function hostListDNSFilterNode(urls, cb) {
                    const promises = urls.map(url => dnsLookupPromise(url, {
                        verbatim: true
                    }));
                    Promise.all(promises).then(resolved => cb(null, resolved)).catch(err => cb(err));
                };
            } else {}
            module.exports.hostListDNSFilter = hostListDNSFilter;
        },
        "./modules/solclient-session/lib/host-list.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                hostListDNSFilter
            } = __webpack_require__("./modules/solclient-session/lib/host-list-dns-filter.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                parseURL
            } = __webpack_require__("./modules/solclient-util/api.js");
            function parseURLs(rawURLs) {
                if (Array.isArray(rawURLs)) {
                    return rawURLs.map(rawURL => parseURL(rawURL));
                }
                return parseURLs(rawURLs.split(/[,;]/));
            }
            class HostInfo {
                constructor(props = {
                    url: null,
                    waitTime: 0
                }) {
                    Object.assign(this, props);
                }
            }
            class HostList {
                constructor({
                    url,
                    connectRetries,
                    reconnectRetries,
                    connectRetriesPerHost,
                    reconnectRetryWaitInMsecs
                } = {}) {
                    Object.assign(this, {
                        hosts: parseURLs(url).map(e => e.href),
                        connectTryCount: connectRetries === -1 ? Number.POSITIVE_INFINITY : connectRetries + 1,
                        reconnectTryCount: reconnectRetries === -1 ? Number.POSITIVE_INFINITY : reconnectRetries,
                        connectTryCountPerHost: connectRetriesPerHost === -1 ? Number.POSITIVE_INFINITY : connectRetriesPerHost + 1,
                        reconnectRetryWaitInMsecs: reconnectRetryWaitInMsecs,
                        _mutableState: {},
                        logger: new LogFormatter("[host-list]")
                    });
                    assert(this.hosts.length >= 1);
                    assert(this.connectTryCount >= 1);
                    assert(this.reconnectTryCount >= 0);
                    assert(this.connectTryCountPerHost >= 1);
                }
                resolveHosts(callback) {
                    const {
                        LOG_TRACE,
                        LOG_WARN
                    } = this.logger;
                    hostListDNSFilter(this.hosts, (err, resolved) => {
                        if (err) return callback(err);
                        assert(resolved.length === this.hosts.length, "Resolve did not return a result for all hosts");
                        LOG_TRACE("Resolve result", resolved);
                        let succeeded = 0;
                        resolved.forEach(result => {
                            if (result.address) {
                                ++succeeded;
                            }
                            if (!result.resolved) {
                                return;
                            }
                            if (result.address) {
                                LOG_TRACE("DNS resolve OK:    ", result.address, "for", result.url);
                            } else {
                                LOG_WARN("DNS resolve FAILED:", result.error.code, `${result.error.syscall}('${result.error.hostname}')`, "for", result.url);
                            }
                        });
                        return callback(succeeded === 0 ? "All hosts failed DNS resolution" : null);
                    });
                }
                reset(state = {
                    wasConnected: false,
                    disconnected: false
                }) {
                    Object.assign(this._mutableState, {
                        wasConnected: state.wasConnected,
                        disconnected: state.disconnected,
                        hostPointer: 0,
                        hostTries: 0,
                        listTries: 1,
                        exhausted: false,
                        lastHostInfo: new HostInfo()
                    });
                }
                getNextHost() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    const state = this._mutableState;
                    const wasConnected = state.wasConnected;
                    const lastHostInfo = state.lastHostInfo;
                    assert(lastHostInfo, "Next host request with no prior host info -- did you call reset()?");
                    try {
                        if (state.disconnected) {
                            LOG_TRACE("Host list set to disconnected, providing null next host");
                            return null;
                        }
                        assert(!state.exhausted, "Next host request after host list exhausted");
                        const properties = Object.assign({
                            hosts: this.hosts,
                            hostTriesMax: this.connectTryCountPerHost,
                            listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount
                        });
                        LOG_TRACE("Getting next host\n", "properties", properties, "\nstate", state);
                        LOG_TRACE("Last host", lastHostInfo);
                        ++state.hostTries;
                        if (state.hostTries > properties.hostTriesMax) {
                            LOG_TRACE(`Exhausted ${state.hostTries} host tries for host ${lastHostInfo.url}.`);
                            ++state.hostPointer;
                            if (state.hostPointer >= properties.hosts.length) {
                                ++state.listTries;
                                if (state.listTries > properties.listTriesMax) {
                                    LOG_TRACE(`Exhausted host list at ${properties.listTriesMax} traversals.`);
                                    state.exhausted = true;
                                } else {
                                    LOG_TRACE(`Host list try (${state.listTries}/${properties.listTriesMax})`);
                                    state.hostPointer = 0;
                                    state.hostTries = 1;
                                }
                            } else {
                                state.hostTries = 1;
                            }
                        } else {
                            LOG_TRACE(`Host try (${state.hostTries}/${properties.hostTriesMax})`);
                        }
                        if (state.exhausted) {
                            LOG_TRACE("All hosts exhausted");
                            return null;
                        }
                        const url = properties.hosts[state.hostPointer];
                        assert(url, `No host at the host pointer! ${properties.hosts}[${state.hostPointer}]`);
                        const isNewList = lastHostInfo.url === null;
                        const isNewHost = lastHostInfo.url !== url;
                        const didJustFinishList = lastHostInfo.url !== url && state.hostPointer === 0;
                        const waitTime = isNewList || isNewHost && !didJustFinishList ? 0 : this.reconnectRetryWaitInMsecs;
                        const hostInfo = new HostInfo({
                            url: url,
                            waitTime: waitTime
                        });
                        LOG_TRACE("Returning host from", hostInfo);
                        state.lastHostInfo = hostInfo;
                        return hostInfo.url;
                    } finally {
                        LOG_TRACE("Final list state\n", state);
                    }
                }
                get connectWaitTimeInMsecs() {
                    assert(this._mutableState.lastHostInfo.url, "Getting connectWaitTimeInMsecs having never called getNextHostInfo");
                    return this._mutableState.lastHostInfo.waitTime;
                }
                currentHostToString() {
                    const state = this._mutableState;
                    const wasConnected = state.wasConnected;
                    const properties = Object.assign({
                        hosts: this.hosts,
                        hostTriesMax: this.connectTryCountPerHost,
                        listTriesMax: wasConnected ? this.reconnectTryCount : this.connectTryCount
                    });
                    const hostNumber = state.hostPointer + 1;
                    return `host '${state.lastHostInfo.url}' (host ${hostNumber} of ${properties.hosts.length})(host connection attempt ${state.hostTries} of ${properties.hostTriesMax})(total ${wasConnected ? "reconnection" : "connection"} attempt ${state.listTries} of ${properties.listTriesMax})`;
                }
            }
            module.exports.HostList = HostList;
        },
        "./modules/solclient-session/lib/message-rx-cb-info.js": module => {
            class MessageRxCBInfo {
                constructor(messageRxCBFunction, userObject) {
                    this.messageRxCBFunction = messageRxCBFunction;
                    this.userObject = userObject;
                }
            }
            module.exports.MessageRxCBInfo = MessageRxCBInfo;
        },
        "./modules/solclient-session/lib/mutable-session-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const MutableSessionProperty = {
                CLIENT_NAME: 1,
                CLIENT_DESCRIPTION: 2
            };
            module.exports.MutableSessionProperty = Enum.new(MutableSessionProperty);
        },
        "./modules/solclient-session/lib/outstanding-data-request.js": module => {
            class OutstandingDataRequest {
                constructor(correlationId, timer, replyReceivedCBFunction, reqFailedCBFunction, userObject) {
                    this.correlationId = correlationId;
                    this.timer = timer;
                    this.replyReceivedCBFunction = replyReceivedCBFunction;
                    this.reqFailedCBFunction = reqFailedCBFunction;
                    this.userObject = userObject;
                }
            }
            module.exports.OutstandingDataRequest = OutstandingDataRequest;
        },
        "./modules/solclient-session/lib/p2p-util.js": module => {
            const P2PUtil = {
                getP2PInboxTopic(base) {
                    return `${base}/_`;
                },
                getP2PTopicSubscription(base) {
                    return `${base}/>`;
                }
            };
            module.exports.P2PUtil = P2PUtil;
        },
        "./modules/solclient-session/lib/session-event-cb-info.js": module => {
            class SessionEventCBInfo {
                constructor(sessionEventCBFunction, userObject) {
                    this.userObject = userObject;
                    this.sessionEventCBFunction = sessionEventCBFunction;
                }
            }
            module.exports.SessionEventCBInfo = SessionEventCBInfo;
        },
        "./modules/solclient-session/lib/session-event-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SessionEventCode = {
                UP_NOTICE: 0,
                DOWN_ERROR: 1,
                CONNECT_FAILED_ERROR: 2,
                REJECTED_MESSAGE_ERROR: 4,
                SUBSCRIPTION_ERROR: 5,
                SUBSCRIPTION_OK: 6,
                VIRTUALROUTER_NAME_CHANGED: 7,
                REQUEST_ABORTED: 8,
                REQUEST_TIMEOUT: 9,
                PROPERTY_UPDATE_OK: 10,
                PROPERTY_UPDATE_ERROR: 11,
                CAN_ACCEPT_DATA: 13,
                DISCONNECTED: 14,
                RECONNECTING_NOTICE: 22,
                RECONNECTED_NOTICE: 23,
                REPUBLISHING_UNACKED_MESSAGES: 24,
                ACKNOWLEDGED_MESSAGE: 25,
                UNSUBSCRIBE_TE_TOPIC_OK: 26,
                UNSUBSCRIBE_TE_TOPIC_ERROR: 27,
                MESSAGE: 28,
                GUARANTEED_MESSAGE_PUBLISHER_DOWN: 29
            };
            module.exports.SessionEventCode = Enum.new(SessionEventCode);
        },
        "./modules/solclient-session/lib/session-event-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SessionEventName = {
                CONNECT: "SessionConnect",
                DISCONNECT: "SessionDisconnect",
                DISPOSE: "SessionDispose",
                CONNECT_TIMEOUT: "SessionConnectTimeout",
                CONNECT_WAIT_TIMEOUT: "SessionConnectWaitTimeout",
                DOWNGRADE_TIMEOUT: "SessionDowngradeTimeout",
                TRANSPORT_UP: "SessionTransportUp",
                TRANSPORT_DESTROYED: "SessionTransportDestroyed",
                TRANSPORT_CAN_ACCEPT_DATA: "SessionTransportCanAcceptData",
                TRANSPORT_PARSE_ERROR: "SessionTransportParseError",
                TRANSPORT_PROTOCOL_SMP: "SessionSMPMessage",
                TRANSPORT_PROTOCOL_CLIENTCTRL: "SessionClientCtrlMessage",
                EXCEPTION: "SessionException",
                SUBSCRIBE_TIMEOUT: "SessionSubscribeTimeout",
                CREATE_SUBSCRIBER: "SessionCreateSubscriber",
                FLOW_UP: "SessionFlowUp",
                FLOW_FAILED: "SessionFlowFailed",
                SEND_ERROR: "SessionSendError",
                FLOWS_DISCONNECTED: "SessionFlowsDisconnected",
                TRANSPORT_FLUSHED: "SessionTransportFlushed",
                DNS_RESOLUTION_COMPLETE: "SessionDNSResolutionComplete",
                TRANSPORT_CHANGE_DONE: "SessionTransportChangeDone"
            };
            module.exports.SessionEventName = Enum.new(SessionEventName);
        },
        "./modules/solclient-session/lib/session-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                ErrorSubcode,
                OperationError,
                RequestError,
                RequestEventCode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                SessionEventCode
            } = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js");
            function buildType(Superclass) {
                class SessionEvent extends Superclass {
                    constructor(superclassArgs, sessionEventCode, infoStr, responseCode = undefined, errorSubcode = 0, correlationKey = undefined, reason = undefined) {
                        super(...superclassArgs);
                        this._sessionEventCode = sessionEventCode;
                        this._infoStr = infoStr;
                        this._responseCode = responseCode;
                        this._errorSubcode = errorSubcode;
                        this._correlationKey = correlationKey;
                        this._reason = reason;
                    }
                    get sessionEventCode() {
                        return this._sessionEventCode;
                    }
                    get infoStr() {
                        return this._infoStr;
                    }
                    get responseCode() {
                        return this._responseCode;
                    }
                    get errorSubcode() {
                        return this.subcode || this._errorSubcode;
                    }
                    get errorSubCode() {
                        return this.errorSubcode;
                    }
                    get correlationKey() {
                        return this._correlationKey;
                    }
                    get reason() {
                        return this._reason;
                    }
                    set reason(value) {
                        this._reason = value;
                    }
                    [Symbol.for("nodejs.util.inspect.custom")]() {
                        return Object.assign(super[Symbol.for("nodejs.util.inspect.custom")] || {}, {
                            sessionEventCode: SessionEventCode.describe(this.sessionEventCode),
                            infoStr: this.infoStr,
                            responseCode: this.responseCode,
                            errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                            correlationKey: this.correlationKey ? this.correlationKey.toString() : null,
                            reason: this.reason ? this.reason : null
                        });
                    }
                    toString() {
                        return util_inspect(this);
                    }
                }
                return SessionEvent;
            }
            const SUPERCLASS_FOR_SESSION_EVENT = {
                [SessionEventCode.CONNECT_FAILED_ERROR]: OperationError,
                [SessionEventCode.DOWN_ERROR]: OperationError,
                [SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN]: OperationError,
                [SessionEventCode.PROPERTY_UPDATE_ERROR]: RequestError,
                [SessionEventCode.REJECTED_MESSAGE_ERROR]: RequestError,
                [SessionEventCode.SUBSCRIPTION_ERROR]: RequestError,
                [SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR]: OperationError,
                [RequestEventCode.REQUEST_ABORTED]: RequestError,
                [RequestEventCode.REQUEST_TIMEOUT]: RequestError
            };
            const SUPERCLASS_ARGS = new Map().set(Object, () => []).set(OperationError, (sec, infoStr, rc, subcode, ck, reason) => [ infoStr, subcode, reason ]).set(RequestError, (sec, infoStr, rc, subcode, ck, reason) => [ infoStr, sec, ck, reason ]);
            const TYPE_CACHE = new Map();
            function build(sessionEventCode, infoStr, responseCode = undefined, errorSubcode = 0, correlationKey = undefined, reason = undefined) {
                const Superclass = SUPERCLASS_FOR_SESSION_EVENT[sessionEventCode] || Object;
                const SessionEvent = (() => {
                    let result = TYPE_CACHE.get(Superclass);
                    if (result) return result;
                    result = buildType(Superclass);
                    TYPE_CACHE.set(Superclass, result);
                    return result;
                })();
                const superclassArgsBuilder = SUPERCLASS_ARGS.get(Superclass) || (() => []);
                const superclassArgs = superclassArgsBuilder(sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
                return new SessionEvent(superclassArgs, sessionEventCode, infoStr, responseCode, errorSubcode, correlationKey, reason);
            }
            const SessionEvent = buildType(Object);
            SessionEvent.build = build;
            module.exports.SessionEvent = SessionEvent;
        },
        "./modules/solclient-session/lib/session-fsm-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                FsmEvent
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                formatHexString
            } = Hex;
            class SessionFSMEvent extends FsmEvent {
                constructor(spec, fields) {
                    super(spec);
                    this.eventText = null;
                    this.errorSubcode = null;
                    this.eventReason = null;
                    this.smfMsg = null;
                    this.sessionId = null;
                    this.guaranteedFlowObject = null;
                    Object.assign(this, fields);
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        eventText: this.eventText,
                        eventReason: this.eventReason,
                        errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                        sessionId: this.sessionId && formatHexString(this.sessionId) || "N/A"
                    };
                }
                getExtraStringInfo() {
                    return util_inspect(this);
                }
            }
            module.exports.SessionFSMEvent = SessionFSMEvent;
        },
        "./modules/solclient-session/lib/session-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const ConsumerLib = __webpack_require__("./modules/solclient-message-consumer/api.js");
            const PublisherLib = __webpack_require__("./modules/solclient-message-publisher/api.js");
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const TransportLib = __webpack_require__("./modules/solclient-transport/api.js");
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                CapabilityType
            } = __webpack_require__("./modules/solclient-session/lib/capability-types.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                CorrelatedRequest
            } = __webpack_require__("./modules/solclient-session/lib/correlated-request.js");
            const {
                Destination
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                ErrorResponseSubcodeMapper,
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                FsmEvent,
                State,
                StateMachine
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Message,
                MessageDeliveryModeType
            } = __webpack_require__("./modules/solclient-message/api.js");
            const {
                P2PUtil
            } = __webpack_require__("./modules/solclient-session/lib/p2p-util.js");
            const {
                SessionEvent
            } = __webpack_require__("./modules/solclient-session/lib/session-event.js");
            const {
                SessionEventCode
            } = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js");
            const {
                SessionEventName
            } = __webpack_require__("./modules/solclient-session/lib/session-event-names.js");
            const {
                SessionFSMEvent
            } = __webpack_require__("./modules/solclient-session/lib/session-fsm-event.js");
            const {
                SessionRequestType
            } = __webpack_require__("./modules/solclient-session/lib/session-request-types.js");
            const {
                SessionStateName
            } = __webpack_require__("./modules/solclient-session/lib/session-state-names.js");
            const {
                SslDowngrade
            } = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js");
            const {
                StatType,
                StatsByMode
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                SubscriptionUpdateTimeoutMessages
            } = __webpack_require__("./modules/solclient-session/lib/subscription-update-timeout-messages.js");
            const {
                formatHexString
            } = Hex;
            const {
                stripNullTerminate
            } = StringUtils;
            const {
                STAT_TX_BYMODE_BYTES,
                STAT_TX_BYMODE_MSGS,
                STAT_RX_BYMODE_BYTES,
                STAT_RX_BYMODE_MSGS,
                STAT_TX_BYMODE_REDELIVERED,
                STAT_TX_BYMODE_BYTES_REDELIVERED
            } = StatsByMode;
            class SessionFSM extends StateMachine {
                constructor(sessionProperties, session, stats, hosts) {
                    super({
                        name: "SessionFSM"
                    });
                    const fsm = this;
                    const logFormatter = function logFormatter(...args) {
                        return [ `[session-fsm=${fsm.sessionIdHex || "(N/A)"}]`, `[${fsm.getCurrentStateName()}]`, ...args ];
                    };
                    const logger = this.logger = new LogFormatter(logFormatter);
                    const {
                        LOG_TRACE,
                        LOG_DEBUG,
                        LOG_INFO
                    } = logger;
                    this.log = logger.wrap(this.log, this);
                    this._sessionProperties = sessionProperties;
                    this._session = session;
                    this._sessionStatistics = stats;
                    this._hosts = hosts;
                    this._consumers = new ConsumerLib.ConsumerFlows();
                    this._flowInterfaceFactory = flow => ({
                        getCorrelationTag: this.getCorrelationTag.bind(this),
                        incStat: this.incStat.bind(this),
                        sendData: message => this.send(message, flow, false),
                        sendToTransport: message => this.sendToTransport(message, flow, false),
                        sendControl: message => this.send(message, flow, true),
                        enqueueRequest: this.enqueueOutstandingCorrelatedReq.bind(this),
                        createDestinationFromDescriptor: session.createDestinationFromDescriptor.bind(session),
                        createTemporaryDestination: session.createTemporaryDestination.bind(session),
                        isCapable: session.isCapable.bind(session),
                        getCapability: session.getCapability.bind(session),
                        getCurrentStateName: this.getCurrentStateName.bind(this),
                        updateQueueSubscription: session.updateQueueSubscription.bind(session),
                        get sessionIdHex() {
                            return fsm.sessionIdHex;
                        },
                        get canAck() {
                            return session.canAck;
                        }
                    });
                    this._userBackpressured = false;
                    this.clearCurrentError();
                    this.initial(function onInitial() {
                        return this.transitionTo(fsm.SessionDisconnected, context => context.getStateMachine().reset());
                    });
                    this.unhandledEventReaction(function onUnhandledEvent(sEvent) {
                        const curState = fsm.getCurrentState();
                        switch (sEvent.getName()) {
                          case SessionEventName.CREATE_SUBSCRIBER:
                            assert(fsm._consumers, "collection has lifetime of FSM instance");
                            fsm._consumers.add(sEvent.guaranteedFlowObject);
                            return this;

                          case SessionEventName.DISPOSE:
                            LOG_DEBUG("Handling DISPOSE");
                            return curState.terminate(() => fsm.disposeInternal());

                          case SessionEventName.FLOW_UP:
                            LOG_DEBUG(`Ignoring FLOW_UP event from ${sEvent.guaranteedFlowObject}`);
                            return this;

                          default:
                            LOG_TRACE(`Ignoring event ${sEvent.getName()} in state ${fsm.getCurrentStateName()}`);
                            return this;
                        }
                    });
                    this.SessionConnecting = new State({
                        name: SessionStateName.CONNECTING,
                        parentContext: fsm
                    }, {
                        handleTransportDestroyed() {
                            fsm._currentHost = fsm._hosts.getNextHost();
                            if (fsm._currentHost === null) {
                                return this.transitionToExitPoint(fsm.SessionConnecting, "ErrorExit");
                            }
                            const {
                                connectWaitTimeInMsecs
                            } = fsm._hosts;
                            LOG_TRACE(`Wait time for this host is ${connectWaitTimeInMsecs}`);
                            if (connectWaitTimeInMsecs > 0 && !fsm._connectWaitTimer) {
                                fsm._connectWaitTimer = setTimeout(() => {
                                    fsm._connectWaitTimer = null;
                                    fsm.processEvent(new SessionFSMEvent({
                                        name: SessionEventName.CONNECT_WAIT_TIMEOUT
                                    }));
                                }, connectWaitTimeInMsecs);
                                return this.transitionTo(fsm.WaitingForInterConnectTimeout);
                            }
                            return this.transitionTo(fsm.WaitingForTransport);
                        }
                    }).entry(() => {
                        fsm.setConnectTimer();
                    }).entryPoint("DisconnectTransport", function onDisconnectTransport() {
                        fsm._hosts.reset({
                            wasConnected: undefined,
                            disconnected: true
                        });
                        fsm._connectFailEvent = SessionEventCode.DISCONNECTED;
                        fsm._connectSuccessEvent = SessionEventCode.DISCONNECTED;
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).entryPoint("ReconnectTransport", function onReconnectTransport() {
                        fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
                        fsm._connectSuccessEvent = SessionEventCode.RECONNECTED_NOTICE;
                        const disconnected = fsm._sessionProperties._reconnectRetries === 0;
                        fsm._hosts.reset({
                            wasConnected: true,
                            disconnected: disconnected
                        });
                        if (!disconnected) {
                            const err = fsm._currentError || {};
                            const args = [ err.eventText, err.responseCode, err.errorSubcode, undefined, err.eventReason ];
                            fsm.setPostEventAction(() => {
                                fsm.setConnectTimer();
                                fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.RECONNECTING_NOTICE, ...args));
                            });
                        }
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).initial(() => {
                        fsm.clearCurrentError();
                        fsm._connectFailEvent = SessionEventCode.CONNECT_FAILED_ERROR;
                        fsm._connectSuccessEvent = SessionEventCode.UP_NOTICE;
                        fsm._hosts.resolveHosts(err => {
                            if (!fsm._hosts) {
                                LOG_TRACE("Ignoring host filter fail because session was disposed");
                                return null;
                            }
                            if (err) {
                                LOG_TRACE("DNS filter failed:", err);
                                fsm.setCurrentError({
                                    errorSubcode: ErrorSubcode.UNRESOLVED_HOSTS,
                                    eventText: err
                                });
                                fsm._hosts.reset({
                                    disconnected: true
                                });
                                return this.processEvent(new SessionFSMEvent({
                                    name: SessionEventName.EXCEPTION
                                }));
                            }
                            fsm._hosts.reset({
                                wasConnected: false
                            });
                            fsm._currentHost = fsm._hosts.getNextHost();
                            return this.processEvent(new SessionFSMEvent({
                                name: SessionEventName.DNS_RESOLUTION_COMPLETE
                            }));
                        });
                        return this.transitionTo(fsm.WaitingForDNS);
                    }).reaction(SessionEventName.DNS_RESOLUTION_COMPLETE, function onDNSComplete() {
                        return this.transitionTo(fsm.WaitingForTransport);
                    }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                    }).reaction(SessionEventName.CONNECT_TIMEOUT, function onConnectTimeout() {
                        fsm.setCurrentError({
                            errorSubcode: ErrorSubcode.TIMEOUT,
                            eventText: "Connect timeout"
                        });
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).reaction(SessionEventName.SEND_ERROR, function onSendError(sessionEvent) {
                        LOG_INFO(`SEND_ERROR reached SessionConnecting. ${sessionEvent}`);
                        fsm.setCurrentError(sessionEvent);
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
                        fsm.setCurrentError(errEvent);
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
                        fsm.setCurrentError(sessionEvent);
                        LOG_INFO("TRANSPORT_DESTROYED event");
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).exit(() => {
                        fsm.clearConnectTimer();
                        if (fsm._connectWaitTimer) {
                            clearTimeout(fsm._connectWaitTimer);
                            fsm._connectWaitTimer = null;
                        }
                    }).exitPoint("ConnectedExit", () => {
                        fsm.setPostEventAction(() => {
                            fsm.emitSessionEvent(SessionEvent.build(fsm._connectSuccessEvent, `'${fsm._hosts.currentHostToString()}'`, 200, 0, null, null));
                            if (fsm._userBackpressured) {
                                const sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, "", null, 0, null, "");
                                fsm.emitSessionEvent(sessionEvent);
                                fsm._userBackpressured = false;
                            }
                        });
                        fsm.clearCurrentError();
                        return this.transitionTo(fsm.SessionTransportUp);
                    }).exitPoint("ErrorExit", function onExit() {
                        fsm.setPostEventAction(() => {
                            const err = fsm._currentError || {};
                            const args = [ err.eventText, err.responseCode, err.errorSubcode, undefined, err.eventReason ];
                            fsm.emitSessionEvent(SessionEvent.build(fsm._connectFailEvent, ...args));
                        });
                        return this.transitionTo(fsm.SessionDisconnected);
                    });
                    this.WaitingForDNS = new State({
                        name: SessionStateName.WAITING_FOR_DNS,
                        parentContext: fsm.SessionConnecting
                    });
                    this.DestroyingTransport = new State({
                        name: SessionStateName.DESTROYING_TRANSPORT,
                        parentContext: fsm.SessionConnecting
                    }).entry(() => {
                        LOG_INFO("Connecting, disposing transport");
                        fsm.destroyTransportSession("Disconnecting session", 0);
                    }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sessionEvent) {
                        fsm.setCurrentError(sessionEvent);
                        return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                    });
                    this.WaitingForInterConnectTimeout = new State({
                        name: SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT,
                        parentContext: fsm.SessionConnecting
                    }).reaction(SessionEventName.CONNECT_WAIT_TIMEOUT, function onConnectWaitTimeout() {
                        return this.transitionTo(fsm.WaitingForTransport);
                    });
                    this.WaitingForTransport = new State({
                        name: SessionStateName.WAITING_FOR_TRANSPORT,
                        parentContext: fsm.SessionConnecting
                    }).initial(() => {
                        const errorMessage = "Cannot establish transport session: creation failed";
                        fsm.setConnectTimer();
                        fsm.clearCurrentError();
                        try {
                            fsm.initTransport();
                        } catch (e) {
                            this.setCurrentError({
                                eventText: e.message === errorMessage ? errorMessage : `${errorMessage}: ${e.message}`,
                                errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
                                eventReason: e
                            });
                            return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                        }
                        return this.transitionTo(fsm.WaitingForTransportUp);
                    });
                    this.WaitingForTransportUp = new State({
                        name: SessionStateName.WAITING_FOR_TRANSPORT_UP,
                        parentContext: this.WaitingForTransport
                    }).entry(() => {
                        this._justEntered = true;
                    }).initial(() => {
                        if (!this._justEntered) {
                            return this;
                        }
                        this._justEntered = false;
                        const errorMessage = "Cannot establish transport session: connection failed";
                        try {
                            const returnCode = fsm._transport.connect();
                            if (returnCode !== TransportLib.TransportReturnCode.OK) {
                                throw new OperationError(errorMessage, ErrorSubcode.CONNECTION_ERROR, TransportLib.TransportReturnCode.describe(returnCode));
                            }
                            LOG_INFO(`Attempting to connect session '${fsm.sessionId}' to ${fsm._hosts.currentHostToString()}`);
                        } catch (e) {
                            this.setCurrentError({
                                eventText: e.message === errorMessage ? errorMessage : `${errorMessage}: ${e.message}`,
                                errorSubcode: e.subcode || ErrorSubcode.INTERNAL_ERROR,
                                eventReason: e
                            });
                            return fsm.SessionConnecting.handleTransportDestroyed.call(this);
                        }
                        return this;
                    }).reaction(SessionEventName.SEND_ERROR, function doNothing(sEvent) {
                        LOG_INFO(`SEND_ERROR while waiting for transport up, doing nothing. ${sEvent}`);
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.TRANSPORT_UP, function onTransportUp(sEvent) {
                        fsm.sessionId = sEvent.sessionId || "";
                        const returnCode = fsm.sendClientCtrlLogin();
                        if (returnCode === TransportLib.TransportReturnCode.OK) {
                            return this.transitionTo(fsm.WaitingForLogin);
                        }
                        const err = {
                            eventText: "Failed to send Client Control Login",
                            errorSubcode: ErrorSubcode.LOGIN_FAILURE,
                            responseCode: 400
                        };
                        fsm.setCurrentError(err);
                        return this.transitionTo(fsm.DestroyingTransport);
                    });
                    this.WaitingForLogin = new State({
                        name: SessionStateName.WAITING_FOR_LOGIN,
                        parentContext: fsm.SessionConnecting
                    }).entry(() => {
                        fsm.setClientCtrlTimer();
                    }).reaction(SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL, function onClientCtrl(sEvent) {
                        const clientCtrlMsg = sEvent.smfMsg;
                        const response = clientCtrlMsg.getResponse();
                        const respCode = response.responseCode;
                        const err = {
                            responseCode: respCode
                        };
                        fsm._responseCode = respCode;
                        if (respCode === 200) {
                            if (!fsm.checkNoLocal(clientCtrlMsg)) {
                                Object.assign(err, {
                                    eventText: "No Local is not supported by the Solace Message Router",
                                    errorSubcode: ErrorSubcode.NO_LOCAL_NOT_SUPPORTED
                                });
                            } else if (!fsm.checkCompressedSsl(clientCtrlMsg)) {
                                Object.assign(err, {
                                    eventText: "Compressed TLS is not supported by the Solace Message Router",
                                    errorSubcode: ErrorSubcode.COMPRESSED_TLS_NOT_SUPPORTED
                                });
                            } else {
                                fsm.updateReadonlySessionProps(clientCtrlMsg);
                                return this.transitionTo(fsm.WaitForTransportChange);
                            }
                        } else {
                            const rawSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, response.responseString);
                            const subcode = rawSubcode === ErrorSubcode.UNKNOWN_ERROR ? ErrorSubcode.LOGIN_FAILURE : rawSubcode;
                            LOG_INFO(`Login failed. Subcode: ${subcode} respCode: ${respCode} ` + `respString: ${response.responseString}`);
                            Object.assign(err, {
                                eventText: response.responseString,
                                errorSubcode: subcode
                            });
                        }
                        LOG_TRACE("ClientCtrl error", err);
                        fsm.setCurrentError(err);
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).reaction(SessionEventName.DOWNGRADE_TIMEOUT, function onDowngradeTimeout() {
                        if (!fsm._transport.requestDowngrade || fsm._transport.requestDowngrade("ClientCtrl timeout", ErrorSubcode.TIMEOUT) === false) {
                            fsm.setCurrentError({
                                eventText: "ClientCtrl timeout",
                                errorSubcode: ErrorSubcode.TIMEOUT
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        }
                        LOG_TRACE("Downgrade accepted, returning to WaitingForTransportUp");
                        return this.transitionTo(fsm.WaitingForTransportUp);
                    }).exit(() => {
                        fsm.clearClientCtrlTimer();
                    });
                    this.WaitForTransportChange = new State({
                        name: SessionStateName.WAITING_FOR_TRANSPORT_CHANGE,
                        parentContext: fsm.SessionConnecting
                    }).initial(function onInitial() {
                        const callback = function onTransportChange(newTransport) {
                            this._transport = newTransport;
                            this.processEvent(new SessionFSMEvent({
                                name: SessionEventName.TRANSPORT_CHANGE_DONE
                            }));
                        };
                        const rc = fsm.updateTransportCompression(callback.bind(fsm));
                        if (rc === null) {
                            return this;
                        }
                        fsm._transport = rc;
                        return this.transitionTo(fsm.ReapplyingSubscriptions);
                    }).reaction(SessionEventName.TRANSPORT_CHANGE_DONE, function onTransportChangeDone() {
                        return this.transitionTo(fsm.ReapplyingSubscriptions);
                    });
                    this.ReapplyingSubscriptions = new State({
                        name: SessionStateName.REAPPLYING_SUBSCRIPTIONS,
                        parentContext: fsm.SessionConnecting
                    }).entry(() => {
                        LOG_INFO("ReapplyingSubscriptions: entry");
                        fsm.copySubscriptionCacheKeys();
                    }).initial(function onInitial() {
                        if (fsm.reapplySubscriptions() === true) {
                            return this.transitionTo(fsm.WaitForSubConfirm);
                        }
                        return this.transitionTo(fsm.WaitForCanAcceptData);
                    }).reaction(SessionEventName.SUBSCRIBE_TIMEOUT, function onSubscribeTimeout() {
                        const respText = "Subscription timeout while reapplying";
                        const subcode = ErrorSubcode.TIMEOUT;
                        fsm.setCurrentError({
                            eventText: respText,
                            errorSubcode: subcode
                        });
                        return this.transitionTo(fsm.DestroyingTransport);
                    }).exit(function onExit() {
                        fsm.clearSubscriptionCacheKeys();
                        return this;
                    });
                    this.WaitForSubConfirm = new State({
                        name: SessionStateName.WAITING_FOR_SUBCONFIRM,
                        parentContext: fsm.ReapplyingSubscriptions
                    }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
                        const smfRespHeader = sEvent.smfMsg.smfHeader;
                        const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                        const respCode = smfRespHeader.pm_respcode;
                        const respText = smfRespHeader.pm_respstr;
                        if (respCode !== 200) {
                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                            LOG_INFO(`Waiting for subscription confirmation, got ${respCode} (${errorSubcode}) ` + `'${respText}' on subscription ${subscriptionStr}`);
                            fsm.setCurrentError({
                                eventText: respText,
                                responseCode: respCode,
                                errorSubcode: errorSubcode
                            });
                            return this.transitionTo(fsm.DestroyTransport);
                        }
                        if (fsm._session.canConnectPublisher && fsm._defaultPublisher && fsm._defaultPublisher.isBindWaiting()) {
                            return this.transitionTo(fsm.WaitingForMessagePublisher);
                        }
                        return this.transitionToExitPoint(fsm.SessionConnecting, "ConnectedExit");
                    });
                    this.WaitForCanAcceptData = new State({
                        name: SessionStateName.WAITING_FOR_CAN_ACCEPT_DATA,
                        parentContext: fsm.ReapplyingSubscriptions
                    }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
                        const smfRespHeader = sEvent.smfMsg.smfHeader;
                        const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                        const respCode = smfRespHeader.pm_respcode;
                        const respText = smfRespHeader.pm_respstr;
                        if (respCode !== 200) {
                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                            LOG_DEBUG(`Waiting for can accept data, got ${respCode} (subcode ${errorSubcode}) ` + `'${respText}' on subscription ${subscriptionStr}`);
                            fsm.setCurrentError({
                                eventText: respText,
                                responseCode: respCode,
                                errorSubcode: errorSubcode
                            });
                            return this.transitionTo(fsm.DestroyingTransport);
                        }
                        LOG_INFO(`Unexpected 200 OK response to subscription add for ${subscriptionStr}`);
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onTransportCanAcceptData() {
                        if (fsm.reapplySubscriptions() === true) {
                            return this.transitionTo(fsm.WaitForSubConfirm);
                        }
                        return this.internalTransition(null);
                    });
                    this.WaitingForMessagePublisher = new State({
                        name: SessionStateName.WAITING_FOR_PUBFLOW,
                        parentContext: fsm.SessionConnecting
                    }).entry(() => {
                        fsm._defaultPublisher.connect();
                        fsm.sendPublisherSessionUpEvent(fsm._defaultPublisher);
                    }).reaction(SessionEventName.FLOW_UP, function onEvent() {
                        LOG_TRACE(`Flow up ${this}`);
                        if (!fsm._defaultPublisher.isBindWaiting()) {
                            LOG_TRACE("Publisher up");
                            return this.transitionToExitPoint(fsm.SessionConnecting, "ConnectedExit");
                        }
                        LOG_TRACE("Waiting for more publishers");
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.FLOW_FAILED, function onEvent(sEvent) {
                        fsm.setCurrentError({
                            eventText: `Guaranteed Message Publisher Failed: ${sEvent.eventText}`,
                            errorSubcode: ErrorSubcode.LOGIN_FAILURE
                        });
                        return this.transitionTo(fsm.DestroyingTransport);
                    });
                    this.SessionTransportUp = new State({
                        name: SessionStateName.TRANSPORT_UP,
                        parentContext: fsm
                    }).entry(function onEntry() {
                        return this;
                    }).initial(function onInitial() {
                        if (fsm._session.canConnectConsumer) {
                            fsm._consumers.flows.forEach(consumer => fsm.sendConsumerSessionUpEvent(consumer));
                            fsm._consumers.reconnectingFlows.forEach(consumer => fsm.sendConsumerSessionUpEvent(consumer));
                        }
                        return this.transitionTo(fsm.FullyConnected);
                    }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                        return this.transitionTo(fsm.SessionDisconnecting);
                    }).reaction(SessionEventName.EXCEPTION, function onException(sEvent) {
                        fsm.setCurrentError(sEvent);
                        fsm.cleanupSession();
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                    }).reaction(SessionEventName.SEND_ERROR, function onSendError(sEvent) {
                        fsm.setCurrentError(sEvent);
                        fsm.cleanupSession();
                        LOG_TRACE("Reconnecting transport after SEND_ERROR (not fully connected)");
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                    }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed(sEvent) {
                        fsm.setCurrentError(sEvent);
                        LOG_INFO("Received unsolicited TRANSPORT_DESTROYED event while transport is up");
                        LOG_TRACE(`TRANSPORT_DESTROYED details: ${sEvent}`);
                        fsm.cleanupSession();
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "ReconnectTransport");
                    }).reaction(SessionEventName.TRANSPORT_PROTOCOL_SMP, function onTransportProtocolSMP(sEvent) {
                        const smfRespHeader = sEvent.smfMsg.smfHeader;
                        const subscriptionStr = stripNullTerminate(sEvent.smfMsg.encodedUtf8Subscription);
                        const respCode = smfRespHeader.pm_respcode;
                        const respText = smfRespHeader.pm_respstr;
                        fsm.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, undefined, false);
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.TRANSPORT_CAN_ACCEPT_DATA, function onCanAcceptData(sEvent) {
                        const sessionEvent = SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, "", null, 0, null, sEvent.toString());
                        fsm.emitSessionEvent(sessionEvent);
                        fsm._userBackpressured = false;
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.CREATE_SUBSCRIBER, function onCreateSubscriber(sEvent) {
                        const consumer = fsm._consumers.add(sEvent.guaranteedFlowObject);
                        fsm.sendConsumerSessionUpEvent(consumer);
                        return this;
                    }).exit(function onExit() {
                        fsm.clearKeepAlive();
                        return this;
                    });
                    this.FullyConnected = new State({
                        name: SessionStateName.FULLY_CONNECTED,
                        parentContext: fsm.SessionTransportUp
                    }).entry(() => {
                        fsm._connectFailEvent = SessionEventCode.DOWN_ERROR;
                        fsm.scheduleKeepAlive();
                    });
                    this.SessionDisconnected = new State({
                        name: SessionStateName.DISCONNECTED,
                        parentContext: fsm
                    }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                        fsm.setPostEventAction(() => {
                            fsm.emitSessionEvent(SessionEvent.build(SessionEventCode.DISCONNECTED));
                        });
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.CONNECT, function onConnect() {
                        return this.transitionTo(fsm.SessionConnecting);
                    }).reaction(SessionEventName.EXCEPTION, function onException() {
                        return this.internalTransition(null);
                    });
                    this.SessionDisconnecting = new State({
                        name: SessionStateName.DISCONNECTING,
                        parentContext: fsm
                    }).initial(() => {
                        LOG_INFO(`Disconnecting session ${fsm}`);
                        return this.transitionTo(fsm.DisconnectingFlows);
                    }).reaction(SessionEventName.DISCONNECT, function onDisconnect() {
                        return this.internalTransition(null);
                    }).reaction(SessionEventName.EXCEPTION, function onException(errEvent) {
                        fsm.setCurrentError({
                            errEvent: errEvent
                        });
                        fsm.cleanupSession();
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                    }).reaction(SessionEventName.TRANSPORT_DESTROYED, function onTransportDestroyed() {
                        LOG_INFO("Received unsolicited TRANSPORT_DESTROYED while disconnecting transport");
                        fsm.cleanupSession();
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                    });
                    this.DisconnectingFlows = new State({
                        name: SessionStateName.DISCONNECTING_FLOWS,
                        parentContext: fsm.SessionDisconnecting
                    }, {
                        gatherPendingFlows() {
                            const {
                                MessageConsumerEventName
                            } = ConsumerLib;
                            assert(!this.isGathering);
                            this.isGathering = true;
                            const adaptedListenForDestroy = (flow, installfn, downEvents) => {
                                assert(flow, "Trying to listen to undefined flow");
                                if (this.known.has(flow)) return;
                                LOG_TRACE(`Adding pending flow ${flow}`);
                                this.known.add(flow);
                                this.pending.add(flow);
                                const onFlowDown = () => {
                                    LOG_TRACE(`Removing flow from pending ${flow}`);
                                    downEvents.forEach(event => flow._removeListener(event, onFlowDown));
                                    this.pending.delete(flow);
                                    if (!this.isGathering) this.checkPendingFlows();
                                };
                                downEvents.forEach(event => installfn.call(flow, event, onFlowDown));
                                try {
                                    flow._disconnectSession();
                                } catch (ex) {
                                    LOG_TRACE("Flow disconnect threw");
                                    LOG_TRACE(ex);
                                    onFlowDown();
                                }
                            };
                            if (fsm._consumers) {
                                fsm._consumers.flows.forEach(flow => {
                                    adaptedListenForDestroy(flow, flow._once, [ MessageConsumerEventName.DOWN, MessageConsumerEventName.DOWN_ERROR ]);
                                });
                            }
                            this.isGathering = false;
                        },
                        checkPendingFlows() {
                            LOG_TRACE("Waiting for disconnects on", this.pending);
                            if (this.pending.size === 0) {
                                this.gatherPendingFlows();
                                if (this.pending.size === 0) {
                                    this.proceed();
                                }
                            }
                        },
                        proceed() {
                            this.known = null;
                            this.pending = null;
                            LOG_INFO("All flows disconnected");
                            fsm.processEvent(new FsmEvent({
                                name: SessionEventName.FLOWS_DISCONNECTED
                            }));
                        }
                    }).entry(function onEntry() {
                        this.known = new Set();
                        this.pending = new Set();
                        this.checkPendingFlows();
                    }).reaction(SessionEventName.FLOWS_DISCONNECTED, function onFlowsDisconnected() {
                        return this.transitionTo(fsm.FlushingTransport);
                    });
                    this.FlushingTransport = new State({
                        name: SessionStateName.FLUSHING_TRANSPORT,
                        parentContext: fsm.SessionDisconnecting
                    }, {
                        flushTransport() {
                            fsm.cleanupSession();
                            fsm.flushTransportSession(() => this.onTransportFlushed());
                            this.sessionId = null;
                        },
                        onTransportFlushed() {
                            fsm.processEvent(new FsmEvent({
                                name: SessionEventName.TRANSPORT_FLUSHED
                            }));
                        }
                    }).entry(function onEntry() {
                        LOG_INFO("Flushing transport");
                        this.flushTransport();
                    }).reaction(SessionEventName.TRANSPORT_FLUSHED, function onTransportFlushed() {
                        LOG_INFO("Handle Transport Flushed");
                        return this.transitionToEntryPoint(fsm.SessionConnecting, "DisconnectTransport");
                    });
                }
                addToSubscriptionCache(destination) {
                    if (Check.nothing(destination) || !this._subscriptionCache) {
                        return;
                    }
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    const key = destination.name;
                    if (this._subscriptionCache[key] === null || this._subscriptionCache[key] === undefined) {
                        LOG_DEBUG(`Cache subscription ${key}`);
                        this._subscriptionCache[key] = destination;
                        LOG_DEBUG("Increment cache count");
                        this._subscriptionCacheCount++;
                    } else {
                        LOG_DEBUG(`Cache subscription ${key}`);
                        this._subscriptionCache[key] = destination;
                    }
                }
                cancelOutstandingCorrelatedReq(correlationTag) {
                    if (Check.nothing(correlationTag) || !this._correlatedReqs) {
                        return null;
                    }
                    const req = this._correlatedReqs[correlationTag];
                    if (req === null || req === undefined) {
                        return null;
                    }
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    LOG_DEBUG(`Cancel outstanding ctrl request correlationTag=${correlationTag}`);
                    if (req.timer) {
                        clearTimeout(req.timer);
                        req.timer = null;
                    }
                    try {
                        const result = delete this._correlatedReqs[correlationTag];
                        if (!result) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                        }
                    } catch (e) {
                        LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`, e);
                    }
                    return req;
                }
                cleanupSession() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO("Clean up session");
                    const {
                        ConsumerFSMEvent,
                        ConsumerFSMEventNames
                    } = ConsumerLib;
                    if (this._correlatedReqs) {
                        Object.keys(this._correlatedReqs).forEach(key => this.cancelOutstandingCorrelatedReq(key));
                    }
                    this.clearConnectTimer();
                    this.clearClientCtrlTimer();
                    this.clearKeepAlive();
                    this._consumers.flows.forEach(consumer => {
                        consumer.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.SESSION_DOWN
                        }));
                    });
                    this._consumers.reconnectingFlows.forEach(consumer => {
                        consumer.processFSMEvent(new ConsumerFSMEvent({
                            name: ConsumerFSMEventNames.SESSION_DOWN
                        }));
                    });
                    if (this._defaultPublisher) {
                        this._defaultPublisher.processFSMEvent(new PublisherLib.PublisherFSMEvent({
                            name: PublisherLib.PublisherFSMEventNames.SESSION_DOWN
                        }));
                    }
                    this._session.cleanupSession();
                }
                clearClientCtrlTimer() {
                    if (!this._clientCtrlTimer) {
                        return;
                    }
                    clearTimeout(this._clientCtrlTimer);
                    this._clientCtrlTimer = null;
                }
                clearConnectTimer() {
                    if (!this._connectTimer) {
                        return;
                    }
                    clearTimeout(this._connectTimer);
                    this._connectTimer = undefined;
                }
                clearKeepAlive() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    if (this._keepAliveTimer) {
                        LOG_INFO("Cancel keepalive timer");
                        clearInterval(this._keepAliveTimer);
                        this._keepAliveTimer = null;
                    }
                    this.resetKeepAliveCounter();
                }
                checkNoLocal(clientCtrlMsg) {
                    let noLocalSupported = true;
                    if (this._sessionProperties.noLocal === true) {
                        const caps = clientCtrlMsg.getRouterCapabilities();
                        if (!caps) {
                            noLocalSupported = false;
                        } else {
                            noLocalSupported = typeof caps[CapabilityType.NO_LOCAL] === "boolean" ? caps[CapabilityType.NO_LOCAL] : false;
                        }
                    }
                    return noLocalSupported;
                }
                checkCompressedSsl(clientCtrlMsg) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    if (this._compressedTLS) {
                        const caps = clientCtrlMsg.getRouterCapabilities();
                        if (!caps || typeof caps[CapabilityType.COMPRESSED_SSL] !== "boolean") {
                            LOG_TRACE("Compressed SSL capability missing.");
                            return false;
                        }
                        return caps[CapabilityType.COMPRESSED_SSL] === true;
                    }
                    return true;
                }
                checkSessionDestinationCapability(destination) {
                    let error = null;
                    if (destination && destination.getType()) {
                        if (destination.getSubscriptionInfo() && (destination.getSubscriptionInfo().isShare || destination.getSubscriptionInfo().isNoExport) && !this._session.isCapable(CapabilityType.SHARED_SUBSCRIPTIONS)) {
                            error = new OperationError("Shared subscriptions are not allowed by router for this client", ErrorSubcode.SHARED_SUBSCRIPTIONS_NOT_SUPPORTED, null);
                        }
                    }
                    return error;
                }
                clearCurrentError() {
                    this._currentError = null;
                }
                clearSubscriptionCacheKeys() {
                    this._subscriptionCacheKeys = null;
                }
                copySubscriptionCacheKeys() {
                    this.clearSubscriptionCacheKeys();
                    this._subscriptionCacheKeys = Object.keys(this._subscriptionCache || {});
                    const p2pTopic = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
                    this._subscriptionCacheKeys.push(p2pTopic);
                }
                createMessagePublisher() {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    if (!this._sessionProperties.publisherProperties.enabled) {
                        LOG_DEBUG("Publisher is disabled");
                        return;
                    }
                    const {
                        MessagePublisher,
                        MessagePublisherEventName
                    } = PublisherLib;
                    const publisher = new MessagePublisher({
                        properties: this._sessionProperties.publisherProperties,
                        sessionInterfaceFactory: this._flowInterfaceFactory
                    });
                    publisher.on(MessagePublisherEventName.UP, () => this.processEvent(new SessionFSMEvent({
                        name: SessionEventName.FLOW_UP
                    }, {
                        guaranteedFlowObject: publisher
                    })));
                    publisher.on(MessagePublisherEventName.CONNECT_FAILED_ERROR, event => this.processEvent(new SessionFSMEvent({
                        name: SessionEventName.FLOW_FAILED
                    }, {
                        guaranteedFlowObject: publisher,
                        event: event,
                        eventText: event.description
                    })));
                    publisher.on(MessagePublisherEventName.REJECTED_MESSAGE, (message, ctrlMessage) => {
                        const header = ctrlMessage.smfHeader;
                        const respCode = header.pm_respcode;
                        const respText = header.pm_respstr;
                        const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(respCode, respText);
                        const event = SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR, respText, respCode, errorSubcode, message.getCorrelationKey());
                        event["message"] = message;
                        this.emitSessionEvent(event);
                    });
                    publisher.on(MessagePublisherEventName.ACKNOWLEDGED_MESSAGE, message => {
                        const event = SessionEvent.build(SessionEventCode.ACKNOWLEDGED_MESSAGE, "Message(s) acknowledged", undefined, 0, message.getCorrelationKey());
                        event["message"] = message;
                        this.emitSessionEvent(event);
                    });
                    publisher.on(MessagePublisherEventName.FLOW_NAME_CHANGED, data => {
                        const {
                            messages,
                            count
                        } = data;
                        if (count > 0) {
                            const event = SessionEvent.build(SessionEventCode.REPUBLISHING_UNACKED_MESSAGES, `Republishing ${count} messages due to ` + "Guaranteed Message Publisher failed to reconnect");
                            event["messages"] = messages;
                            event["count"] = count;
                            this.emitSessionEvent(event);
                        }
                    });
                    publisher.on(MessagePublisherEventName.CAN_SEND, () => {
                        this.emitSessionEvent(SessionEvent.build(SessionEventCode.CAN_ACCEPT_DATA, `${publisher} window is now open and can send`));
                    });
                    publisher.on(MessagePublisherEventName.GUARANTEED_MESSAGING_DOWN, () => {
                        this.emitSessionEvent(SessionEvent.build(SessionEventCode.GUARANTEED_MESSAGE_PUBLISHER_DOWN, "Guaranteed Message Publishing shut down"));
                    });
                    this._defaultPublisher = publisher;
                }
                sendConsumerSessionUpEvent(consumer) {
                    const {
                        ConsumerFSMEvent,
                        ConsumerFSMEventNames
                    } = ConsumerLib;
                    const isAD = this._session.canConnectConsumer;
                    const event = new ConsumerFSMEvent({
                        name: isAD ? ConsumerFSMEventNames.SESSION_UP : ConsumerFSMEventNames.SESSION_UP_NO_AD
                    });
                    event.guaranteedFlowObject = consumer;
                    consumer.processFSMEvent(event);
                }
                sendPublisherSessionUpEvent(publisher) {
                    const isAD = this._session.canConnectPublisher;
                    const event = new PublisherLib.PublisherFSMEvent({
                        name: isAD ? PublisherLib.PublisherFSMEventNames.SESSION_UP : PublisherLib.PublisherFSMEventNames.SESSION_UP_NO_AD
                    });
                    event.guaranteedFlowObject = publisher;
                    publisher.processFSMEvent(event);
                }
                createMessageConsumer(properties) {
                    const {
                        MessageConsumer
                    } = ConsumerLib;
                    const consumer = new MessageConsumer({
                        properties: properties,
                        sessionInterfaceFactory: this._flowInterfaceFactory
                    });
                    const conusmerProperties = consumer.getProperties();
                    if (conusmerProperties.topicEndpointSubscription) {
                        const error = this.checkSessionDestinationCapability(conusmerProperties.topicEndpointSubscription);
                        if (error) {
                            throw error;
                        }
                    }
                    const info = {
                        guaranteedFlowObject: consumer
                    };
                    this.processEvent(new SessionFSMEvent({
                        name: SessionEventName.CREATE_SUBSCRIBER
                    }, info));
                    return consumer;
                }
                createQueueBrowser(properties) {
                    const {
                        MessageConsumerAcknowledgeMode,
                        QueueBrowser
                    } = ConsumerLib;
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    LOG_DEBUG(`Creating queue browser with properties:  ${properties}`);
                    const consumerProperties = {};
                    consumerProperties.queueDescriptor = properties.queueDescriptor;
                    consumerProperties.acknowledgeMode = MessageConsumerAcknowledgeMode.CLIENT;
                    consumerProperties.browser = true;
                    if (Object.prototype.hasOwnProperty.call(properties, "connectTimeoutInMsecs")) {
                        consumerProperties.connectTimeoutInMsecs = properties.connectTimeoutInMsecs;
                    }
                    if (Object.prototype.hasOwnProperty.call(properties, "connectAttempts")) {
                        consumerProperties.connectAttempts = properties.connectAttempts;
                    }
                    if (Object.prototype.hasOwnProperty.call(properties, "windowSize")) {
                        consumerProperties.windowSize = properties.windowSize;
                    }
                    if (Object.prototype.hasOwnProperty.call(properties, "transportAcknowledgeTimeoutInMsecs")) {
                        consumerProperties.transportAcknowledgeTimeoutInMsecs = properties.transportAcknowledgeTimeoutInMsecs;
                    }
                    if (Object.prototype.hasOwnProperty.call(properties, "transportAcknowledgeThresholdPercentage")) {
                        consumerProperties.transportAcknowledgeThresholdPercentage = properties.transportAcknowledgeThresholdPercentage;
                    }
                    const consumer = this.createMessageConsumer(consumerProperties);
                    const browser = new QueueBrowser(consumer);
                    return browser;
                }
                destroyTransportSession(msg, subcode) {
                    if (Check.nothing(this._transport)) {
                        this.processEvent(new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_DESTROYED
                        }));
                        return;
                    }
                    const {
                        LOG_INFO,
                        LOG_ERROR
                    } = this.logger;
                    LOG_INFO("Destroy transport session");
                    const returnCode = this._transport.destroy(msg, subcode);
                    this._smfClient = null;
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        LOG_ERROR(`Failed to destroy transport session, return code: ${TransportLib.TransportReturnCode.describe(returnCode)}`);
                    }
                }
                disposeInternal() {
                    if (this._disposed) {
                        return;
                    }
                    const operations = {
                        transport: () => {
                            this.destroyTransportSession("Disposing", 0);
                            this._transport = null;
                            this._smfClient = null;
                        },
                        session: () => {
                            this.cleanupSession();
                            this._session = null;
                            this._sessionProperties = null;
                            this._correlatedReqs = null;
                            this._flowInterfaceFactory = null;
                        },
                        statistics: () => {
                            if (this._sessionStatistics) {
                                this._sessionStatistics.resetStats();
                                this._sessionStatistics = null;
                            }
                            this._kaStats = null;
                        },
                        "subscription cache": () => {
                            if (this._subscriptionCache) {
                                Object.keys(this._subscriptionCache).forEach(key => this.removeFromSubscriptionCache(key));
                                this._subscriptionCache = null;
                            }
                            this.clearSubscriptionCacheKeys();
                            this._subscriptionCacheCount = 0;
                        },
                        MessagePublishers: () => {
                            if (this._defaultPublisher) {
                                this._defaultPublisher.dispose();
                                this._defaultPublisher = null;
                            }
                        },
                        MessageConsumers: () => {
                            this._consumers.disposeAll();
                            this._consumers = null;
                        },
                        "host list": () => {
                            this._currentHost = null;
                            this._hosts = null;
                        }
                    };
                    Object.keys(operations).forEach(operationKey => {
                        const {
                            LOG_TRACE,
                            LOG_INFO
                        } = this.logger;
                        const operation = operations[operationKey];
                        try {
                            LOG_TRACE(`Dispose: ${operationKey}`);
                            operation();
                            LOG_TRACE(`Dispose: ${operationKey} succeeded`);
                        } catch (ex) {
                            LOG_INFO(`Dispose: ${operationKey} failed:`, ex, "...continuing");
                        }
                    });
                    this._disposed = true;
                }
                emitSessionEvent(event) {
                    this._session.sendEvent(event);
                }
                enqueueOutstandingCorrelatedReq(correlationTag, reqTimeoutCb, reqTimeout, correlationKey, respRecvCallback) {
                    if (Check.nothing(correlationTag)) {
                        return;
                    }
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO(`Enqueue outstanding ctrl request correlationTag=${correlationTag}`);
                    let timer = null;
                    if (reqTimeoutCb) {
                        timer = setTimeout(reqTimeoutCb, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
                    }
                    const outstandingReq = new CorrelatedRequest(correlationTag, timer, correlationKey, respRecvCallback);
                    this._correlatedReqs[correlationTag] = outstandingReq;
                }
                errorInFsm(errorEventText, errorSubcode, eventReason = null) {
                    const {
                        LOG_INFO
                    } = this.logger;
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.EXCEPTION
                    });
                    LOG_INFO(`Handling error in FSM: ${errorEventText} ${eventReason && eventReason.stack}`);
                    this.setCurrentError({
                        eventText: errorEventText,
                        errorSubcode: errorSubcode,
                        eventReason: eventReason
                    });
                    return this.processEvent(sEvent);
                }
                flushTransportSession(callback) {
                    if (this._transport) {
                        this._transport.flush(callback);
                    } else {
                        callback();
                    }
                }
                getCorrelationTag() {
                    return this._smfClient.nextCorrelationTag();
                }
                getCurrentStateName() {
                    const currentState = this.getCurrentState();
                    if (!currentState) return null;
                    if (currentState === this.getFinalState()) return SessionStateName.DISPOSED;
                    return this.getCurrentState().getName();
                }
                getStat(statType) {
                    if (this._sessionStatistics === undefined) {
                        return undefined;
                    }
                    if (statType === StatType.TX_TOTAL_DATA_MSGS) {
                        return this._sessionStatistics.getStat(StatType.TX_DIRECT_MSGS) + this._sessionStatistics.getStat(StatType.TX_PERSISTENT_MSGS) + this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_MSGS);
                    } else if (statType === StatType.TX_TOTAL_DATA_BYTES) {
                        return this._sessionStatistics.getStat(StatType.TX_DIRECT_BYTES) + this._sessionStatistics.getStat(StatType.TX_PERSISTENT_BYTES) + this._sessionStatistics.getStat(StatType.TX_NONPERSISTENT_BYTES);
                    }
                    return this._sessionStatistics.getStat(statType);
                }
                getTransportInfo() {
                    if (Check.nothing(this._transport)) {
                        return "Not connected.";
                    }
                    return this._transport.getInfoStr();
                }
                handleADCtrlMessage(message, header) {
                    const flowId = message.getFlowId();
                    const respText = header.pm_respstr;
                    const correlationTag = header.pm_corrtag;
                    const {
                        LOG_INFO,
                        LOG_DEBUG,
                        LOG_WARN
                    } = this.logger;
                    if (correlationTag) {
                        this.updateRxStats(message);
                        LOG_INFO(`Handle SMF response for correlationTag ${correlationTag}`);
                        const cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
                        if (Check.nothing(cancelledRequest)) {
                            return this.errorInFsm(`Cannot find matching request for response: ${respText}`, ErrorSubcode.INTERNAL_ERROR);
                        }
                        if (cancelledRequest.respRecvdCallback) {
                            cancelledRequest.respRecvdCallback(message, cancelledRequest);
                            return this;
                        }
                        LOG_DEBUG(`Dropping ADCTRL message due to mismatched correlation tag ${correlationTag}`);
                        this.incStat(StatType.RX_REPLY_MSG_DISCARD);
                        return this;
                    }
                    let flow;
                    const msgType = message.msgType;
                    const {
                        SMFAdProtocolMessageType
                    } = SMFLib;
                    switch (msgType) {
                      case SMFAdProtocolMessageType.CLIENTACK:
                      case SMFAdProtocolMessageType.CLIENTNACK:
                      case SMFAdProtocolMessageType.CLOSEPUBFLOW:
                        if (this._defaultPublisher.flowId === flowId) {
                            flow = this._defaultPublisher;
                        }
                        break;

                      default:
                        flow = this._consumers.getFlowById(flowId);
                    }
                    if (flow && !flow.disposed) {
                        this.updateRxStats(message, flow);
                        flow.handleUncorrelatedControlMessage(message);
                        return this;
                    }
                    const response = message.getResponse();
                    const rc = response ? `"${response.responseCode} ${response.responseString}" ` : "";
                    LOG_WARN(`Dropping ADCTRL.${SMFLib.SMFAdProtocolMessageType.describe(message.msgType)} ${rc}for unknown flow ${flowId}`);
                    this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                    return this;
                }
                handleADTrMessage(message, header) {
                    const {
                        LOG_DEBUG
                    } = this.logger;
                    const flowId = header.pm_ad_flowid;
                    const flow = this._consumers.getFlowById(flowId);
                    if (!flow || flow.disposed) {
                        LOG_DEBUG("Dropped incoming AD message for " + `${flow ? "disposed" : "unknown"} flow ID ${flowId}`);
                        this.updateRxStats(message, this._sessionStatistics);
                        this.incStat(StatType.RX_DISCARD_NO_MATCHING_CONSUMER);
                        return null;
                    }
                    this.updateRxStats(message, flow);
                    flow.handleDataMessage(message);
                    return flow;
                }
                handleApiSubscriptionTimeout(correlationTag, timeoutMsg) {
                    if (this._correlatedReqs[correlationTag] === undefined || this._correlatedReqs[correlationTag] === null) {
                        return;
                    }
                    const {
                        LOG_INFO,
                        LOG_ERROR
                    } = this.logger;
                    LOG_INFO(`${timeoutMsg || "Subscription timeout"} for correlationTag=${correlationTag}`);
                    try {
                        const result = delete this._correlatedReqs[correlationTag];
                        if (!result) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                        }
                    } catch (e) {
                        LOG_ERROR(`Cannot delete ctrl request ${correlationTag}, exception: ${e.message}`);
                    }
                }
                handleClientCtrlMessage(message, header) {
                    let correlationTag;
                    const {
                        LOG_INFO
                    } = this.logger;
                    this.updateRxStats(message);
                    if (message.msgType === SMFLib.SMFClientCtrlMessageType.LOGIN) {
                        correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
                        LOG_INFO("Handle SMF response for ClientCTRL Login");
                    } else {
                        correlationTag = header.pm_corrtag;
                        LOG_INFO(`Handle SMF response for correlationTag ${correlationTag}`);
                    }
                    const cancelledRequest = this.cancelOutstandingCorrelatedReq(correlationTag);
                    if (Check.nothing(cancelledRequest)) {
                        const respText = header.pm_respstr;
                        return this.errorInFsm(`Cannot find matching request for response: ${respText}`, ErrorSubcode.INTERNAL_ERROR);
                    } else if (cancelledRequest.respRecvdCallback) {
                        return cancelledRequest.respRecvdCallback(message);
                    }
                    LOG_INFO(`Dropping ClientCtrl message due to mismatched correlation tag ${correlationTag}`);
                    return this.incStat(StatType.RX_REPLY_MSG_DISCARD);
                }
                handleClientCtrlResponse(clientCtrlMsg) {
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.TRANSPORT_PROTOCOL_CLIENTCTRL
                    });
                    sEvent.smfMsg = clientCtrlMsg;
                    this.processEvent(sEvent);
                }
                handleClientCtrlTimeout() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO("ClientCtrl timeout for session");
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.DOWNGRADE_TIMEOUT
                    });
                    this.processEvent(sEvent);
                }
                handleConnectTimeout() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    LOG_INFO("Connection timeout. Disconnecting");
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.CONNECT_TIMEOUT
                    });
                    this.processEvent(sEvent);
                }
                handleUpdatePropertyTimeout(correlationTag, timeoutMsg) {
                    const {
                        LOG_ERROR
                    } = this.logger;
                    try {
                        const result = delete this._correlatedReqs[correlationTag];
                        if (!result) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                        }
                    } catch (e) {
                        LOG_ERROR(`Cannot delete ctrl request ${correlationTag}, exception: ${e.message}`);
                    }
                    const sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, timeoutMsg, null, ErrorSubcode.TIMEOUT, null, null);
                    this.sendEvent(sessionEvent);
                }
                handleRejectedTrMessage(header) {
                    const respCode = header.pm_respcode;
                    const topicNameRaw = header.pm_tr_topicname_bytes;
                    const topicName = topicNameRaw ? topicNameRaw.replace(/\0/g, "") : "";
                    const respText = header.pm_respstr;
                    const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                    this.emitSessionEvent(SessionEvent.build(SessionEventCode.REJECTED_MESSAGE_ERROR, respText, respCode, errorSubcode, null, `Topic: ${topicName}`));
                }
                handleSMFMessage(message) {
                    try {
                        const header = message.smfHeader;
                        if (header.discardMessage) {
                            if (this._sessionStatistics) {
                                this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                            }
                            return null;
                        }
                        switch (header.smf_protocol) {
                          case SMFLib.SMFProtocol.TRMSG:
                            if (header.smf_adf) {
                                return this.handleADTrMessage(message, header);
                            }
                            this.updateRxStats(message, this._sessionStatistics);
                            return header.pm_respcode === 0 ? this._session.handleDataMessage(message) : this.handleRejectedTrMessage(header);

                          case SMFLib.SMFProtocol.ADCTRL:
                            return this.handleADCtrlMessage(message, header);

                          case SMFLib.SMFProtocol.CLIENTCTRL:
                            return this.handleClientCtrlMessage(message, header);

                          case SMFLib.SMFProtocol.SMP:
                            return this.handleSMPMessage(message, header);

                          case SMFLib.SMFProtocol.KEEPALIVE:
                          case SMFLib.SMFProtocol.KEEPALIVEV2:
                            return null;

                          default:
                            return this.handleUnknownProtocolMessage(message, header);
                        }
                    } catch (e) {
                        const {
                            LOG_ERROR
                        } = this.logger;
                        LOG_ERROR(`Exception in handleSMFMessage, exception: ${e.stack}`);
                        return this.errorInFsm(`Exception in handleSMFMessage: ${e.message}`, e.subcode || ErrorSubcode.INTERNAL_ERROR, e);
                    }
                }
                handleSMFParseError(transportError) {
                    return this.errorInFsm(transportError, ErrorSubcode.PROTOCOL_ERROR);
                }
                handleSMPMessage(message, header) {
                    this.updateRxStats(message);
                    const cancelledRequest = this.cancelOutstandingCorrelatedReq(header.pm_corrtag || "");
                    if (Check.nothing(cancelledRequest) || Check.nothing(cancelledRequest.respRecvdCallback)) {
                        const sEvent = new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_PROTOCOL_SMP
                        });
                        sEvent.smfMsg = message;
                        return this.processEvent(sEvent);
                    }
                    return cancelledRequest.respRecvdCallback(message, cancelledRequest);
                }
                handleSubscriptionUpdateError(respCode, respText, subscriptionStr, request, confirm) {
                    const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                    if (!(errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND)) {
                        this.removeFromSubscriptionCache(subscriptionStr);
                    }
                    this._session.handleSubscriptionUpdateError(respCode, respText, subscriptionStr, request, confirm);
                }
                handleSubscriptionTimeout(correlationTag) {
                    const {
                        LOG_ERROR
                    } = this.logger;
                    try {
                        const result = delete this._correlatedReqs[correlationTag];
                        if (!result) {
                            LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`);
                        }
                    } catch (e) {
                        LOG_ERROR(`Cannot delete ctrl request ${correlationTag}`, e);
                    }
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.SUBSCRIBE_TIMEOUT
                    });
                    this.processEvent(sEvent);
                }
                handleTransportEvent(transportEvent) {
                    const {
                        LOG_INFO,
                        LOG_WARN
                    } = this.logger;
                    const infoStr = transportEvent.getInfoStr() || "";
                    LOG_INFO(`Receive transport event: ${transportEvent}`);
                    let sEvent;
                    switch (transportEvent.getTransportEventCode()) {
                      case TransportLib.TransportSessionEventCode.UP_NOTICE:
                        sEvent = new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_UP
                        });
                        sEvent.sessionId = transportEvent.getSessionId();
                        this.processEvent(sEvent);
                        break;

                      case TransportLib.TransportSessionEventCode.DESTROYED_NOTICE:
                        sEvent = new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_DESTROYED
                        });
                        sEvent.sessionId = transportEvent.getSessionId();
                        sEvent.eventText = infoStr;
                        sEvent.errorSubcode = transportEvent.getSubcode();
                        sEvent.eventReason = transportEvent;
                        this._smfClient = null;
                        this._transport = null;
                        this.processEvent(sEvent);
                        break;

                      case TransportLib.TransportSessionEventCode.CAN_ACCEPT_DATA:
                        this.GuaranteedFlowControlledRelief();
                        sEvent = new SessionFSMEvent({
                            name: SessionEventName.TRANSPORT_CAN_ACCEPT_DATA
                        });
                        sEvent.sessionId = transportEvent.getSessionId();
                        this.processEvent(sEvent);
                        break;

                      case TransportLib.TransportSessionEventCode.SEND_ERROR:
                        sEvent = new SessionFSMEvent({
                            name: SessionEventName.SEND_ERROR
                        });
                        sEvent.sessionId = transportEvent.getSessionId();
                        sEvent.eventText = transportEvent.getInfoStr();
                        sEvent.errorSubcode = transportEvent.getSubcode();
                        sEvent.eventReason = transportEvent;
                        this.processEvent(sEvent);
                        break;

                      case TransportLib.TransportSessionEventCode.DATA_DECODE_ERROR:
                      case TransportLib.TransportSessionEventCode.PARSE_FAILURE:
                        return this.errorInFsm(transportEvent.getInfoStr(), transportEvent.getSubcode());

                      default:
                        LOG_WARN("Received unknown transport session event", transportEvent);
                    }
                    return true;
                }
                handleUnknownProtocolMessage(message, header) {
                    const {
                        LOG_INFO,
                        LOG_ERROR
                    } = this.logger;
                    this.updateRxStats(message);
                    if (header && header.smf_protocol === SMFLib.SMFProtocol.TSESSION) {
                        LOG_ERROR(`Received transport session message instead of SMF message, protocol 0x${formatHexString(header.smf_protocol)}`);
                        LOG_ERROR(`Transport MessageType=${message.messageType}, target sessionId=${formatHexString(message.sessionId)}`);
                        return this.errorInFsm("Received message with unknown protocol", ErrorSubcode.PARSE_FAILURE);
                    }
                    if (this._sessionStatistics) {
                        this._sessionStatistics.incStat(StatType.RX_DISCARD_SMF_UNKNOWN_ELEMENT);
                    }
                    LOG_INFO(`Drop message with unknown protocol 0x${formatHexString(header.smf_protocol)}`);
                    return null;
                }
                incStat(statType, value) {
                    return this._sessionStatistics ? this._sessionStatistics.incStat(statType, value) : undefined;
                }
                initTransport() {
                    const {
                        LOG_INFO
                    } = this.logger;
                    const host = this._currentHost;
                    LOG_INFO(`Creating transport session ${host}`);
                    this._kaStats = {
                        lastMsgWritten: 0,
                        lastBytesWritten: 0
                    };
                    this._smfClient = new TransportLib.SMFClient(rxData => this.handleSMFMessage(rxData), rxError => this.handleSMFParseError(rxError), this);
                    this._transport = TransportLib.TransportFactory.createTransport(host, transportEvent => this.handleTransportEvent(transportEvent), this._smfClient, this._sessionProperties.clone(), () => this.sessionIdHex);
                    this.injectTransportInterceptor(this._transportInterceptor);
                }
                injectTransportInterceptor(interceptor) {
                    this._transportInterceptor = interceptor;
                    if (this._transport) {
                        this._transport.setInterceptor(interceptor);
                    }
                }
                keepAliveTimeout() {
                    const {
                        LOG_TRACE,
                        LOG_DEBUG,
                        LOG_INFO
                    } = this.logger;
                    LOG_TRACE("KeepAlive timeout");
                    if (this._keepAliveCounter >= this._sessionProperties.keepAliveIntervalsLimit) {
                        LOG_INFO(`Exceed maximum keep alive intervals limit ${this._sessionProperties.keepAliveIntervalsLimit}`);
                        LOG_DEBUG("Stop keep alive timer");
                        if (this._keepAliveTimer) {
                            clearInterval(this._keepAliveTimer);
                        }
                        return this.errorInFsm("Exceed maximum keep alive intervals limit", ErrorSubcode.KEEP_ALIVE_FAILURE);
                    }
                    LOG_TRACE("About to send keep alive");
                    const clientStats = this._transport.getClientStats();
                    const prestatMsgWritten = clientStats.msgWritten;
                    const prestatBytesWritten = clientStats.bytesWritten;
                    const kaMsg = new SMFLib.KeepAliveMessage();
                    const returnCode = this.send(kaMsg, null, true);
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        return this.errorInFsm("Cannot send keep alive message", ErrorSubcode.KEEP_ALIVE_FAILURE);
                    }
                    if (this._kaStats.lastMsgWritten === prestatMsgWritten && this._kaStats.lastBytesWritten < prestatBytesWritten) {
                        LOG_DEBUG("Keep alive sent", "Not incrementing keep alive counter due to large message send", `KA count = ${this._keepAliveCounter}`);
                    } else {
                        this._keepAliveCounter++;
                        LOG_TRACE(`Last message written: ${this._kaStats.lastMsgWritten}`);
                        LOG_TRACE(`Last bytes written: ${this._kaStats.lastBytesWritten}`);
                        LOG_TRACE(`Keep alive sent, increment keep alive counter, keep alive count = ${this._keepAliveCounter}`);
                    }
                    this._kaStats.lastBytesWritten = clientStats.bytesWritten;
                    this._kaStats.lastMsgWritten = clientStats.msgWritten;
                    return true;
                }
                prepareAndSendMessage(message) {
                    if (message instanceof Message) {
                        let returnCode;
                        const deliveryMode = message.getDeliveryMode();
                        switch (deliveryMode) {
                          case MessageDeliveryModeType.DIRECT:
                            if (!this._transport) return;
                            message._payload_is_memoized = false;
                            message._memoized_csumm = null;
                            message._memoized_payload = null;
                            returnCode = this.sendToTransport(message);
                            break;

                          case MessageDeliveryModeType.PERSISTENT:
                          case MessageDeliveryModeType.NON_PERSISTENT:
                            if (!this._defaultPublisher) {
                                const reason = this._session.adLocallyDisabled ? "locally disabled" : "remotely unsupported";
                                throw new OperationError("Session does not provide Guaranteed Message Publish capability", ErrorSubcode.GM_UNAVAILABLE, reason);
                            } else {
                                if (this._gmSendDisallowed) this._gmSendDisallowed();
                                returnCode = this._defaultPublisher.prepareAdMessageAndSend(message);
                            }
                            break;

                          default:
                            {
                                const {
                                    LOG_ERROR
                                } = this.logger;
                                LOG_ERROR("Unhandled message delivery mode", MessageDeliveryModeType.describe(deliveryMode));
                            }
                        }
                        if (returnCode !== TransportLib.TransportReturnCode.OK) {
                            if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
                                this._userBackpressured = true;
                                throw new OperationError("Cannot send message - no space in transport", ErrorSubcode.INSUFFICIENT_SPACE, TransportLib.TransportReturnCode.describe(returnCode));
                            }
                            this.setCurrentError(new OperationError("Cannot send message", ErrorSubcode.INVALID_OPERATION, TransportLib.TransportReturnCode.describe(returnCode)));
                            this.processEvent(new SessionFSMEvent({
                                name: SessionEventName.EXCEPTION
                            }));
                        }
                    }
                }
                GuaranteedFlowControlledRelief() {
                    if (this._defaultPublisher) {
                        this._defaultPublisher.processFSMEvent(new PublisherLib.PublisherFSMEvent({
                            name: PublisherLib.PublisherFSMEventNames.CAN_SEND
                        }));
                    }
                }
                reapplySubscriptions() {
                    const {
                        LOG_INFO,
                        LOG_DEBUG
                    } = this.logger;
                    const {
                        SolclientFactory: {
                            createTopicDestination
                        }
                    } = SolclientFactoryLib;
                    LOG_INFO(`Reapplying subscriptions, count=${this._subscriptionCacheKeys.length}`);
                    if (!this._subscriptionCacheKeys) {
                        return true;
                    }
                    try {
                        while (this._subscriptionCacheKeys.length) {
                            const key = this._subscriptionCacheKeys.shift();
                            const requestConfirmation = this._subscriptionCacheKeys.length === 0;
                            const topicDestination = createTopicDestination(key);
                            const rc = this.sendSubscribe(topicDestination, requestConfirmation, null, this._sessionProperties.readTimeoutInMsecs, null);
                            if (rc !== TransportLib.TransportReturnCode.OK) {
                                this.errorInFsm(`Error occurred sending subscription: ${TransportLib.TransportReturnCode.describe(rc)}`, ErrorSubcode.INTERNAL_ERROR);
                            }
                        }
                    } catch (e) {
                        if (e instanceof OperationError && e.subcode === ErrorSubcode.INSUFFICIENT_SPACE) {
                            LOG_DEBUG("Apply subscriptions blocked due to insufficient space, wait for can accept data event");
                            return false;
                        }
                        this.errorInFsm(`Unexpected expection occurred while reapplying subscriptions: ${e}`, e.subcode || ErrorSubcode.INTERNAL_ERROR, e);
                    }
                    return true;
                }
                removeFromSubscriptionCache(topic) {
                    if (Check.nothing(topic) || !this._subscriptionCache) {
                        return null;
                    }
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    const key = topic instanceof Destination ? topic.name : topic;
                    LOG_DEBUG(`Remove subscription ${key}`);
                    const sub = this._subscriptionCache[key];
                    if (sub === undefined || sub === null) {
                        return null;
                    }
                    try {
                        const result = delete this._subscriptionCache[key];
                        if (!result) {
                            LOG_ERROR(`Cannot remove subscription ${key}`);
                        } else {
                            this._subscriptionCacheCount--;
                        }
                    } catch (e) {
                        LOG_ERROR(`Cannot remove subscription ${key}`, e);
                    }
                    return sub;
                }
                reset() {
                    this.resetStats();
                    this.sessionId = null;
                    this._keepAliveTimer = null;
                    this.resetKeepAliveCounter();
                    this._correlatedReqs = {};
                    this._disposed = false;
                    this._smfClient = null;
                    this._kaStats = {
                        lastMsgWritten: 0,
                        lastBytesWritten: 0
                    };
                    this._subscriptionCache = null;
                    this._subscriptionCacheKeys = null;
                    this._subscriptionCacheCount = 0;
                    if (this._sessionProperties.reapplySubscriptions) {
                        this._subscriptionCache = {};
                    }
                    this._eventCode = null;
                    this._responseCode = null;
                    this.eventText = null;
                    this.errorSubcode = null;
                    this.eventReason = null;
                }
                resetKeepAliveCounter() {
                    this._keepAliveCounter = 0;
                }
                resetStats() {
                    return this._sessionStatistics ? this._sessionStatistics.resetStats() : undefined;
                }
                scheduleKeepAlive() {
                    const {
                        LOG_DEBUG,
                        LOG_ERROR
                    } = this.logger;
                    const {
                        keepAliveIntervalInMsecs
                    } = this._sessionProperties;
                    if (keepAliveIntervalInMsecs === 0) {
                        return;
                    }
                    if (this._keepAliveTimer) {
                        clearInterval(this._keepAliveTimer);
                    }
                    this._keepAliveTimer = setInterval(() => {
                        try {
                            this.keepAliveTimeout();
                        } catch (e) {
                            LOG_ERROR("Error occurred in keepAliveTimeout", e);
                        }
                    }, keepAliveIntervalInMsecs);
                    LOG_DEBUG(`Create Keepalive timer with interval: ${keepAliveIntervalInMsecs}ms`);
                }
                send(message, statTarget = this._sessionStatistics, forceAllowEnqueue = false) {
                    try {
                        return this.sendToTransport(message, statTarget, forceAllowEnqueue);
                    } catch (ex) {
                        const {
                            LOG_TRACE
                        } = this.logger;
                        LOG_TRACE(`Error sending message: ${ex.message}: ${ex.stack}`);
                        this.errorInFsm(`Send operation failed: ${ex.message}`, ex.subcode || ErrorSubcode.CONNECTION_ERROR);
                    }
                    return TransportLib.TransportReturnCode.CONNECTION_ERROR;
                }
                sendToTransport(message, statTarget = this._sessionStatistics, forceAllowEnqueue = false) {
                    let returnCode = TransportLib.TransportReturnCode.CONNECTION_ERROR;
                    if (!this._transport) {
                        throw new OperationError("Transport has been destroyed", ErrorSubcode.INTERNAL_ERROR);
                    }
                    const content = SMFLib.Codec.Encode.encodeCompoundMessage(message);
                    returnCode = this._transport.send(content, forceAllowEnqueue);
                    switch (returnCode) {
                      case TransportLib.TransportReturnCode.OK:
                        this.updateTxStats(message, statTarget);
                        break;

                      case TransportLib.TransportReturnCode.NO_SPACE:
                        if (!forceAllowEnqueue) {
                            break;
                        }

                      default:
                        throw new OperationError(`Transport returned ${TransportLib.TransportReturnCode.describe(returnCode)}`, ErrorSubcode.INTERNAL_ERROR);
                    }
                    return returnCode;
                }
                sendClientCtrlLogin() {
                    const {
                        LOG_INFO,
                        LOG_DEBUG,
                        LOG_TRACE
                    } = this.logger;
                    this._compressedTLS = this._sessionProperties.compressionLevel > 0 && this._currentHost.match(/tcps:/i) !== null;
                    this._plaintextTLS = this._currentHost.match(/tcps:/i) !== null && this._sessionProperties.sslConnectionDowngradeTo === SslDowngrade.PLAINTEXT;
                    LOG_TRACE(`sendClientLogin plaintextTLS: ${this._plaintextTLS} _compressedTLS: ${this._compressedTLS}`);
                    const clientCtrlMsg = SMFLib.ClientCtrlMessage.getLogin(this._sessionProperties, this._compressedTLS, this._plaintextTLS);
                    const returnCode = this.send(clientCtrlMsg);
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        this._responseCode = null;
                        this.eventReason = null;
                        if (returnCode === TransportLib.TransportReturnCode.NO_SPACE) {
                            this.eventText = "Cannot send client control - no space in transport";
                            this.errorSubcode = ErrorSubcode.INSUFFICIENT_SPACE;
                        } else {
                            LOG_INFO(`Cannot send client ctrl, return code
          ${TransportLib.TransportReturnCode.describe(returnCode)}`);
                            this.eventText = "Cannot send client ctrl";
                            this.errorSubcode = ErrorSubcode.INVALID_OPERATION;
                        }
                    } else {
                        const correlationTag = TransportLib.SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG;
                        LOG_INFO(`Using internally correlationTag=${correlationTag} for tracking ClientCTRL Login`);
                        this.enqueueOutstandingCorrelatedReq(correlationTag, null, null, null, rxMsgObj => this.handleClientCtrlResponse(rxMsgObj));
                        LOG_DEBUG("Sent client ctrl");
                    }
                    return returnCode;
                }
                sendSubscribe(topic, requestConfirmation, correlationKey, requestTimeout, respRecvdCallback) {
                    const {
                        LOG_INFO,
                        LOG_DEBUG
                    } = this.logger;
                    assert(topic instanceof Destination, "sendSubscribe requires a Destination, not a string");
                    LOG_DEBUG("Sending subscribe: ", topic, requestConfirmation, correlationKey);
                    const correlationTag = this.getCorrelationTag();
                    const smpMsg = SMFLib.SMPMessage.getSubscriptionMessage(correlationTag, topic, true, requestConfirmation);
                    assert(smpMsg.encodedUtf8Subscription, "Encoded SMP message was invalid");
                    const returnCode = this.send(smpMsg);
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        LOG_INFO("Subscribe failed", TransportLib.TransportReturnCode.describe(returnCode));
                        return returnCode;
                    }
                    if (requestConfirmation) {
                        this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleSubscriptionTimeout(correlationTag), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                    }
                    return returnCode;
                }
                sendUpdateProperty(mutableSessionProperty, newValue, correlationKey, requestTimeout, respRecvdCallback) {
                    const correlationTag = this._smfClient.nextCorrelationTag();
                    const smpMsg = SMFLib.ClientCtrlMessage.getUpdate(mutableSessionProperty, newValue, correlationTag);
                    const returnCode = this.send(smpMsg);
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        return returnCode;
                    }
                    this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleUpdatePropertyTimeout(correlationTag), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                    return returnCode;
                }
                setClientCtrlTimer() {
                    this.clearClientCtrlTimer();
                    this._clientCtrlTimer = setTimeout(() => this.handleClientCtrlTimeout(), this._sessionProperties.transportDowngradeTimeoutInMsecs);
                }
                setConnectTimer() {
                    this.clearConnectTimer();
                    this._connectTimer = setTimeout(() => this.handleConnectTimeout(), this._sessionProperties.connectTimeoutInMsecs);
                }
                setCurrentError(source) {
                    const target = this._currentError || {};
                    const {
                        LOG_TRACE
                    } = this.logger;
                    Object.keys(source).forEach(key => {
                        if (source[key] === null || source[key] === undefined) return false;
                        if (target[key] !== null && target[key] !== undefined) {
                            LOG_TRACE(`Attempt to overwrite property {key=${key}, current value=${target[key]}, incoming value=${source[key]}}`);
                            return false;
                        }
                        target[key] = source[key];
                        return true;
                    });
                    this._currentError = target;
                }
                subscriptionUpdate(subject, requestConfirmation, correlationKey, requestTimeout, requestType, respRecvdCallback) {
                    const error = this.checkSessionDestinationCapability(subject);
                    if (error) {
                        throw error;
                    }
                    const timeoutMsg = SubscriptionUpdateTimeoutMessages[requestType] || SubscriptionUpdateTimeoutMessages.default;
                    const isSMP = requestType !== SessionRequestType.REMOVE_DTE_SUBSCRIPTION;
                    const add = requestType === SessionRequestType.ADD_SUBSCRIPTION || requestType === SessionRequestType.ADD_P2PINBOX;
                    const correlationTag = this.getCorrelationTag();
                    const generateMessage = isSMP ? SMFLib.SMPMessage.getSubscriptionMessage : SMFLib.AdProtocolMessage.getDTEUnsubscribeMessage;
                    const msg = generateMessage(correlationTag, subject, add, requestConfirmation);
                    const returnCode = this.send(msg);
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        return returnCode;
                    }
                    if (requestConfirmation) {
                        this.enqueueOutstandingCorrelatedReq(correlationTag, () => this.handleApiSubscriptionTimeout(correlationTag, timeoutMsg), requestTimeout || this._sessionProperties.readTimeoutInMsecs, correlationKey, respRecvdCallback);
                    }
                    if (requestType === SessionRequestType.ADD_SUBSCRIPTION && this._sessionProperties.reapplySubscriptions) {
                        this.addToSubscriptionCache(subject);
                    } else if (requestType === SessionRequestType.REMOVE_SUBSCRIPTION && this._sessionProperties.reapplySubscriptions) {
                        this.removeFromSubscriptionCache(subject);
                    }
                    return returnCode;
                }
                queueSubscriptionUpdate(subject, queue, requestTimeout, add, respRecvdCallback) {
                    const timeoutMsg = add ? SubscriptionUpdateTimeoutMessages[SessionRequestType.ADD_SUBSCRIPTION] : SubscriptionUpdateTimeoutMessages[SessionRequestType.REMOVE_SUBSCRIPTION];
                    const correlationTag = this.getCorrelationTag();
                    const msg = SMFLib.SMPMessage.getQueueSubscriptionMessage(correlationTag, subject, queue, add);
                    const returnCode = this.send(msg);
                    if (returnCode !== TransportLib.TransportReturnCode.OK) {
                        return returnCode;
                    }
                    this.enqueueOutstandingCorrelatedReq(correlationTag, () => {
                        const origReq = this._correlatedReqs[correlationTag];
                        this.handleApiSubscriptionTimeout(correlationTag, timeoutMsg);
                        respRecvdCallback(null, origReq);
                    }, requestTimeout || this._sessionProperties.readTimeoutInMsecs, null, respRecvdCallback);
                    return returnCode;
                }
                updateRxStats(smfMessage, target = this._sessionStatistics) {
                    if (!target) {
                        return;
                    }
                    const smfHeader = smfMessage.smfHeader;
                    if (!smfHeader) {
                        return;
                    }
                    const deliveryMode = smfHeader.pm_deliverymode || 0;
                    const msgStatKey = STAT_RX_BYMODE_MSGS[deliveryMode];
                    const bytesStatKey = STAT_RX_BYMODE_BYTES[deliveryMode];
                    const msgLength = smfHeader.messageLength;
                    switch (smfHeader.smf_protocol) {
                      case SMFLib.SMFProtocol.TRMSG:
                        if (smfHeader.pm_respcode === 0) {
                            target.incStat(StatType.RX_TOTAL_DATA_MSGS);
                            target.incStat(msgStatKey);
                            target.incStat(StatType.RX_TOTAL_DATA_BYTES, msgLength);
                            target.incStat(bytesStatKey, msgLength);
                            if (smfHeader.smf_di) {
                                target.incStat(StatType.RX_DISCARD_MSG_INDICATION);
                            }
                        }
                        break;

                      case SMFLib.SMFProtocol.CLIENTCTRL:
                      case SMFLib.SMFProtocol.SMP:
                      case SMFLib.SMFProtocol.KEEPALIVE:
                      case SMFLib.SMFProtocol.KEEPALIVEV2:
                      case SMFLib.SMFProtocol.ADCTRL:
                        target.incStat(StatType.RX_CONTROL_MSGS);
                        target.incStat(StatType.RX_CONTROL_BYTES, msgLength);
                        break;

                      default:
                    }
                }
                updateTxStats(smfMessage, target = this._sessionStatistics) {
                    if (!target) {
                        return;
                    }
                    if (smfMessage.getReplyTo !== undefined && smfMessage.getReplyTo()) {
                        target.incStat(StatType.TX_REQUEST_SENT);
                    }
                    const smfHeader = smfMessage.smfHeader;
                    if (!smfHeader) {
                        return;
                    }
                    const deliveryMode = smfHeader.pm_deliverymode || 0;
                    let msgStatKey = STAT_TX_BYMODE_MSGS[deliveryMode];
                    let bytesStatKey = STAT_TX_BYMODE_BYTES[deliveryMode];
                    if (deliveryMode !== MessageDeliveryModeType.DIRECT) {
                        if (smfMessage.isRedelivered()) {
                            msgStatKey = STAT_TX_BYMODE_REDELIVERED[deliveryMode];
                            bytesStatKey = STAT_TX_BYMODE_BYTES_REDELIVERED[deliveryMode];
                        }
                    }
                    const msgLength = smfHeader.messageLength;
                    switch (smfHeader.smf_protocol) {
                      case SMFLib.SMFProtocol.TRMSG:
                        target.incStat(msgStatKey);
                        target.incStat(bytesStatKey, msgLength);
                        break;

                      case SMFLib.SMFProtocol.CLIENTCTRL:
                      case SMFLib.SMFProtocol.SMP:
                      case SMFLib.SMFProtocol.KEEPALIVE:
                      case SMFLib.SMFProtocol.KEEPALIVEV2:
                      case SMFLib.SMFProtocol.ADCTRL:
                        target.incStat(StatType.TX_CONTROL_MSGS);
                        target.incStat(StatType.TX_CONTROL_BYTES, msgLength);
                        break;

                      default:
                    }
                }
                updateReadonlySessionProps(clientCtrlRespMsg) {
                    const props = this._sessionProperties;
                    props._setVpnNameInUse(clientCtrlRespMsg.getVpnNameInUseValue() || "");
                    const oldVirtualRouterName = props.virtualRouterName;
                    const newVirtualRouterName = clientCtrlRespMsg.getVridInUseValue() || "";
                    props._setVirtualRouterName(newVirtualRouterName);
                    if (oldVirtualRouterName !== "" && oldVirtualRouterName !== newVirtualRouterName) {
                        this.handleVirtualRouterNameChange(oldVirtualRouterName, newVirtualRouterName);
                    }
                    props._setP2pInboxBase(clientCtrlRespMsg.getP2PTopicValue() || "");
                    props._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(props.p2pInboxBase));
                    this._session.updateCapabilities(clientCtrlRespMsg.getRouterCapabilities());
                    const gmCap = this._session._getCapability(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
                    this._gmSendDisallowed = typeof gmCap === "boolean" && !gmCap ? () => {
                        throw new OperationError("Sending guaranteed message is not allowed by router for this client", ErrorSubcode.INVALID_OPERATION, null);
                    } : null;
                }
                handleVirtualRouterNameChange(oldName, newName) {
                    if (this._consumers) {
                        this._consumers.flows.forEach(consumer => consumer.onVRNChanged());
                        this._consumers.reconnectingFlows.forEach(consumer => consumer.onVRNChanged());
                    }
                    this.emitSessionEvent(SessionEvent.build(SessionEventCode.VIRTUALROUTER_NAME_CHANGED, `Virtual router name is changed from ${oldName} to ${newName}`, null, 0, null, null));
                }
                get sessionIdHex() {
                    return this.sessionId && formatHexString(this.sessionId) || "N/A";
                }
                updateTransportCompression(callback) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("updateTransportCompression called. " + `plaintextTLS: ${this._plaintextTLS} _compressedTLS: ${this._compressedTLS}`);
                    if (this._plaintextTLS) {
                        TransportLib.TransportFactory.severTls(this._transport, this._compressedTLS, callback);
                        return null;
                    }
                    if (this._compressedTLS) {
                        const newTransport = TransportLib.TransportFactory.startCompression(this._transport);
                        return newTransport;
                    }
                    return this._transport;
                }
            }
            module.exports.SessionFSM = SessionFSM;
        },
        "./modules/solclient-session/lib/session-operations.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SessionOperation = {
                CONNECT: "CONNECT",
                DISCONNECT: "DISCONNECT",
                CTRL: "CTRL",
                SEND: "SEND",
                QUERY_OPERATION: "QUERY_OPERATION"
            };
            module.exports.SessionOperation = Enum.new(SessionOperation);
        },
        "./modules/solclient-session/lib/session-properties-validator.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const PublisherLib = __webpack_require__("./modules/solclient-message-publisher/api.js");
            const SessionPropertiesLib = __webpack_require__("./modules/solclient-session/lib/session-properties.js");
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                APIPropertiesValidators,
                parseURL
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                AuthenticationScheme
            } = __webpack_require__("./modules/solclient-session/lib/authentication-schemes.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LOG_WARN,
                LOG_INFO
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SslDowngrade
            } = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js");
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/api.js");
            const {
                validateInstance,
                valArrayIsMember,
                valArrayOfString,
                valBoolean,
                valLength,
                valNotEmpty,
                valNumber,
                valRange,
                valString,
                valStringOrArray
            } = APIPropertiesValidators;
            const ALLOWED_PROTOCOLS = [ "http:", "https:", "ws:", "wss:", "tcp:", "tcps:" ];
            function valClientName(typeDesc, instance, name) {
                const error = SMFLib.ClientCtrlMessage.validateClientName(instance[name], errorMessage => new OperationError(`${typeDesc} validation: Property '${name}': ${errorMessage}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                if (error) {
                    throw error;
                }
            }
            function valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull) {
                const val = instance[key];
                if (allowNull && val === null) return;
                if (typeof val !== "undefined" && !enumInstance.values.some(v => v === val)) {
                    throw new OperationError(`${typeDesc} validation: Property '${key}' must be a member of ${enumName}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                }
            }
            function valSslExcludedProtocols(typeDesc, instance, name) {
                const val = instance[name];
                if (Check.array(val)) {
                    if (val.length > 0) {
                        const supported = SessionPropertiesLib.SessionProperties.SUPPORTED_SSL_PROTOCOLS;
                        val.forEach(protocol => {
                            const prtcl = protocol.toLowerCase();
                            if (supported.indexOf(prtcl) < 0) {
                                throw new OperationError(`${typeDesc} validation: Property '${name}' contains unsupported protocol: ${protocol}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                        });
                    }
                }
            }
            function valSslCipherSuites(typeDesc, instance, name) {
                const val = instance[name];
                if (val && Check.string(val) && !Check.empty(val)) {
                    const ciphers = val.split(",");
                    const supported = SessionPropertiesLib.SessionProperties.SUPPORTED_CIPHER_SUITES;
                    ciphers.forEach(cipher => {
                        if (supported.indexOf(cipher.trim()) < 0) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' contains unsupported cipher suite: '${cipher}'`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    });
                }
            }
            function valSslTrustedCommonNameList(typeDesc, instance, name) {
                const val = instance[name];
                if (Check.something(val) && Check.array(val) && val.length > 16) {
                    throw new OperationError(`${typeDesc} validation: Property '${name}' length exceeds limit of 16`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                }
            }
            function valUrlList(typeDesc, instance, name) {
                const val = instance[name];
                const valArray = typeof val === "string" ? val.split(",") : val;
                if (!Check.array(valArray)) {
                    throw new OperationError(`${typeDesc} validation: Property '${name}' not an array or comma-delimited string`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                }
                valArray.forEach(el => {
                    let url = null;
                    try {
                        url = parseURL(el);
                    } catch (ex) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' contained an invalid URL: ${el}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (!Check.included(url.protocol, ALLOWED_PROTOCOLS)) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' contained a URL'${url.href}' with an invalid protocol: '${url.protocol}'`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                });
            }
            function isHttpTransport(transportProtocol) {
                return transportProtocol && (transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING || transportProtocol === TransportProtocol.HTTP_BINARY || transportProtocol === TransportProtocol.HTTP_BASE64);
            }
            function validatePropsSupportedByTransport(transportProtocol, nonHttpPropsSet) {
                if (nonHttpPropsSet.length > 0 && isHttpTransport(transportProtocol)) {
                    const propNames = nonHttpPropsSet.length <= 5 ? nonHttpPropsSet : nonHttpPropsSet.slice(0, 5);
                    throw new OperationError(`SessionProperties validation: properties that are not supported by transport protocol ${transportProtocol} have been set: ${propNames}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                }
            }
            function matchUrl(instance, name, regex, all) {
                const val = instance[name];
                if (val instanceof Array) {
                    const arrayLength = val.length;
                    for (let i = 0; i < arrayLength; i++) {
                        const currententry = val[i];
                        if (!all) {
                            if (Check.string(currententry) && currententry.match(regex)) {
                                return true;
                            }
                        } else if (all) {
                            if (!Check.string(currententry) || !currententry.match(regex)) {
                                return false;
                            }
                        }
                    }
                    if (!all) {
                        return false;
                    } else if (all) {
                        return true;
                    }
                }
                return Check.string(val) && val.match(regex);
            }
            function useSsl(instance, name, all) {
                return matchUrl(instance, name, /^(https|wss|tcps):/i, all);
            }
            const SessionPropertiesValidator = {
                validate(props) {
                    const v = validateInstance.bind(null, "SessionProperties", props);
                    v("url", [ valNotEmpty ], [ valStringOrArray ], [ valUrlList ]);
                    v("userName", [ valString ], [ valLength, 189 ]);
                    v("password", [ valString ], [ valLength, 128 ]);
                    v("clientName", [ valString ], [ valLength, 160 ], [ valClientName ]);
                    v("applicationDescription", [ valString ], [ valLength, 254 ]);
                    v("vpnName", [ valString ], [ valLength, 32 ]);
                    v("connectTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                    v("connectRetriesPerHost", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                    v("connectRetries", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                    v("reconnectRetries", [ valNumber ], [ valRange, -1, Number.MAX_VALUE ]);
                    v("reconnectRetryWaitInMsecs", [ valNumber ], [ valRange, 0, 6e4 ]);
                    v("readTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                    v("sendBufferMaxSize", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                    v("maxWebPayload", [ valNumber ], [ valRange, 100, Number.MAX_VALUE ]);
                    if (false) {}
                    v("generateSendTimestamps", [ valBoolean ]);
                    v("generateReceiveTimestamps", [ valBoolean ]);
                    v("includeSenderId", [ valBoolean ]);
                    v("keepAliveIntervalInMsecs", [ valNumber ], [ valRange, 0, Number.MAX_VALUE ]);
                    v("keepAliveIntervalsLimit", [ valNumber ], [ valRange, 3, Number.MAX_VALUE ]);
                    v("generateSequenceNumber", [ valBoolean ]);
                    v("subscriberLocalPriority", [ valNumber ], [ valRange, 1, 4 ]);
                    v("subscriberNetworkPriority", [ valNumber ], [ valRange, 1, 4 ]);
                    v("ignoreDuplicateSubscriptionError", [ valBoolean ]);
                    v("ignoreSubscriptionNotFoundError", [ valBoolean ]);
                    v("reapplySubscriptions", [ valBoolean ]);
                    v("noLocal", [ valBoolean ]);
                    v("transportDowngradeTimeoutInMsecs", [ valNumber ], [ valRange, 1, Number.MAX_VALUE ]);
                    v("idToken", [ valString ]);
                    v("accessToken", [ valString ]);
                    if (props.transportProtocol && props.webTransportProtocolList) {
                        throw new OperationError("SessionProperties validation: Property 'transportProtocol' and " + "'webTransportProtocolList' cannot be set at the same time", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (props.webTransportProtocolList !== null && props.webTransportProtocolList !== undefined) {
                        if (!Array.isArray(props.webTransportProtocolList)) {
                            throw new OperationError("Property 'webTransportProtocolList' must be an array if set", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (props.webTransportProtocolList.length === 0) {
                            throw new OperationError("Property 'webTransportProtocolList' must be non-empty if set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                    }
                    v("authenticationScheme", [ valIsMember, AuthenticationScheme, "AuthenticationScheme", false ]);
                    const useClientCert = props.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
                    if (!useSsl(props, "url", true) && useClientCert) {
                        throw new OperationError("SessionProperties validation: Property 'authenticationScheme' cannot be set to client certificate " + "for unsecured sessions", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (Check.equal(props.authenticationScheme, AuthenticationScheme.OAUTH2)) {
                        if (!useSsl(props, "url", true)) {
                            throw new OperationError(`SessionProperties validation: Property 'authenticationScheme' ${""}cannot be set to '${AuthenticationScheme.OAUTH2}' unless the ${""}session property 'url' is written to use a secure ${""}communication protocol like tcps or https.`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        if (Check.empty(props.idToken) && Check.empty(props.accessToken)) {
                            throw new OperationError(`SessionProperties validation: Property 'authenticationScheme' ${""}can be set to ${""}'${AuthenticationScheme.OAUTH2}' only if there ${""}is an accompanying token set as a session property. The ${""}token types that are ${""}supported for OAuth authentication are OAuth2.0 Access ${""}Tokens and OpenID Connect ID Tokens. To set an access token ${""}you can use the accessToken session property. To set an id ${""}you can use the idToken session property.`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                    } else if (!Check.empty(props.idToken) || !Check.empty(props.accessToken)) {
                        LOG_INFO(`SessionProperties validation: Property ${""}'authenticationScheme' must be set to ${""}'${AuthenticationScheme.OAUTH2}'in order to use either ${""} an OAUTH2 access token or an OpenID Connect ID token.`);
                    }
                    if (true) {
                        if (Check.something(props.transportProtocol) && props.transportProtocol !== TransportProtocol.WS_BINARY) {
                            throw new OperationError("SessionProperties validation: properties 'transportProtocol' " + "can only be WS_BINARY", ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (Check.something(props.webTransportProtocolList)) {
                            if (!Check.array(props.webTransportProtocolList)) {
                                throw new OperationError("SessionProperties validation: Property " + "'webTransportProtocolList' should be type Array", ErrorSubcode.PARAMETER_INVALID_TYPE);
                            }
                            if (props.webTransportProtocolList.length !== 1 || props.webTransportProtocolList[0] !== TransportProtocol.WS_BINARY) {
                                throw new OperationError("SessionProperties validation: properties " + "'webTransportProtocolList' can only contain element WS_BINARY", ErrorSubcode.PARAMETER_INVALID_TYPE);
                            }
                        }
                        v("sslExcludedProtocols", [ valArrayOfString ], [ valSslExcludedProtocols ]);
                        v("sslCipherSuites", [ valString ], [ valSslCipherSuites ]);
                        v("sslValidateCertificate", [ valBoolean ]);
                        if (props.sslValidateCertificate || useClientCert) {
                            v("sslTrustStores", [ valArrayOfString ]);
                            v("sslTrustedCommonNameList", [ valArrayOfString ], [ valSslTrustedCommonNameList ]);
                        }
                        if (useClientCert) {
                            v("sslPfx", [ valString ]);
                            v("sslPfxPassword", [ valString ]);
                            v("sslPrivateKey", [ valString ]);
                            v("sslPrivateKeyPassword", [ valString ]);
                            v("sslCertificate", [ valString ]);
                            const sslPfxSet = Check.something(props.sslPfx) && props.sslPfx.length;
                            const sslPrivateKeySet = Check.something(props.sslPrivateKey) && props.sslPrivateKey.length;
                            const sslCertSet = Check.something(props.sslCertificate) && props.sslCertificate.length;
                            if (!sslPfxSet && !sslPrivateKeySet && !sslCertSet) {
                                throw new OperationError("SessionProperties validation: " + "Either property 'sslPfx', or 'sslPrivateKey' and 'sslCertificate' " + "must be set when authenticationScheme is client certificate", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                            if (sslPfxSet && (sslPrivateKeySet || sslCertSet)) {
                                throw new OperationError("SessionProperties validation: " + "Property 'sslPfx' can only be set when 'sslPrivateKey' and 'sslCertificate' " + "are not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                            if (sslPrivateKeySet && !sslCertSet || !sslPrivateKeySet && sslCertSet) {
                                throw new OperationError("SessionProperties validation: " + "Property 'sslPrivateKey' and 'sslCertificate' " + "must be set at the same time", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                        }
                        v("compressionLevel", [ valNumber ], [ valRange, 0, 9 ]);
                        if (props.compressionLevel > 0) {
                            if (props.url instanceof Array) {
                                const allTcp = props.url.every(url => Check.string(url) && url.match(/tcps?:/i));
                                if (!allTcp) {
                                    throw new OperationError("SessionProperties validation: Property " + "'compressionLevel' is non-zero, " + "but not all URLs in the host list " + "support compression. (tcp:// or tcps:// expected)", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                                }
                            } else if (Check.string(props.url)) {
                                if (!props.url.match(/tcps?:/i)) {
                                    throw new OperationError("SessionProperties validation: Property " + "'compressionLevel' is non-zero, " + "but the url does not " + "support compression. (tcp:// or tcps:// expected)", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                                }
                            } else {
                                throw new OperationError("SessionProperties validation: Property" + "'url' must be string or array of strings." + ` instead got ${props.url} ` + `of type ${typeof props.url}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                        }
                        v("sslConnectionDowngradeTo", [ valIsMember, SslDowngrade, "SslDowngrade", false ]);
                    }
                    v("transportProtocol", [ valIsMember, TransportProtocol, "TransportProtocol", true ]);
                    v("webTransportProtocolList", [ valArrayIsMember, TransportProtocol, "TransportProtocol", true, false, false ]);
                    validatePropsSupportedByTransport(props.transportProtocol, props.nonHTTPTransportPropsSet);
                    if (props.publisherProperties) {
                        PublisherLib.MessagePublisherPropertiesValidator.validate(props.publisherProperties);
                    }
                    const recommendedMin = props.defaultConnectTimeoutInMsecs;
                    const connectTimeout = props.connectTimeoutInMsecs;
                    const transportCount = props.webTransportProtocolList ? props.webTransportProtocolList.length : 1;
                    if (transportCount > 1 && connectTimeout < recommendedMin) {
                        LOG_WARN(`Connect timeout of ${connectTimeout} msecs is less than default and recommended ` + `minimum of ${recommendedMin} msecs for current transport selection. Transport ` + "downgrades may not complete.");
                    }
                }
            };
            module.exports.SessionPropertiesValidator = SessionPropertiesValidator;
        },
        "./modules/solclient-session/lib/session-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const NodeSslConstants = __webpack_require__("constants");
            const PublisherLib = __webpack_require__("./modules/solclient-message-publisher/api.js");
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                AuthenticationScheme
            } = __webpack_require__("./modules/solclient-session/lib/authentication-schemes.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                LOG_WARN
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SslDowngrade
            } = __webpack_require__("./modules/solclient-session/lib/ssl-downgrades.js");
            function makeDefaults() {
                const {
                    MessagePublisherProperties
                } = PublisherLib;
                return {
                    _vpnNameInUse: "",
                    _virtualRouterName: "",
                    _p2pInboxInUse: "",
                    _p2pInboxBase: "",
                    _userIdentification: "",
                    _tpProtocolInUse: null,
                    _tpContentType: "text/plain",
                    _publisherProperties: new MessagePublisherProperties()
                };
            }
            const DEFAULT_CIPHER_SUITES = true ? [ "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-SHA384", "ECDHE-RSA-AES256-SHA", "AES256-GCM-SHA384", "AES256-SHA256", "AES256-SHA", "ECDHE-RSA-DES-CBC3-SHA", "DES-CBC3-SHA", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-SHA256", "ECDHE-RSA-AES128-SHA", "AES128-GCM-SHA256", "AES128-SHA256", "AES128-SHA" ].join(",") : 0;
            const SUPPORTED_CIPHER_SUITES = true ? [ "AES128-GCM-SHA256", "AES128-SHA", "AES128-SHA256", "AES256-GCM-SHA384", "AES256-SHA", "AES256-SHA256", "DES-CBC3-SHA", "ECDHE-RSA-AES128-GCM-SHA256", "ECDHE-RSA-AES128-SHA", "ECDHE-RSA-AES128-SHA256", "ECDHE-RSA-AES256-GCM-SHA384", "ECDHE-RSA-AES256-SHA", "ECDHE-RSA-AES256-SHA384", "ECDHE-RSA-DES-CBC3-SHA" ] : 0;
            const SUPPORTED_SSL_PROTOCOLS = true ? [ "tlsv1", "tlsv1.1", "tlsv1.2" ] : 0;
            class SessionPropertiesBrowser extends APIProperties {
                get transportProtocol() {
                    return Check.nothing(this._tpProtocol) ? null : this._tpProtocol;
                }
                set transportProtocol(newValue) {
                    this._tpProtocol = newValue;
                }
                get transportDowngradeTimeoutInMsecs() {
                    return Check.nothing(this._tpDowngradeTimeout) ? 3e3 : this._tpDowngradeTimeout;
                }
                set transportDowngradeTimeoutInMsecs(newValue) {
                    this._tpDowngradeTimeout = newValue;
                }
                get webTransportProtocolList() {
                    return Check.nothing(this._transportProtocolList) ? null : this._transportProtocolList;
                }
                set webTransportProtocolList(newValue) {
                    this._transportProtocolList = newValue;
                }
                get bufferedAmountQueryIntervalInMsecs() {
                    return Check.nothing(this._bufferedAmountQueryInterval) ? 100 : this._bufferedAmountQueryInterval;
                }
                set bufferedAmountQueryIntervalInMsecs(newValue) {
                    this._bufferedAmountQueryInterval = newValue;
                }
                get transportProtocolInUse() {
                    return this._tpProtocolInUse || null;
                }
                _setTransportProtocolInUse(value) {
                    this._tpProtocolInUse = value;
                }
                get webTransportProtocolInUse() {
                    return this._tpProtocolInUse || null;
                }
                _setWebTransportProtocolInUse(value) {
                    this._tpProtocolInUse = value;
                }
                get transportContentType() {
                    return this._tpContentType || "text/plain";
                }
                set transportContentType(newValue) {
                    this._tpContentType = newValue;
                }
                _lendsInspect() {
                    return {
                        bufferedAmountQueryIntervalInMsecs: this.bufferedAmountQueryIntervalInMsecs,
                        transportContentType: this.transportContentType,
                        transportDowngradeTimeoutInMsecs: this.transportDowngradeTimeoutInMsecs,
                        transportProtocol: this.transportProtocol,
                        transportProtocolInUse: this.transportProtocolInUse,
                        webTransportProtocolList: this.webTransportProtocolList
                    };
                }
            }
            class SessionPropertiesNode extends APIProperties {
                get transportProtocol() {
                    return this._tpProtocol;
                }
                set transportProtocol(value) {
                    this._tpProtocol = value;
                }
                get webTransportProtocolList() {
                    return this._transportProtocolList;
                }
                set webTransportProtocolList(value) {
                    this._transportProtocolList = value;
                }
                get transportDowngradeTimeoutInMsecs() {
                    return this._tpDowngradeTimeout || 864e5;
                }
                set transportDowngradeTimeoutInMsecs(value) {
                    this._tpDowngradeTimeout = value;
                }
                get transportProtocolInUse() {
                    return this._tpProtocolInUse;
                }
                _setTransportProtocolInUse(value) {
                    this._tpProtocolInUse = value;
                }
                get webTransportProtocolInUse() {
                    return this._tpProtocolInUse;
                }
                _setWebTransportProtocolInUse(value) {
                    this._tpProtocolInUse = value;
                }
                get transportContentType() {
                    return this._tpContentType;
                }
                set transportContentType(value) {
                    this._tpContentType = value;
                }
                get sslExcludedProtocols() {
                    return Check.nothing(this._sslExcludedProtocols) ? null : this._sslExcludedProtocols;
                }
                set sslExcludedProtocols(newValue) {
                    this._sslExcludedProtocols = newValue;
                }
                get sslCipherSuites() {
                    return Check.nothing(this._sslCipherSuites) ? DEFAULT_CIPHER_SUITES : this._sslCipherSuites;
                }
                set sslCipherSuites(newValue) {
                    this._sslCipherSuites = newValue;
                }
                get sslValidateCertificate() {
                    if (this._sslValidateCert === undefined) return process.env.NODE_TLS_REJECT_UNAUTHORIZED !== "0";
                    if (this._sslValidateCert === null) return true;
                    return this._sslValidateCert;
                }
                set sslValidateCertificate(newValue) {
                    this._sslValidateCert = newValue;
                }
                get sslTrustStores() {
                    return Check.nothing(this._sslTrustStores) ? null : this._sslTrustStores;
                }
                set sslTrustStores(newValue) {
                    this._sslTrustStores = newValue;
                }
                get sslTrustedCommonNameList() {
                    return Check.nothing(this._sslTrustedCNList) ? null : this._sslTrustedCNList;
                }
                set sslTrustedCommonNameList(newValue) {
                    this._sslTrustedCNList = newValue;
                }
                get sslPfx() {
                    return Check.nothing(this._sslPfx) ? "" : this._sslPfx;
                }
                set sslPfx(newValue) {
                    this._sslPfx = newValue;
                }
                get sslPfxPassword() {
                    return Check.nothing(this._sslPfxPasswd) ? "" : this._sslPfxPasswd;
                }
                set sslPfxPassword(newValue) {
                    this._sslPfxPasswd = newValue;
                }
                get sslPrivateKey() {
                    return Check.nothing(this._sslPrivateKey) ? "" : this._sslPrivateKey;
                }
                set sslPrivateKey(newValue) {
                    this._sslPrivateKey = newValue;
                }
                get sslPrivateKeyPassword() {
                    return Check.nothing(this._sslPrivateKeyPasswd) ? "" : this._sslPrivateKeyPasswd;
                }
                set sslPrivateKeyPassword(newValue) {
                    this._sslPrivateKeyPasswd = newValue;
                }
                get sslCertificate() {
                    return Check.nothing(this._sslCertificate) ? "" : this._sslCertificate;
                }
                set sslCertificate(newValue) {
                    this._sslCertificate = newValue;
                }
                get sslProtocol() {
                    return this._sslProtocol;
                }
                set sslProtocol(newValue) {
                    this._sslProtocol = newValue;
                }
                get compressionLevel() {
                    return Check.nothing(this._compressionLevel) ? 0 : this._compressionLevel;
                }
                set compressionLevel(newValue) {
                    this._compressionLevel = newValue;
                }
                get sslConnectionDowngradeTo() {
                    return Check.nothing(this._sslConnectionDowngradeTo) ? SslDowngrade.NONE : this._sslConnectionDowngradeTo;
                }
                set sslConnectionDowngradeTo(newValue) {
                    this._sslConnectionDowngradeTo = newValue;
                }
                _lendsInspect() {
                    return {
                        sslExcludedProtocols: this.sslExcludedProtocols,
                        sslCipherSuites: this.sslCipherSuites,
                        sslValidateCertificate: this.sslValidateCertificate,
                        sslTrustStores: this.sslTrustStores,
                        sslTrustedCommonNameList: this.sslTrustedCommonNameList,
                        sslPfx: this.sslPfx,
                        sslPfxPassword: this.sslPfxPassword ? "*****" : this.sslPfxPassword,
                        sslPrivateKey: this.sslPrivateKey,
                        sslPrivateKeyPassword: this.sslPrivateKeyPassword ? "*****" : this.sslPrivateKeyPassword,
                        sslCertificate: this.sslCertificate,
                        sslProtocol: this.sslProtocol,
                        compressionLevel: this.compressionLevel,
                        sslConnectionDowngradeTo: this.sslConnectionDowngradeTo
                    };
                }
            }
            const SessionPropertiesBase = true ? SessionPropertiesNode : 0;
            class SessionProperties extends SessionPropertiesBase {
                constructor(options) {
                    super(makeDefaults(), options);
                }
                get authenticationScheme() {
                    return Check.nothing(this._authScheme) ? AuthenticationScheme.BASIC : this._authScheme;
                }
                set authenticationScheme(newValue) {
                    this._authScheme = newValue;
                }
                get accessToken() {
                    return Check.empty(this._accessToken) ? "" : this._accessToken;
                }
                set accessToken(newValue) {
                    this._accessToken = newValue;
                }
                get idToken() {
                    return Check.empty(this._idToken) ? "" : this._idToken;
                }
                set idToken(newValue) {
                    this._idToken = newValue;
                }
                get issuerIdentifier() {
                    return Check.empty(this._issuerIdentifier) ? "" : this._issuerIdentifier;
                }
                set issuerIdentifier(newValue) {
                    if (!Check.type(newValue, "string")) {
                        LOG_WARN(`Failed to set issuer identifier because the pased value ${""}was not of type String. The passed issuer identifier ${""}must be of type String. Setting issuer identifier to ${""}default value empty string.`);
                        this._issuerIdentifier = "";
                    } else if (Check.empty(newValue)) {
                        LOG_WARN(`Failed to set the issuer identifier because the passed string was empty ${""}or null. The passed issuer identifier must not be empty or null. Setting ${""}issuer identifier to default value empty string.`);
                    } else {
                        this._issuerIdentifier = newValue;
                    }
                }
                get url() {
                    return Check.nothing(this._url) ? "" : this._url;
                }
                set url(newValue) {
                    this._url = newValue;
                }
                get password() {
                    return Check.nothing(this._password) ? "" : this._password;
                }
                set password(newValue) {
                    this._password = newValue;
                }
                get userName() {
                    return Check.nothing(this._userName) ? "" : this._userName;
                }
                set userName(newValue) {
                    this._userName = newValue;
                }
                get clientName() {
                    return Check.nothing(this._clientName) ? "" : this._clientName;
                }
                set clientName(newValue) {
                    this._clientName = newValue;
                }
                get applicationDescription() {
                    return Check.nothing(this._appDesc) ? "" : this._appDesc;
                }
                set applicationDescription(newValue) {
                    this._appDesc = newValue;
                }
                get vpnName() {
                    return Check.nothing(this._vpnName) ? "" : this._vpnName;
                }
                set vpnName(newValue) {
                    this._vpnName = newValue;
                }
                get vpnNameInUse() {
                    return Check.nothing(this._vpnNameInUse) ? "" : this._vpnNameInUse;
                }
                _setVpnNameInUse(value) {
                    this._vpnNameInUse = value;
                }
                get virtualRouterName() {
                    return Check.nothing(this._virtualRouterName) ? "" : this._virtualRouterName;
                }
                _setVirtualRouterName(value) {
                    this._virtualRouterName = value;
                }
                get connectTimeoutInMsecs() {
                    if (Check.nothing(this._connectTimeout)) {
                        return this.defaultConnectTimeoutInMsecs;
                    }
                    return this._connectTimeout;
                }
                set connectTimeoutInMsecs(newValue) {
                    this._connectTimeout = newValue;
                }
                get defaultConnectTimeoutInMsecs() {
                    const minTimeout = 8e3;
                    const {
                        webTransportProtocolList,
                        transportDowngradeTimeoutInMsecs
                    } = this;
                    const transportCount = webTransportProtocolList ? webTransportProtocolList.length : 1;
                    const margin = transportCount > 1 ? 1e3 : 0;
                    const connectDowngradeDefault = transportCount * transportDowngradeTimeoutInMsecs + margin;
                    return Math.max(minTimeout, connectDowngradeDefault);
                }
                get connectRetries() {
                    return Check.nothing(this._connectRetries) ? 20 : this._connectRetries;
                }
                set connectRetries(newValue) {
                    this._connectRetries = newValue;
                }
                get connectRetriesPerHost() {
                    return Check.nothing(this._connectRetriesPerHost) ? 0 : this._connectRetriesPerHost;
                }
                set connectRetriesPerHost(newValue) {
                    this._connectRetriesPerHost = newValue;
                }
                get reconnectRetryWaitInMsecs() {
                    return Check.nothing(this._reconnectRetryWaitInMsecs) ? 3e3 : this._reconnectRetryWaitInMsecs;
                }
                set reconnectRetryWaitInMsecs(newValue) {
                    this._reconnectRetryWaitInMsecs = newValue;
                }
                get reconnectRetries() {
                    return Check.nothing(this._reconnectRetries) ? 20 : this._reconnectRetries;
                }
                set reconnectRetries(newValue) {
                    this._reconnectRetries = newValue;
                }
                get generateSendTimestamps() {
                    return Check.nothing(this._genSendTimestamps) ? false : this._genSendTimestamps;
                }
                set generateSendTimestamps(newValue) {
                    this._genSendTimestamps = newValue;
                }
                get generateReceiveTimestamps() {
                    return Check.nothing(this._genReceiveTimestamps) ? false : this._genReceiveTimestamps;
                }
                set generateReceiveTimestamps(newValue) {
                    this._genReceiveTimestamps = newValue;
                }
                get includeSenderId() {
                    return Check.nothing(this._includeSenderId) ? false : this._includeSenderId;
                }
                set includeSenderId(newValue) {
                    this._includeSenderId = newValue;
                }
                get generateSequenceNumber() {
                    return Check.nothing(this._genSequenceNumber) ? false : this._genSequenceNumber;
                }
                set generateSequenceNumber(newValue) {
                    this._genSequenceNumber = newValue;
                }
                get keepAliveIntervalInMsecs() {
                    return Check.nothing(this._kaInterval) ? 3e3 : this._kaInterval;
                }
                set keepAliveIntervalInMsecs(newValue) {
                    this._kaInterval = newValue;
                }
                get keepAliveIntervalsLimit() {
                    return Check.nothing(this._kaIntervalsLimit) ? 3 : this._kaIntervalsLimit;
                }
                set keepAliveIntervalsLimit(newValue) {
                    this._kaIntervalsLimit = newValue;
                }
                get p2pInboxInUse() {
                    return Check.nothing(this._p2pInboxInUse) ? "" : this._p2pInboxInUse;
                }
                _setP2pInboxInUse(value) {
                    this._p2pInboxInUse = value;
                }
                get p2pInboxBase() {
                    return Check.nothing(this._p2pInboxBase) ? "" : this._p2pInboxBase;
                }
                _setP2pInboxBase(value) {
                    this._p2pInboxBase = value;
                }
                get userIdentification() {
                    return Check.nothing(this._userIdentification) ? "" : this._userIdentification;
                }
                _setUserIdentification(value) {
                    this._userIdentification = value;
                }
                get subscriberLocalPriority() {
                    return Check.nothing(this._subLocalPriority) ? 1 : this._subLocalPriority;
                }
                set subscriberLocalPriority(newValue) {
                    this._subLocalPriority = newValue;
                }
                get subscriberNetworkPriority() {
                    return Check.nothing(this._subNetworkPriority) ? 1 : this._subNetworkPriority;
                }
                set subscriberNetworkPriority(newValue) {
                    this._subNetworkPriority = newValue;
                }
                get ignoreDuplicateSubscriptionError() {
                    return Check.nothing(this._ignoreDupSubError) ? true : this._ignoreDupSubError;
                }
                set ignoreDuplicateSubscriptionError(newValue) {
                    this._ignoreDupSubError = newValue;
                }
                get ignoreSubscriptionNotFoundError() {
                    return Check.nothing(this._ignoreSubNotFoundError) ? true : this._ignoreSubNotFoundError;
                }
                set ignoreSubscriptionNotFoundError(newValue) {
                    this._ignoreSubNotFoundError = newValue;
                }
                get reapplySubscriptions() {
                    return Check.nothing(this._reapplySubcriptions) ? false : this._reapplySubcriptions;
                }
                set reapplySubscriptions(newValue) {
                    this._reapplySubcriptions = newValue;
                }
                get publisherProperties() {
                    return this._publisherProperties;
                }
                set publisherProperties(val) {
                    const {
                        MessagePublisherProperties
                    } = PublisherLib;
                    this._publisherProperties = val instanceof MessagePublisherProperties ? val : new MessagePublisherProperties(val);
                }
                get noLocal() {
                    return Check.nothing(this._noLocal) ? false : this._noLocal;
                }
                set noLocal(newValue) {
                    this._noLocal = newValue;
                }
                get readTimeoutInMsecs() {
                    return Check.nothing(this._readTimeout) ? 1e4 : this._readTimeout;
                }
                set readTimeoutInMsecs(newValue) {
                    this._readTimeout = newValue;
                }
                get sendBufferMaxSize() {
                    return Check.nothing(this._sendBufferMaxSize) ? 64 * 1024 : this._sendBufferMaxSize;
                }
                set sendBufferMaxSize(newValue) {
                    this._sendBufferMaxSize = newValue;
                }
                get assumedMaxAdSize() {
                    return Check.nothing(this._assumedMaxAdSize) ? 3e7 : this._assumedMaxAdSize;
                }
                set assumedMaxAdSize(newValue) {
                    this._assumedMaxAdSize = newValue;
                }
                get maxWebPayload() {
                    return Check.nothing(this._maxWebPayload) ? 1024 * 1024 : this._maxWebPayload;
                }
                set maxWebPayload(newValue) {
                    this._maxWebPayload = newValue;
                }
                get nonHTTPTransportPropsSet() {
                    return [].filter(k => Check.something(this[k]));
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return Object.assign(this._lendsInspect(), {
                        authenticationScheme: AuthenticationScheme.describe(this.authenticationScheme),
                        accessToken: this.accessToken ? "*****" : "Not Set",
                        idToken: this.idToken ? "*****" : "Not Set",
                        issuerIdentifier: this.issuerIdentifier ? "*****" : "Not Set",
                        url: this.url,
                        password: this.password ? "*****" : this.password,
                        userName: this.userName,
                        clientName: this.clientName,
                        applicationDescription: this.applicationDescription,
                        vpnName: this.vpnName,
                        vpnNameInUse: this.vpnNameInUse,
                        virtualRouterName: this.virtualRouterName,
                        connectTimeoutInMsecs: this.connectTimeoutInMsecs,
                        connectRetries: this.connectRetries,
                        connectRetriesPerHost: this.connectRetriesPerHost,
                        reconnectRetryWaitInMsecs: this.reconnectRetryWaitInMsecs,
                        reconnectRetries: this.reconnectRetries,
                        generateSendTimestamps: this.generateSendTimestamps,
                        generateReceiveTimestamps: this.generateReceiveTimestamps,
                        includeSenderId: this.includeSenderId,
                        generateSequenceNumber: this.generateSequenceNumber,
                        keepAliveIntervalInMsecs: this.keepAliveIntervalInMsecs,
                        keepAliveIntervalsLimit: this.keepAliveIntervalsLimit,
                        p2pInboxInUse: this.p2pInboxInUse,
                        p2pInboxBase: this.p2pInboxBase,
                        userIdentification: this.userIdentification,
                        subscriberLocalPriority: this.subscriberLocalPriority,
                        subscriberNetworkPriority: this.subscriberNetworkPriority,
                        ignoreDuplicateSubscriptionError: this.ignoreDuplicateSubscriptionError,
                        reapplySubscriptions: this.reapplySubscriptions,
                        publisherProperties: this.publisherProperties,
                        noLocal: this.noLocal,
                        readTimeoutInMsecs: this.readTimeoutInMsecs,
                        sendBufferMaxSize: this.sendBufferMaxSize,
                        maxWebPayload: this.maxWebPayload
                    });
                }
                toString() {
                    return super.toString();
                }
            }
            if (true) {
                SessionProperties.DEFAULT_CIPHER_SUITES = DEFAULT_CIPHER_SUITES;
                SessionProperties.SUPPORTED_CIPHER_SUITES = SUPPORTED_CIPHER_SUITES;
                SessionProperties.SUPPORTED_SSL_PROTOCOLS = SUPPORTED_SSL_PROTOCOLS;
                SessionProperties.SslProtocolExcludeConstantMap = {
                    ["sslv2"]: NodeSslConstants["SSL_OP_NO_SSLv2"] || 0,
                    ["sslv3"]: NodeSslConstants["SSL_OP_NO_SSLv3"] || 0,
                    ["tlsv1"]: NodeSslConstants["SSL_OP_NO_TLSv1"] || 0,
                    ["tlsv1.1"]: NodeSslConstants["SSL_OP_NO_TLSv1_1"] || 0,
                    ["tlsv1.2"]: NodeSslConstants["SSL_OP_NO_TLSv1_2"] || 0
                };
            }
            module.exports.SessionProperties = SessionProperties;
        },
        "./modules/solclient-session/lib/session-request-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SessionRequestType = {
                ADD_SUBSCRIPTION: 0,
                REMOVE_SUBSCRIPTION: 1,
                ADD_P2PINBOX: 2,
                REMOVE_P2PINBOX: 3,
                REMOVE_DTE_SUBSCRIPTION: 100
            };
            module.exports.SessionRequestType = Enum.new(SessionRequestType);
        },
        "./modules/solclient-session/lib/session-state-names.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SessionStateName = {
                DISCONNECTED: "SessionDisconnected",
                CONNECTING: "SessionConnecting",
                WAITING_FOR_TRANSPORT: "WaitingForTransport",
                WAITING_FOR_TRANSPORT_UP: "WaitingForTransportUp",
                WAITING_FOR_LOGIN: "WaitingForLogin",
                TRANSPORT_UP: "SessionTransportUp",
                FULLY_CONNECTED: "SessionFullyConnected",
                SESSION_ERROR: "SessionError",
                DISCONNECTING: "SessionDisconnecting",
                REAPPLYING_SUBSCRIPTIONS: "ReapplyingSubscriptions",
                WAITING_FOR_PUBFLOW: "WaitingForMessagePublisher",
                DISPOSED: "SessionDisposed",
                WAITING_FOR_SUBCONFIRM: "WaitForSubConfirm",
                WAITING_FOR_CAN_ACCEPT_DATA: "WaitForCanAcceptData",
                DISCONNECTING_FLOWS: "DisconnectingFlows",
                FLUSHING_TRANSPORT: "FlushingTransport",
                DESTROYING_TRANSPORT: "DestroyingTransport",
                RECONNECTING: "Reconnecting",
                TRANSPORT_FAIL: "TransportFail",
                WAITING_FOR_INTERCONNECT_TIMEOUT: "WaitingForInterconnectTimeout",
                WAITING_FOR_DNS: "WaitingForDNS",
                WAITING_FOR_TRANSPORT_CHANGE: "WaitingForTransportChange"
            };
            module.exports.SessionStateName = Enum.new(SessionStateName);
        },
        "./modules/solclient-session/lib/session-states.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SessionState = {
                CONNECTING: 1,
                CONNECTED: 2,
                SESSION_ERROR: 3,
                DISCONNECTING: 4,
                DISCONNECTED: 5
            };
            module.exports.SessionState = Enum.new(SessionState);
        },
        "./modules/solclient-session/lib/session.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const DestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
            const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
            const SolclientFactoryLib = __webpack_require__("./modules/solclient-factory/api.js");
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                CacheSession,
                CACHE_REQUEST_PREFIX
            } = __webpack_require__("./modules/solclient-solcache-session/api.js");
            const {
                CapabilityType
            } = __webpack_require__("./modules/solclient-session/lib/capability-types.js");
            const {
                Check,
                Parameter
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                DefaultCapabilities
            } = __webpack_require__("./modules/solclient-session/lib/default-capabilities.js");
            const {
                ErrorResponseSubcodeMapper,
                ErrorSubcode,
                OperationError,
                RequestEventCode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                EventEmitter
            } = __webpack_require__("./modules/solclient-events/api.js");
            const {
                GlobalContext
            } = __webpack_require__("./modules/solclient-session/lib/global-context.js");
            const {
                HostList
            } = __webpack_require__("./modules/solclient-session/lib/host-list.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                MessageRxCBInfo
            } = __webpack_require__("./modules/solclient-session/lib/message-rx-cb-info.js");
            const {
                MutableSessionProperty
            } = __webpack_require__("./modules/solclient-session/lib/mutable-session-properties.js");
            const {
                OutstandingDataRequest
            } = __webpack_require__("./modules/solclient-session/lib/outstanding-data-request.js");
            const {
                P2PUtil
            } = __webpack_require__("./modules/solclient-session/lib/p2p-util.js");
            const {
                QueueDescriptor,
                QueueType
            } = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                SDTField,
                SDTFieldType
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                SessionEvent
            } = __webpack_require__("./modules/solclient-session/lib/session-event.js");
            const {
                SessionEventCBInfo
            } = __webpack_require__("./modules/solclient-session/lib/session-event-cb-info.js");
            const {
                SessionEventCode
            } = __webpack_require__("./modules/solclient-session/lib/session-event-codes.js");
            const {
                SessionEventName
            } = __webpack_require__("./modules/solclient-session/lib/session-event-names.js");
            const {
                SessionFSM
            } = __webpack_require__("./modules/solclient-session/lib/session-fsm.js");
            const {
                SessionFSMEvent
            } = __webpack_require__("./modules/solclient-session/lib/session-fsm-event.js");
            const {
                SessionOperation
            } = __webpack_require__("./modules/solclient-session/lib/session-operations.js");
            const {
                SessionProperties
            } = __webpack_require__("./modules/solclient-session/lib/session-properties.js");
            const {
                SessionPropertiesValidator
            } = __webpack_require__("./modules/solclient-session/lib/session-properties-validator.js");
            const {
                SessionRequestType
            } = __webpack_require__("./modules/solclient-session/lib/session-request-types.js");
            const {
                SessionState
            } = __webpack_require__("./modules/solclient-session/lib/session-states.js");
            const {
                SessionStateName
            } = __webpack_require__("./modules/solclient-session/lib/session-state-names.js");
            const {
                Stats,
                StatType
            } = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                TransportCapabilities,
                TransportProtocol,
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/api.js");
            function transportProtocolDefaultList() {
                const {
                    ProfileBinding
                } = SolclientFactoryLib;
                if (true) {
                    return [ TransportProtocol.WS_BINARY ];
                }
                const result = [];
                if (TransportCapabilities.web.webSocket()) {
                    result.push(TransportProtocol.WS_BINARY);
                }
                const profile = ProfileBinding.value;
                if (profile.cometEnabled) {
                    if (TransportCapabilities.web.xhrBinary()) {
                        if (TransportCapabilities.web.streaming()) {
                            result.push(TransportProtocol.HTTP_BINARY_STREAMING);
                        }
                        result.push(TransportProtocol.HTTP_BINARY);
                    }
                    result.push(TransportProtocol.HTTP_BASE64);
                }
                return result;
            }
            function isValidADTransport(transportProtocol) {
                return transportProtocol && (transportProtocol !== TransportProtocol.HTTP_BINARY_STREAMING && transportProtocol !== TransportProtocol.HTTP_BINARY && transportProtocol !== TransportProtocol.HTTP_BASE64);
            }
            function formatEventName(eventName) {
                return `SessionEventCode.${SessionEventCode.describe(eventName)}`;
            }
            const SOLCLIENT_REQUEST_PREFIX = "#REQ";
            class Session extends EventEmitter {
                constructor(properties, messageCallback, eventCallback) {
                    super({
                        emits: SessionEventCode.values,
                        direct: SessionEventCode.MESSAGE,
                        formatEventName: formatEventName
                    });
                    const self = this;
                    this.logger = new LogFormatter();
                    this.logger.formatter = function formatter(...args) {
                        return [ `[session=${self._sessionFSM ? self._sessionFSM.sessionIdHex : "(N/A)"}]`, ...args ];
                    };
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session constructor called.");
                    if (properties !== undefined && properties !== null) {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("Incoming session properties:\n", properties);
                    }
                    this.on("error", error => {
                        const {
                            LOG_ERROR
                        } = self.logger;
                        LOG_ERROR(error.info.error);
                    });
                    const sessionProperties = new SessionProperties(properties);
                    {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("Eventual session properties:\n", sessionProperties);
                    }
                    this._messageCallbackInfo = this.wrapMessageCallback(messageCallback);
                    this._eventCallbackInfo = this.wrapEventCallback(eventCallback);
                    if (Check.empty(sessionProperties.clientName)) {
                        sessionProperties.clientName = GlobalContext.GenerateClientName();
                    }
                    sessionProperties._setUserIdentification(GlobalContext.GenerateUserIdentification());
                    if (Check.empty(sessionProperties.applicationDescription)) {
                        sessionProperties.applicationDescription = GlobalContext.GenerateClientDescription();
                    }
                    SessionPropertiesValidator.validate(sessionProperties);
                    if (Check.nothing(sessionProperties.webTransportProtocolList)) {
                        const selectedProtocol = sessionProperties.transportProtocol;
                        const defaultList = transportProtocolDefaultList();
                        const sliceIndex = selectedProtocol ? defaultList.indexOf(selectedProtocol) : 0;
                        if (sliceIndex < 0) {
                            throw new OperationError(`Selected transport protocol ${TransportProtocol.describe(selectedProtocol)} is disabled or invalid for this platform`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        sessionProperties.webTransportProtocolList = defaultList.slice(sliceIndex);
                        if (sessionProperties.webTransportProtocolList.length === 0) {
                            throw new OperationError(`No usable transport protocol or fallback from ${TransportProtocol.describe(selectedProtocol)}`, ErrorSubcode.PARAMETER_CONFLICT);
                        }
                        const validForAD = sessionProperties.webTransportProtocolList.filter(x => isValidADTransport(x));
                        if (validForAD.length === 0) {
                            this._adDisabledReason = "Guaranteed messaging not compatible with any available " + `transport protocol: ${sessionProperties.webTransportProtocolList.map(k => TransportProtocol.describe(k)).join(", ")}`;
                        }
                        if (sessionProperties.publisherProperties.enabled) {
                            if (this._adDisabledReason) {
                                throw new OperationError("Invalid transport protocol(s) for session with Guaranteed Messaging Publisher", ErrorSubcode.PARAMETER_CONFLICT, this._adDisabledReason);
                            }
                            sessionProperties.webTransportProtocolList = validForAD;
                        }
                    } else {
                        const transportProtocols = sessionProperties.webTransportProtocolList;
                        const validForAD = transportProtocols.every(isValidADTransport);
                        if (!validForAD) {
                            const invalid = transportProtocols.filter(x => !isValidADTransport(x));
                            this._adDisabledReason = `Guaranteed messaging incompatible with selected transport protocols: ${invalid.map(k => TransportProtocol.describe(k)).join(", ")}`;
                            if (sessionProperties.publisherProperties.enabled) {
                                throw new OperationError("Invalid transport protocol(s) for session with Guaranteed Messaging Publisher", ErrorSubcode.PARAMETER_CONFLICT, this._adDisabledReason);
                            }
                        }
                    }
                    this._sessionProperties = sessionProperties;
                    this._sessionStats = new Stats();
                    this._hosts = new HostList(sessionProperties);
                    this._sessionFSM = new SessionFSM(this._sessionProperties, this, this._sessionStats, this._hosts);
                    this._sessionFSM.start();
                    this._sessionFSM.createMessagePublisher();
                    this._outstandingDataReqs = {};
                    this._capabilities = DefaultCapabilities.createDefaultCapabilities(sessionProperties);
                    this._seqNum = 1;
                }
                connect() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session connect called.");
                    const result = this.allowOperation(SessionOperation.CONNECT);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.CONNECT
                    });
                    this._sessionFSM.processEvent(sEvent);
                }
                get canAck() {
                    const statesCanAck = [ SessionStateName.CONNECTING, SessionStateName.TRANSPORT_UP, SessionStateName.DISCONNECTING ];
                    return statesCanAck.some(stateName => !!this._sessionFSM.getActiveState(stateName));
                }
                disconnect() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session disconnect called.");
                    const result = this.allowOperation(SessionOperation.DISCONNECT);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    const sEvent = new SessionFSMEvent({
                        name: SessionEventName.DISCONNECT
                    });
                    this._sessionFSM.processEvent(sEvent);
                }
                dispose() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session dispose called.");
                    if (this._disposed) return;
                    setTimeout(() => {
                        this._sessionFSM.processEvent(new SessionFSMEvent({
                            name: SessionEventName.DISPOSE
                        }));
                        this._sessionFSM.terminateFsm();
                        this.disableEmitter();
                        this._disposed = true;
                    }, 0);
                }
                subscribe(topic, requestConfirmation, correlationKey, requestTimeout) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session subscribe called for topic ", topic && topic.toString && topic.toString());
                    const result = this.allowOperation(SessionOperation.CTRL);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                    topic.validate();
                    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
                        throw new OperationError(`Topic is required for subscribe; ${DestinationLib.DestinationType.describe(topic.getType())}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                    }
                    Parameter.isBooleanOrNothing("requestConfirmation", requestConfirmation);
                    Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                    Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                    this._sessionFSM.subscriptionUpdate(topic, !!requestConfirmation, correlationKey, requestTimeout, SessionRequestType.ADD_SUBSCRIPTION, (rxMsgObj, cancelledRequest) => this.handleSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, requestConfirmation));
                }
                updateQueueSubscription(topic, queue, add, messageConsumer, callback, requestTimeout) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Queue subscribe called for topic ", topic && topic.toString && topic.toString(), " for queue ", queue && queue.toString && queue.toString());
                    LOG_TRACE("queue: ", queue);
                    const result = this.allowOperation(SessionOperation.CTRL);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                    topic.validate();
                    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
                        throw new OperationError(`Topic is required for queue subscribe; ${DestinationLib.DestinationType.describe(topic.getType())}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                    }
                    Parameter.isInstanceOf("queue", queue, DestinationLib.Destination);
                    queue.validate();
                    if (queue.getType() !== DestinationLib.DestinationType.QUEUE && queue.getType() !== DestinationLib.DestinationType.TEMPORARY_QUEUE) {
                        throw new OperationError(`Queue is required for queue subscribe; ${DestinationLib.DestinationType.describe(queue.getType())}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                    Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                    this._sessionFSM.queueSubscriptionUpdate(topic, queue, requestTimeout, add, (rxMsgObj, cancelledRequest) => this.handleQueueSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, callback));
                }
                unsubscribe(topic, requestConfirmation, correlationKey, requestTimeout) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session unsubscribe called for topic ", topic && topic.toString && topic.toString());
                    const result = this.allowOperation(SessionOperation.CTRL);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isInstanceOf("topic", topic, DestinationLib.Destination);
                    topic.validate();
                    if (topic.getType() !== DestinationLib.DestinationType.TOPIC) {
                        throw new OperationError(`Topic is required for unsubscribe; ${DestinationLib.DestinationType.describe(topic.getType())}`, ErrorSubcode.INVALID_TOPIC_SYNTAX);
                    }
                    Parameter.isBooleanOrNothing("requestConfirmation", requestConfirmation);
                    Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                    Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                    this._sessionFSM.subscriptionUpdate(topic, !!requestConfirmation, correlationKey, requestTimeout, SessionRequestType.REMOVE_SUBSCRIPTION, (rxMsgObj, cancelledRequest) => this.handleSubscriptionUpdateResponse(rxMsgObj, cancelledRequest, requestConfirmation));
                }
                unsubscribeDurableTopicEndpoint(queueDescriptor) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session unsubscribeDurableTopicEndpoint called for queue descriptor ", queueDescriptor && queueDescriptor.toString && queueDescriptor.toString());
                    const result = this.allowOperation(SessionOperation.CTRL);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    const destination = this.createDestinationFromDescriptor(QueueDescriptor.createFromSpec(queueDescriptor));
                    const requestConfirmation = true;
                    this._sessionFSM.subscriptionUpdate(destination, requestConfirmation, undefined, undefined, SessionRequestType.REMOVE_DTE_SUBSCRIPTION, (rxMsgObj, cancelledRequest) => this.handleDTEUnsubscribeResponse(rxMsgObj, cancelledRequest));
                }
                updateProperty(mutableSessionProperty, newValue, requestTimeout, correlationKey) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session updateProperty called: ", mutableSessionProperty, newValue);
                    const result = this.allowOperation(SessionOperation.CTRL);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    const {
                        Topic
                    } = DestinationLib;
                    LOG_TRACE("Updating property ", mutableSessionProperty, newValue);
                    Parameter.isEnumMember("mutableSessionProperty", mutableSessionProperty, MutableSessionProperty);
                    Parameter.isNumberOrNothing("requestTimeout", requestTimeout);
                    Parameter.isRangeCompareOrNothing("requestTimeout", requestTimeout, ">", 0);
                    let sessionEvent;
                    const responseCallback = respMsg => {
                        const response = respMsg.getResponse();
                        if (response.responseCode === 200) {
                            if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
                                this._sessionProperties.applicationDescription = newValue;
                                sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, response.responseString, response.responseCode, 0, correlationKey, null);
                                this.sendEvent(sessionEvent);
                            } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
                                const oldP2pTopicName = P2PUtil.getP2PTopicSubscription(this._sessionProperties.p2pInboxBase);
                                const oldP2pTopic = Topic.createFromName(oldP2pTopicName);
                                const newP2pTopicName = P2PUtil.getP2PTopicSubscription(respMsg.getP2PTopicValue());
                                const newP2pTopic = Topic.createFromName(newP2pTopicName);
                                const afterAddCallback = smpResp => {
                                    const resp = smpResp.getResponse();
                                    if (resp.responseCode === 200) {
                                        this._sessionProperties._setP2pInboxBase(respMsg.getP2PTopicValue() || "");
                                        this._sessionProperties._setP2pInboxInUse(P2PUtil.getP2PInboxTopic(this._sessionProperties.p2pInboxBase));
                                        this._sessionProperties.clientName = newValue;
                                        sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, resp.responseString, resp.responseCode, 0, correlationKey, null);
                                        this.sendEvent(sessionEvent);
                                    } else {
                                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode, resp.responseString);
                                        if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT && this._sessionProperties.ignoreDuplicateSubscriptionError) {
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_OK, resp.responseString, resp.responseCode, 0, correlationKey, null);
                                            this.sendEvent(sessionEvent);
                                        } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT || errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID || errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED || errorSubcode === ErrorSubcode.SUBSCRIPTION_TOO_MANY) {
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, errorSubcode, correlationKey, null);
                                            this.sendEvent(sessionEvent);
                                        } else {
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, ErrorSubcode.SUBSCRIPTION_ERROR_OTHER, correlationKey, null);
                                            this.sendEvent(sessionEvent);
                                        }
                                    }
                                };
                                const afterRemoveCallback = smpResp => {
                                    const resp = smpResp.getResponse();
                                    if (resp.responseCode === 200) {
                                        this._sessionFSM.subscriptionUpdate(newP2pTopic, true, correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.ADD_P2PINBOX, afterAddCallback);
                                    } else {
                                        const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(resp.responseCode, resp.responseString);
                                        if (errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND && this._sessionProperties.ignoreSubscriptionNotFoundError) {
                                            this._sessionFSM.subscriptionUpdate(newP2pTopic, true, correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.ADD_P2PINBOX, afterAddCallback);
                                        } else if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ATTRIBUTES_CONFLICT || errorSubcode === ErrorSubcode.SUBSCRIPTION_INVALID || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND || errorSubcode === ErrorSubcode.SUBSCRIPTION_ACL_DENIED) {
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, errorSubcode, null, null);
                                            this.sendEvent(sessionEvent);
                                        } else {
                                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, resp.responseString, resp.responseCode, ErrorSubcode.SUBSCRIPTION_ERROR_OTHER, null, null);
                                            this.sendEvent(sessionEvent);
                                        }
                                    }
                                };
                                this._sessionFSM.subscriptionUpdate(oldP2pTopic, true, correlationKey, this._sessionProperties.readTimeoutInMsecs, SessionRequestType.REMOVE_P2PINBOX, afterRemoveCallback);
                            }
                        } else {
                            const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(response.responseCode, response.responseString);
                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, response.responseString, response.responseCode, errorSubcode, correlationKey, null);
                            this.sendEvent(sessionEvent);
                        }
                    };
                    const returnCode = this._sessionFSM.sendUpdateProperty(mutableSessionProperty, newValue, correlationKey, requestTimeout, responseCallback);
                    if (returnCode !== TransportReturnCode.OK) {
                        if (returnCode === TransportReturnCode.NO_SPACE) {
                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, "Property update failed - no space in transport", null, ErrorSubcode.INSUFFICIENT_SPACE, null, null);
                        } else {
                            sessionEvent = SessionEvent.build(SessionEventCode.PROPERTY_UPDATE_ERROR, "Property update failed", null, ErrorSubcode.INVALID_OPERATION, null, null);
                        }
                        this.sendEvent(sessionEvent);
                    }
                }
                updateAuthenticationOnReconnect(authenticationProperties) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    const allowedProperties = [ "accessToken", "idToken" ];
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    if (!authenticationProperties || typeof authenticationProperties !== "object") {
                        throw new OperationError("updateAuthenticationOnReconnect parameter must be a non-empty object.", ErrorSubcode.PARAMETER_INVALID_TYPE, null);
                    }
                    var key;
                    for (key in authenticationProperties) {
                        if (!allowedProperties.includes(key)) {
                            throw new OperationError("Invalid property in updateAuthenticationOnReconnect parameter.", ErrorSubcode.PARAMETER_CONFLICT, null);
                        }
                    }
                    const newProps = this.getSessionProperties();
                    Object.assign(newProps, authenticationProperties);
                    SessionPropertiesValidator.validate(newProps);
                    this._sessionProperties = newProps;
                    Object.assign(this._sessionFSM._sessionProperties, authenticationProperties);
                    LOG_TRACE("updateAuthenticationOnReconnect applied new token(s).");
                }
                send(message) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session send() called.");
                    const result = this.allowOperation(SessionOperation.SEND, message);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isInstanceOf("message", message, MessageLib.Message);
                    this.validateAndSendMessage(message);
                }
                sendRequest(message, timeout = undefined, replyReceivedCBFunction = undefined, requestFailedCBFunction = undefined, userObject = undefined) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session sendRequest called.");
                    const result = this.allowOperation(SessionOperation.SEND, message);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isInstanceOf("message", message, MessageLib.Message);
                    Parameter.isNumberOrNothing("timeout", timeout);
                    Parameter.isRangeCompareOrNothing("timeout", timeout, ">=", 100);
                    Parameter.isFunctionOrNothing("replyReceivedCBFunction", replyReceivedCBFunction);
                    Parameter.isFunctionOrNothing("requestFailedCBFunction", requestFailedCBFunction);
                    const correlationId = message.getCorrelationId();
                    if (correlationId === null || correlationId === undefined) {
                        message.setCorrelationId(SOLCLIENT_REQUEST_PREFIX + GlobalContext.NextId());
                    }
                    const replyTo = message.getReplyTo();
                    if (replyTo === null || replyTo === undefined) {
                        const replyToTopic = DestinationLib.Topic.createFromName(this._sessionProperties.p2pInboxInUse);
                        message.setReplyTo(replyToTopic);
                    }
                    this.validateAndSendMessage(message);
                    this.enqueueOutstandingDataReq(message.getCorrelationId(), requestFailedCBFunction, timeout, replyReceivedCBFunction, userObject);
                }
                sendReply(messageToReplyTo, replyMessage) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session sendReply called.");
                    const result = this.allowOperation(SessionOperation.SEND, replyMessage);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isInstanceOfOrNothing("messageToReplyTo", messageToReplyTo, MessageLib.Message);
                    Parameter.isInstanceOf("replyMessage", replyMessage, MessageLib.Message);
                    replyMessage.setAsReplyMessage(true);
                    if (messageToReplyTo) {
                        replyMessage.setCorrelationId(messageToReplyTo.getCorrelationId());
                        const replyTo = messageToReplyTo.getReplyTo();
                        if (replyTo === null || replyTo === undefined) {
                            throw new OperationError("ReplyTo destination may not be null.", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                        }
                        replyMessage.setDestination(messageToReplyTo.getReplyTo());
                    }
                    this.validateAndSendMessage(replyMessage);
                }
                getStat(statType) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session getStat called.");
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isEnumMember("statType", statType, StatType);
                    return this._sessionFSM.getStat(statType);
                }
                resetStats() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session resetStats called.");
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    this._sessionFSM.resetStats();
                }
                getSessionProperties() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session getSessionProperties called.");
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    const properties = this._sessionProperties.clone();
                    const sessionState = this.getSessionState();
                    if (sessionState !== SessionStateName.DISCONNECTED && this._sessionFSM._transport) {
                        properties._setWebTransportProtocolInUse(this._sessionFSM._transport.getTransportProtocol());
                    }
                    return properties;
                }
                isCapable(capabilityType) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session isCapable called.");
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isNumber("capabilityType", capabilityType);
                    const caps = this._capabilities;
                    if (!caps) {
                        return false;
                    }
                    return typeof caps[capabilityType] === "boolean" ? caps[capabilityType] : false;
                }
                getCapability(capabilityType) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session getCapability called.");
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    Parameter.isNumber("capabilityType", capabilityType);
                    const val = this._getCapability(capabilityType);
                    if (typeof val === "boolean") {
                        return SDTField.create(SDTFieldType.BOOL, val);
                    }
                    if (typeof val === "number") {
                        return SDTField.create(SDTFieldType.INT64, val);
                    }
                    if (typeof val === "string") {
                        return SDTField.create(SDTFieldType.STRING, val);
                    }
                    return null;
                }
                _getCapability(capabilityType) {
                    const caps = this._capabilities;
                    if (!caps) return null;
                    const value = caps[capabilityType];
                    return value === undefined ? null : value;
                }
                getSessionState() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session getSessionState called.");
                    const result = this.allowOperation(SessionOperation.QUERY_OPERATION);
                    if (result) {
                        throw new OperationError(result, ErrorSubcode.INVALID_OPERATION, null);
                    }
                    const sessionStateName = this.getFSMState();
                    switch (sessionStateName) {
                      case SessionStateName.FULLY_CONNECTED:
                        return SessionState.CONNECTED;

                      case SessionStateName.DISCONNECTING:
                        return SessionState.DISCONNECTING;

                      case SessionStateName.DISCONNECTED:
                        return SessionState.DISCONNECTED;

                      case SessionStateName.SESSION_ERROR:
                        return SessionState.SESSION_ERROR;

                      case SessionStateName.CONNECTING:
                      case SessionStateName.WAITING_FOR_INTERCONNECT_TIMEOUT:
                      case SessionStateName.WAITING_FOR_DNS:
                      case SessionStateName.WAITING_FOR_TRANSPORT_UP:
                      case SessionStateName.WAITING_FOR_SESSION_UP:
                      case SessionStateName.WAITING_FOR_LOGIN:
                      case SessionStateName.WAITING_FOR_P2PINBOX_REG:
                      case SessionStateName.WAITING_FOR_PUBFLOW:
                      case SessionStateName.REAPPLYING_SUBSCRIPTIONS:
                        return SessionState.CONNECTING;

                      default:
                        {
                            const {
                                LOG_INFO
                            } = this.logger;
                            LOG_INFO(`Unmapped session state ${SessionStateName.describe(sessionStateName)}`);
                            return null;
                        }
                    }
                }
                getFSMState() {
                    return this._sessionFSM.getCurrentStateName();
                }
                createCacheSession(properties) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session createCacheSession called.");
                    return new CacheSession(properties, this, {
                        incStat: this._sessionFSM.incStat.bind(this._sessionFSM)
                    });
                }
                createMessageConsumer(consumerProperties) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session createMessageConsumer called.");
                    if (this._adDisabledReason) {
                        throw new OperationError("Session does not provide MessageConsumer capability", ErrorSubcode.GM_UNAVAILABLE, this._adDisabledReason);
                    }
                    if (consumerProperties !== undefined && consumerProperties !== null) {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("createMessageConsumer - Consumer properties:\n", consumerProperties);
                    }
                    return this._sessionFSM.createMessageConsumer(consumerProperties);
                }
                createQueueBrowser(browserProperties) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session createQueueBrowser called.");
                    if (this._adDisabledReason) {
                        throw new OperationError("Session does not provide QueueBrowser capability", ErrorSubcode.GM_UNAVAILABLE, this._adDisabledReason);
                    }
                    if (browserProperties !== undefined && browserProperties !== null) {
                        const {
                            LOG_DEBUG
                        } = this.logger;
                        LOG_DEBUG("createQueueBrowser - Browser properties:\n", browserProperties);
                    }
                    return this._sessionFSM.createQueueBrowser(browserProperties);
                }
                createDestinationFromDescriptor(queueDescriptor) {
                    const {
                        DestinationType,
                        Queue,
                        Topic
                    } = DestinationLib;
                    let destinationType = DestinationType.TOPIC;
                    if (queueDescriptor.type === QueueType.QUEUE) {
                        destinationType = queueDescriptor.durable ? DestinationType.QUEUE : DestinationType.TEMPORARY_QUEUE;
                    }
                    const name = queueDescriptor.name || null;
                    if (queueDescriptor.durable) {
                        assert(name, "Durable endpoint with generated name is not a valid configuration");
                        const factoryMethod = queueDescriptor.getType() === QueueType.QUEUE ? Queue.createFromLocalName : Topic.createFromName;
                        return factoryMethod(name);
                    }
                    return this.createTemporaryDestination(destinationType, name);
                }
                createTemporaryDestination(destinationType, name) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    const {
                        DestinationFromNetwork,
                        DestinationUtil
                    } = DestinationLib;
                    const vrn = this.getSessionProperties().virtualRouterName;
                    if (!this.isCapable(CapabilityType.TEMPORARY_ENDPOINT) || vrn === null || vrn === undefined || vrn.length === 0) {
                        throw new OperationError("Attempt to generate temporary destination or endpoint without suitable session", ErrorSubcode.INVALID_OPERATION);
                    }
                    const localName = name && name.startsWith("#P2P") ? name : DestinationUtil.createTemporaryName(destinationType, vrn, name);
                    LOG_TRACE("Generated name:", localName);
                    return DestinationFromNetwork.createDestinationFromName(localName);
                }
                sendEvent(sessionEvent) {
                    if (!sessionEvent) return;
                    if (this._disposed) return;
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE(`Sending event ${sessionEvent}`);
                    this._eventCallbackInfo.sessionEventCBFunction(this, sessionEvent, this._eventCallbackInfo.userObject);
                }
                getTransportInfo() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    LOG_TRACE("Session getTransportInfo called.");
                    return this._sessionFSM.getTransportInfo();
                }
                injectTransportInterceptor(interceptor) {
                    this._sessionFSM.injectTransportInterceptor(interceptor);
                }
                allowOperation(operationEnum, message) {
                    if (!this._sessionFSM) return false;
                    let allow = true;
                    const sessionStateName = this._sessionFSM.getCurrentStateName();
                    if (sessionStateName === SessionStateName.DISPOSED) {
                        allow = false;
                    } else if (Check.anything(operationEnum)) {
                        switch (operationEnum) {
                          case SessionOperation.CONNECT:
                            if (sessionStateName !== SessionStateName.NEW && sessionStateName !== SessionStateName.DISCONNECTED) {
                                allow = false;
                            }
                            break;

                          case SessionOperation.DISCONNECT:
                            if (sessionStateName === SessionStateName.NEW) {
                                allow = false;
                            }
                            break;

                          case SessionOperation.SEND:
                          case SessionOperation.CTRL:
                            allow = sessionStateName === SessionStateName.FULLY_CONNECTED || message && message.getDeliveryMode() !== MessageLib.MessageDeliveryModeType.DIRECT;
                            break;

                          case SessionOperation.QUERY_OPERATION:
                            allow = true;
                            break;

                          default:
                            allow = false;
                        }
                    } else {
                        allow = false;
                    }
                    if (allow) {
                        return null;
                    }
                    return `Cannot perform operation ${operationEnum} while in state ${sessionStateName}`;
                }
                updateCapabilities(routerCapabilities) {
                    this._capabilities = routerCapabilities;
                }
                validateAndSendMessage(message) {
                    const sendDest = message.getDestination();
                    if (Check.nothing(sendDest) || Check.empty(sendDest.getName())) {
                        throw new OperationError("Message must have a valid Destination", ErrorSubcode.TOPIC_MISSING);
                    }
                    const senderTimestamp = message.getSenderTimestamp();
                    const noSenderTimestamp = senderTimestamp === null || senderTimestamp === undefined;
                    if (this._sessionProperties.generateSendTimestamps && (noSenderTimestamp || message.hasAutoSenderTimestamp)) {
                        const now = new Date();
                        message.setSenderTimestamp(now.getTime());
                        message.hasAutoSenderTimestamp = true;
                    }
                    const sequenceNumber = message.getSequenceNumber();
                    const noSequenceNumber = sequenceNumber === null || sequenceNumber === undefined;
                    if (this._sessionProperties.generateSequenceNumber && (noSequenceNumber || message.hasAutoSequenceNumber)) {
                        message.setSequenceNumber(this._seqNum++);
                        message.hasAutoSequenceNumber = true;
                    }
                    const senderId = message.getSenderId();
                    const noSenderId = senderId === null || senderId === undefined;
                    if (this._sessionProperties.includeSenderId && noSenderId) {
                        message.setSenderId(this._sessionProperties.clientName);
                    }
                    this._sessionFSM.prepareAndSendMessage(message);
                }
                enqueueOutstandingDataReq(correlationId, reqFailedCb, reqTimeout, replyRecvdCb, userObject) {
                    if (Check.none(correlationId)) {
                        return;
                    }
                    const {
                        LOG_TRACE,
                        LOG_ERROR
                    } = this.logger;
                    LOG_TRACE(`Enqueue outstanding data request correlationId=${correlationId}`);
                    const timer = setTimeout(() => {
                        this._sessionFSM.incStat(StatType.TX_REQUEST_TIMEOUT);
                        try {
                            const result = delete this._outstandingDataReqs[correlationId];
                            if (!result) {
                                LOG_ERROR(`Cannot delete data request ${correlationId}`);
                            }
                        } catch (e) {
                            LOG_ERROR(`Cannot delete data request ${correlationId}`, e);
                        }
                        if (Check.anything(reqFailedCb)) {
                            const requestEvent = SessionEvent.build(RequestEventCode.REQUEST_TIMEOUT, "Request timeout", correlationId);
                            reqFailedCb(this, requestEvent, userObject);
                        }
                    }, reqTimeout || this._sessionProperties.readTimeoutInMsecs);
                    const outstandingReq = new OutstandingDataRequest(correlationId, timer, replyRecvdCb, reqFailedCb, userObject);
                    this._outstandingDataReqs[correlationId] = outstandingReq;
                }
                cancelOutstandingDataReq(correlationId) {
                    const {
                        LOG_TRACE,
                        LOG_ERROR
                    } = this.logger;
                    if (Check.none(correlationId) || !this._outstandingDataReqs) {
                        return null;
                    }
                    const req = this._outstandingDataReqs[correlationId];
                    if (req === undefined || req === null) {
                        return null;
                    }
                    LOG_TRACE(`Cancel outstanding data request correlationId=${correlationId}`);
                    if (req.timer) {
                        clearTimeout(req.timer);
                        req.timer = null;
                    }
                    try {
                        const result = delete this._outstandingDataReqs[correlationId];
                        if (!result) {
                            LOG_ERROR(`Cannot delete data request ${correlationId}`);
                        }
                    } catch (e) {
                        LOG_ERROR(`Cannot delete data request ${correlationId}`, e);
                    }
                    return req;
                }
                cleanupSession() {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    if (this._outstandingDataReqs) {
                        LOG_TRACE("Cancel all outstanding data requests");
                        Object.keys(this._outstandingDataReqs).forEach(key => {
                            const dataReq = this.cancelOutstandingDataReq(key);
                            if (dataReq && dataReq.reqFailedCBFunction) {
                                const requestEvent = SessionEvent.build(RequestEventCode.REQUEST_ABORTED, "Request aborted", key);
                                dataReq.reqFailedCBFunction(this, requestEvent, dataReq.userObject);
                            }
                        });
                    }
                }
                handleDataMessage(dataMessageIn) {
                    const {
                        LOG_TRACE,
                        LOG_INFO
                    } = this.logger;
                    const dataMessage = dataMessageIn;
                    if (this._sessionProperties.generateReceiveTimestamps) {
                        const now = new Date();
                        dataMessage._receiverTimestamp = now.getTime();
                    }
                    if (dataMessage.isReplyMessage()) {
                        const correlationId = dataMessage.getCorrelationId();
                        if (Check.anything(correlationId)) {
                            const dataReq = this.cancelOutstandingDataReq(correlationId);
                            if (dataReq !== null) {
                                this._sessionFSM.incStat(StatType.RX_REPLY_MSG_RECVED);
                                LOG_TRACE("Calling application replyReceivedCallback");
                                dataReq.replyReceivedCBFunction(this, dataMessage, dataReq.userObject);
                                LOG_TRACE("application replyReceivedCallback returns");
                                return;
                            }
                            if (correlationId.startsWith(SOLCLIENT_REQUEST_PREFIX)) {
                                LOG_INFO("DROP: Discard reply message due to missing outstanding request");
                                this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
                                return;
                            }
                            if (correlationId.startsWith(CACHE_REQUEST_PREFIX) && !(CacheSession && this._messageCallbackInfo.userObject instanceof CacheSession)) {
                                LOG_INFO("DROP: Discard cache reply due to no cache session active");
                                this._sessionFSM.incStat(StatType.RX_REPLY_MSG_DISCARD);
                                return;
                            }
                        }
                    }
                    LOG_TRACE("Calling application messageCallback");
                    this._messageCallbackInfo.messageRxCBFunction(this, dataMessage, this._messageCallbackInfo.userObject);
                    LOG_TRACE("application messageCallback returns");
                }
                handleSubscriptionUpdateResponse(smpMsg, request, requestConfirm) {
                    const response = smpMsg.getResponse();
                    const {
                        responseCode,
                        responseString
                    } = response;
                    const {
                        correlationKey
                    } = request;
                    if (responseCode === 200) {
                        const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK, responseString, responseCode, 0, correlationKey, null);
                        this.sendEvent(sessionEvent);
                    } else {
                        const subscriptionStr = StringUtils.stripNullTerminate(smpMsg.encodedUtf8Subscription);
                        this._sessionFSM.handleSubscriptionUpdateError(responseCode, responseString, subscriptionStr, correlationKey, requestConfirm);
                    }
                }
                handleQueueSubscriptionUpdateResponse(smpMsg, request, callback) {
                    const {
                        LOG_TRACE
                    } = this.logger;
                    if (!smpMsg) {
                        LOG_TRACE("handleQueueSubscriptionUpdateResponse called on timeout.");
                        callback(false, ErrorSubcode.TIMEOUT, 0, "Timeout");
                        return;
                    }
                    const response = smpMsg.getResponse();
                    const {
                        responseCode,
                        responseString
                    } = response;
                    const errorSubcode = ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                    LOG_TRACE("handleQueueSubscriptionUpdateResponse called.", smpMsg);
                    if (responseCode === 200 || errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND) {
                        callback(true, 0, responseCode, responseString);
                    } else {
                        callback(false, errorSubcode, responseCode, responseString);
                    }
                }
                handleDTEUnsubscribeResponse(adCtrlMessage, request) {
                    const response = adCtrlMessage.getResponse();
                    const {
                        responseCode,
                        responseString
                    } = response;
                    const {
                        correlationKey
                    } = request;
                    const eventCode = responseCode === 200 ? SessionEventCode.UNSUBSCRIBE_TE_TOPIC_OK : SessionEventCode.UNSUBSCRIBE_TE_TOPIC_ERROR;
                    const subcode = responseCode === 200 ? 0 : ErrorResponseSubcodeMapper.getADErrorSubcode(responseCode, responseString);
                    this.sendEvent(SessionEvent.build(eventCode, responseString, responseCode, subcode, correlationKey));
                }
                handleSubscriptionUpdateError(respCode, respText, subscriptionStr, correlationKey, requestConfirm) {
                    const errorSubcode = ErrorResponseSubcodeMapper.getErrorSubcode(respCode, respText);
                    if (errorSubcode === ErrorSubcode.SUBSCRIPTION_ALREADY_PRESENT && this._sessionProperties.ignoreDuplicateSubscriptionError || errorSubcode === ErrorSubcode.SUBSCRIPTION_NOT_FOUND && this._sessionProperties.ignoreSubscriptionNotFoundError) {
                        if (requestConfirm) {
                            const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_OK, respText, respCode, 0, correlationKey, null);
                            this.sendEvent(sessionEvent);
                        }
                    } else {
                        const sessionEvent = SessionEvent.build(SessionEventCode.SUBSCRIPTION_ERROR, respText, respCode, errorSubcode, correlationKey, `Topic: ${subscriptionStr}`);
                        this.sendEvent(sessionEvent);
                    }
                }
                getEventCBInfo() {
                    return this._eventCallbackInfo;
                }
                setEventCBInfo(eventCBInfo) {
                    this._eventCallbackInfo = eventCBInfo;
                }
                getMessageCBInfo() {
                    return this._messageCallbackInfo;
                }
                setMessageCBInfo(messageCBInfo) {
                    this._messageCallbackInfo = messageCBInfo;
                }
                getCorrelationTag() {
                    return this._sessionFSM.getCorrelationTag();
                }
                wrapEventCallback(eventCallback) {
                    const {
                        LOG_WARN
                    } = this.logger;
                    const eventCallbackInfo = (() => {
                        if (!eventCallback) return null;
                        if (eventCallback.sessionEventCBFunction) return eventCallback;
                        return new SessionEventCBInfo(eventCallback);
                    })();
                    return new SessionEventCBInfo((session, sessionEvent, obj, rfu) => {
                        const {
                            sessionEventCode
                        } = sessionEvent;
                        if (eventCallbackInfo) {
                            try {
                                eventCallbackInfo.sessionEventCBFunction(session, sessionEvent, obj, rfu);
                            } catch (ex) {
                                const error = Object.assign(new OperationError(`Unhandled error in SessionEventRxCBInfo callback on sessionEventCode ${SessionEventCode.describe(sessionEventCode)}`, ErrorSubcode.CALLBACK_ERROR, `On event: ${[ sessionEventCode, sessionEvent, obj, rfu ]} ${ex}`), {
                                    stack: ex.stack,
                                    info: {
                                        event: {
                                            name: sessionEventCode,
                                            formattedName: `SessionEventCode.${SessionEventCode.describe(sessionEventCode)}`,
                                            args: [ sessionEvent, obj, rfu ]
                                        },
                                        error: ex
                                    }
                                });
                                LOG_WARN(error.toString(), error.info);
                            }
                        }
                        this.emit(sessionEventCode, sessionEvent);
                    });
                }
                wrapMessageCallback(messageCallback) {
                    const {
                        LOG_WARN
                    } = this.logger;
                    const messageCallbackInfo = (() => {
                        if (!messageCallback) return null;
                        if (messageCallback.messageRxCBFunction) return messageCallback;
                        return new MessageRxCBInfo(messageCallback);
                    })();
                    const formattedName = `SessionEventCode.${SessionEventCode.describe(SessionEventCode.MESSAGE)}`;
                    const buildErrorEvent = (ex, message, object) => Object.assign(new OperationError(`Unhandled error in MessageRxCBInfo callback/handler for ${formattedName}`, ErrorSubcode.CALLBACK_ERROR), {
                        stack: ex.stack,
                        info: {
                            event: {
                                name: SessionEventCode.MESSAGE,
                                formattedName: formattedName,
                                args: [ message, object ]
                            },
                            error: ex
                        }
                    });
                    return new MessageRxCBInfo((session, message, object) => {
                        if (messageCallbackInfo) {
                            try {
                                messageCallbackInfo.messageRxCBFunction(session, message, object);
                            } catch (ex) {
                                const error = buildErrorEvent(ex, message, object).toString();
                                LOG_WARN(error, error.info, ex);
                            }
                        }
                        try {
                            this.emitDirect(message);
                        } catch (ex) {
                            this.emit("error", buildErrorEvent(ex, message, object));
                        }
                    });
                }
                get adLocallyDisabled() {
                    return !!this._adDisabledReason;
                }
                get canConnectConsumer() {
                    if (this.adLocallyDisabled) return false;
                    if (this._capabilities) {
                        return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_CONSUME);
                    }
                    return undefined;
                }
                get canConnectPublisher() {
                    if (this.adLocallyDisabled) return false;
                    if (this._capabilities) {
                        return this.isCapable(CapabilityType.GUARANTEED_MESSAGE_PUBLISH);
                    }
                    return undefined;
                }
                get disposed() {
                    return this._disposed;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        sessionId: this._sessionFSM && this._sessionFSM.sessionIdHex || "(N/A)",
                        transport: this.getTransportInfo(),
                        state: SessionState.describe(this.getSessionState())
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.Session = Session;
        },
        "./modules/solclient-session/lib/ssl-downgrades.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SslDowngrade = {
                NONE: "NONE",
                PLAINTEXT: "PLAIN_TEXT"
            };
            module.exports.SslDowngrade = Enum.new(SslDowngrade);
        },
        "./modules/solclient-session/lib/subscription-update-timeout-messages.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                SessionRequestType
            } = __webpack_require__("./modules/solclient-session/lib/session-request-types.js");
            module.exports = {
                SubscriptionUpdateTimeoutMessages: {
                    [SessionRequestType.ADD_SUBSCRIPTION]: "Add subscription request timeout",
                    [SessionRequestType.REMOVE_SUBSCRIPTION]: "Remove subscription request timeout",
                    [SessionRequestType.ADD_P2PINBOX]: "Add P2P inbox subscription timeout",
                    [SessionRequestType.REMOVE_P2PINBOX]: "Remove P2P inbox subscription timeout",
                    [SessionRequestType.REMOVE_DTE_SUBSCRIPTION]: "Remove endpoint topic subscription",
                    default: "Request timeout"
                }
            };
        },
        "./modules/solclient-smf/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const CodecLib = __webpack_require__("./modules/solclient-smf/lib/codec/api.js");
            const {
                AdProtocolMessage,
                BinaryMetaBlock,
                ClientCtrlMessage,
                KeepAliveMessage,
                SMPMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                SMFAdProtocolMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-message-types.js");
            const {
                SMFAdProtocolParam
            } = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-params.js");
            const {
                SMFClientCtrlMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-message-types.js");
            const {
                SMFClientCtrlParam
            } = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-params.js");
            const {
                SMFParameterType,
                SMFExtendedParameterType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-parameter-types.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            const {
                SMFSMPMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-types.js");
            const {
                SMFSMPMessageTypeFlags
            } = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-type-flags.js");
            const {
                SMFTransportSessionMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-transport-session-message-types.js");
            module.exports.AdProtocolMessage = AdProtocolMessage;
            module.exports.BinaryMetaBlock = BinaryMetaBlock;
            module.exports.ClientCtrlMessage = ClientCtrlMessage;
            module.exports.Codec = CodecLib;
            module.exports.KeepAliveMessage = KeepAliveMessage;
            module.exports.SMFAdProtocolMessageType = SMFAdProtocolMessageType;
            module.exports.SMFAdProtocolParam = SMFAdProtocolParam;
            module.exports.SMFClientCtrlMessageType = SMFClientCtrlMessageType;
            module.exports.SMFClientCtrlParam = SMFClientCtrlParam;
            module.exports.SMFParameterType = SMFParameterType;
            module.exports.SMFProtocol = SMFProtocol;
            module.exports.SMFSMPMessageTypeFlags = SMFSMPMessageTypeFlags;
            module.exports.SMFSMPMessageType = SMFSMPMessageType;
            module.exports.SMFTransportSessionMessageType = SMFTransportSessionMessageType;
            module.exports.SMPMessage = SMPMessage;
            module.exports.SMFExtendedParameterType = SMFExtendedParameterType;
        },
        "./modules/solclient-smf/lib/codec/adprotocol.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                AdProtocolMessage,
                SMFParameter
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_DEBUG,
                LOG_INFO,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                ReplayStartType
            } = __webpack_require__("./modules/solclient-replaystart/api.js");
            const {
                get: bits,
                set: setBits
            } = Bits;
            const {
                int8ToStr,
                int16ToStr,
                int24ToStr,
                int32ToStr
            } = Convert;
            function parseAdpAt(dataBuf, offset) {
                if (offset + 3 > dataBuf.length) {
                    LOG_DEBUG("Not enough data to read an ADP message.");
                    return false;
                }
                let pos = offset;
                let onebyte = dataBuf.readUInt8(pos);
                pos++;
                const adpVersion = bits(onebyte, 0, 6);
                let msgLength;
                let msgType;
                if (adpVersion < 3) {
                    const twobyte = dataBuf.readUInt16BE(pos);
                    pos += 2;
                    msgType = bits(twobyte, 12, 4);
                    msgLength = bits(twobyte, 0, 12);
                    msgLength <<= 2;
                } else if (adpVersion === 3) {
                    onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    msgType = bits(onebyte, 0, 8);
                    msgLength = dataBuf.readUInt32BE(pos);
                    pos += 4;
                } else {
                    LOG_ERROR("Found unsupported ADP Version", adpVersion);
                    return false;
                }
                if (offset + msgLength > dataBuf.length) {
                    LOG_ERROR(`Invalid Asssured Control Protocol length=${msgLength} exceeds remaining message buffer = ${dataBuf.length - offset}`);
                    return false;
                }
                const adpMsg = new AdProtocolMessage(msgType, adpVersion);
                while (pos < offset + msgLength) {
                    onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    const paramUH = bits(onebyte, 6, 2);
                    const paramType = bits(onebyte, 0, 6);
                    if (paramType === 0) {
                        continue;
                    }
                    if (pos >= offset + msgLength) {
                        LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} at position =${pos}`);
                        return false;
                    }
                    let paramLen = dataBuf.readUInt8(pos);
                    let paramValueLen;
                    pos++;
                    if (paramLen === 0) {
                        if (pos + 5 > offset + msgLength) {
                            LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} at position =${pos}`);
                            return false;
                        }
                        paramLen = dataBuf.readUInt32BE(pos);
                        pos += 4;
                        paramValueLen = paramLen - 5;
                    } else {
                        paramValueLen = paramLen - 2;
                    }
                    if (paramLen <= 0) {
                        return false;
                    }
                    if (pos + paramValueLen > offset + msgLength) {
                        LOG_ERROR(`Invalid Asssured Control Protocol parameter=${paramType} length =${paramValueLen} invalid at position =${pos}`);
                        return false;
                    }
                    const smfParam = new SMFParameter(paramUH, paramType, null, dataBuf, pos, pos + paramValueLen);
                    adpMsg.addParameter(smfParam);
                    pos += paramValueLen;
                }
                return adpMsg;
            }
            function encAdp0Param(uh, paramtype) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(2));
                return data.join("");
            }
            function encAdp8Param(uh, paramtype, value) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(3));
                data.push(Convert.int8ToStr(value));
                return data.join("");
            }
            function encAdp16Param(uh, paramtype, value) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(4));
                data.push(Convert.int16ToStr(value));
                return data.join("");
            }
            function encAdp32Param(uh, paramtype, value) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(6));
                data.push(Convert.int32ToStr(value));
                return data.join("");
            }
            function encAdp64Param(uh, paramtype, value) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(10));
                data.push(Convert.int64ToStr(value));
                return data.join("");
            }
            const RSValueLenMap = {};
            RSValueLenMap[ReplayStartType.BEGINNING] = 3;
            RSValueLenMap[ReplayStartType.DATE] = 11;
            RSValueLenMap[ReplayStartType.RGMID] = 19;
            function encAdpReplayParam(uh, paramtype, value) {
                const data = [];
                const valType = value.type;
                const valObj = value.value;
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(RSValueLenMap[valType]));
                data.push(Convert.int8ToStr(valType));
                switch (valType) {
                  case ReplayStartType.DATE:
                    data.push(Convert.int64ToStr(valObj));
                    break;

                  case ReplayStartType.RGMID:
                    data.push(Convert.int64ToStr(valObj.suid));
                    data.push(Convert.int64ToStr(valObj.messageId));
                    break;

                  case ReplayStartType.BEGINNING:
                    break;

                  default:
                    break;
                }
                return data.join("");
            }
            function encAdp64AckPairParam(uh, paramtype, min, max) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                data.push(Convert.int8ToStr(18));
                data.push(Convert.int64ToStr(min));
                data.push(Convert.int64ToStr(max));
                return data.join("");
            }
            function encAdpUTF8NTParam(uh, paramtype, value) {
                const data = [];
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh, 6, 2);
                byte1 = Bits.set(byte1, paramtype, 0, 6);
                data.push(Convert.int8ToStr(byte1));
                let byte2 = 0;
                if (value.length <= 253) {
                    byte2 = value.length + 2;
                    data.push(Convert.int8ToStr(byte2));
                } else {
                    byte2 = 0;
                    data.push(Convert.int8ToStr(byte2));
                    data.push(Convert.int32ToStr(value.length + 5));
                }
                data.push(value);
                return data.join("");
            }
            function encAdp(adpMsg) {
                const paramspace = [];
                const paramarray = adpMsg.getParameterArray();
                let p;
                for (p = 0; p < paramarray.length; p++) {
                    const param = paramarray[p];
                    if (param === undefined) {
                        continue;
                    }
                    switch (param.getType()) {
                      case SMFLib.SMFAdProtocolParam.WINDOW:
                      case SMFLib.SMFAdProtocolParam.EP_DURABLE:
                      case SMFLib.SMFAdProtocolParam.ACCESSTYPE:
                      case SMFLib.SMFAdProtocolParam.FLOWTYPE:
                      case SMFLib.SMFAdProtocolParam.EP_RESPECTS_TTL:
                      case SMFLib.SMFAdProtocolParam.TRANSACTION_CTRL_MESSAGE_TYPE:
                      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_STATE:
                      case SMFLib.SMFAdProtocolParam.ACTIVE_FLOW_INDICATION:
                      case SMFLib.SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY:
                      case SMFLib.SMFAdProtocolParam.MAX_REDELIVERY:
                        paramspace.push(encAdp8Param(param.getUh(), param.getType(), param.getValue()));
                        break;

                      case SMFLib.SMFAdProtocolParam.EP_BEHAVIOUR:
                        paramspace.push(encAdp16Param(param.getUh(), param.getType(), param.getValue()));
                        break;

                      case SMFLib.SMFAdProtocolParam.FLOWID:
                      case SMFLib.SMFAdProtocolParam.TRANSPORT_WINDOW:
                      case SMFLib.SMFAdProtocolParam.EP_ALLOTHER_PERMISSION:
                      case SMFLib.SMFAdProtocolParam.EP_QUOTA:
                      case SMFLib.SMFAdProtocolParam.EP_MAX_MSGSIZE:
                      case SMFLib.SMFAdProtocolParam.GRANTED_PERMISSION:
                      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_ID:
                      case SMFLib.SMFAdProtocolParam.PUBLISHER_ID:
                        paramspace.push(encAdp32Param(param.getUh(), param.getType(), param.getValue()));
                        break;

                      case SMFLib.SMFAdProtocolParam.LASTMSGIDSENT:
                      case SMFLib.SMFAdProtocolParam.LASTMSGIDACKED:
                      case SMFLib.SMFAdProtocolParam.LASTMSGIDRECEIVED:
                      case SMFLib.SMFAdProtocolParam.TRANSACTION_ID:
                      case SMFLib.SMFAdProtocolParam.ENDPOINT_ERROR_ID:
                        paramspace.push(encAdp64Param(param.getUh(), param.getType(), param.getValue()));
                        break;

                      case SMFLib.SMFAdProtocolParam.REPLAY_START_LOCATION:
                        {
                            const replayParamVal = param.getValue();
                            if (undefined === replayParamVal.value) {
                                paramspace.push(encAdp8Param(param.getUh(), param.getType(), replayParamVal.type));
                            } else {
                                paramspace.push(encAdpReplayParam(param.getUh(), param.getType(), replayParamVal));
                            }
                            break;
                        }

                      case SMFLib.SMFAdProtocolParam.APPLICATION_ACK:
                        {
                            const ranges = param.getValue();
                            const uh = param.getUh();
                            const type = param.getType();
                            for (let i = 0; i < ranges.length; ++i) {
                                const range = ranges[i];
                                paramspace.push(encAdp64AckPairParam(uh, type, range[0], range[1]));
                            }
                            break;
                        }

                      case SMFLib.SMFAdProtocolParam.QUEUENAME:
                      case SMFLib.SMFAdProtocolParam.DTENAME:
                      case SMFLib.SMFAdProtocolParam.TOPICNAME:
                      case SMFLib.SMFAdProtocolParam.FLOWNAME:
                      case SMFLib.SMFAdProtocolParam.SELECTOR:
                      case SMFLib.SMFAdProtocolParam.TRANSACTED_SESSION_NAME:
                        paramspace.push(encAdpUTF8NTParam(param.getUh(), param.getType(), param.getValue()));
                        break;

                      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY:
                        break;

                      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK:
                        break;

                      case SMFLib.SMFAdProtocolParam.TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK:
                        break;

                      case SMFLib.SMFAdProtocolParam.NOLOCAL:
                      case SMFLib.SMFAdProtocolParam.CUT_THROUGH:
                        paramspace.push(encAdp0Param(param.getUh(), param.getType()));
                        break;

                      case SMFLib.SMFAdProtocolParam.APPLICATION_PUB_ACK:
                        break;

                      default:
                        LOG_INFO("Unrecognized ADProtocol Parameter in Message");
                        break;
                    }
                }
                const paramdata = paramspace.join("");
                const data = [];
                if (adpMsg.version === 2) {
                    let threebytes = 0;
                    threebytes = setBits(threebytes, 0, 22, 2);
                    threebytes = setBits(threebytes, adpMsg.version, 16, 6);
                    threebytes = setBits(threebytes, adpMsg.msgType, 12, 4);
                    let padBytes = 4 - (3 + paramdata.length & 3);
                    const length = 3 + paramdata.length + padBytes >> 2;
                    threebytes = setBits(threebytes, length, 0, 12);
                    data.push(int24ToStr(threebytes));
                    data.push(paramdata);
                    if (padBytes === 4) padBytes = 0;
                    while (padBytes > 0) {
                        data.push(int8ToStr(0));
                        padBytes--;
                    }
                } else if (adpMsg.version === 3) {
                    let twobytes = 0;
                    twobytes = setBits(twobytes, 0, 14, 2);
                    twobytes = setBits(twobytes, adpMsg.version, 8, 6);
                    twobytes = setBits(twobytes, adpMsg.msgType, 0, 8);
                    data.push(int16ToStr(twobytes));
                    data.push(int32ToStr(6 + paramdata.length));
                    data.push(paramdata);
                } else {
                    LOG_ERROR(`Invalid Version ${adpMsg.version} found while encoding`);
                }
                return data.join("");
            }
            module.exports.parseAdpAt = parseAdpAt;
            module.exports.encAdp = encAdp;
        },
        "./modules/solclient-smf/lib/codec/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ContentSummaryType
            } = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js");
            const {
                Decode
            } = __webpack_require__("./modules/solclient-smf/lib/codec/decode.js");
            const {
                Encode
            } = __webpack_require__("./modules/solclient-smf/lib/codec/encode.js");
            const {
                ParamParse
            } = __webpack_require__("./modules/solclient-smf/lib/codec/param-parse.js");
            const {
                ParseSMF
            } = __webpack_require__("./modules/solclient-smf/lib/codec/parse-smf.js");
            const {
                Transport
            } = __webpack_require__("./modules/solclient-smf/lib/codec/transport.js");
            module.exports.ContentSummaryType = ContentSummaryType;
            module.exports.Encode = Encode;
            module.exports.Decode = Decode;
            module.exports.ParamParse = ParamParse;
            module.exports.ParseSMF = ParseSMF;
            module.exports.Transport = Transport;
        },
        "./modules/solclient-smf/lib/codec/client-ctrl.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                ClientCtrlMessage,
                SMFParameter
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                get: bits,
                set: setBits
            } = Bits;
            const {
                int8ToStr,
                int16ToStr,
                int32ToStr
            } = Convert;
            function parseCCAt(dataBuf, offset, payloadLen) {
                const ccMsg = new ClientCtrlMessage();
                if (payloadLen < 6 || offset + 6 > dataBuf.length) {
                    return ccMsg;
                }
                let pos = offset;
                const twobytes = dataBuf.readUInt16BE(pos);
                pos += 2;
                const version = bits(twobytes, 8, 3);
                const msgType = bits(twobytes, 0, 8);
                const len = dataBuf.readUInt32BE(pos);
                pos += 4;
                if (version !== 1) {
                    LOG_ERROR(`Unsupported ClientCtrl version ${version}`);
                    return false;
                }
                if (len <= 0 || offset + len > dataBuf.length) {
                    return false;
                }
                ccMsg.msgType = msgType;
                ccMsg.version = version;
                while (pos < offset + len) {
                    const onebyte = dataBuf.readUInt8(pos);
                    pos++;
                    const paramUh = bits(onebyte, 7, 1);
                    const paramType = bits(onebyte, 0, 7);
                    const paramLen = dataBuf.readUInt32BE(pos);
                    if (paramLen <= 0) {
                        return false;
                    }
                    pos += 4;
                    const paramValueLen = paramLen - 5;
                    const smfP = new SMFParameter(paramUh, paramType, null, dataBuf, pos, pos + paramValueLen);
                    ccMsg.addParameter(smfP);
                    pos += paramValueLen;
                }
                return ccMsg;
            }
            function encCC(ccMsg) {
                const paramSpace = [];
                const paramArray = ccMsg.getParameterArray();
                for (let p = 0, n = paramArray.length; p < n; ++p) {
                    const currentParam = paramArray[p];
                    if (currentParam === undefined) {
                        continue;
                    }
                    let currentParamOneByte = 0;
                    currentParamOneByte = setBits(currentParamOneByte, currentParam.getUh(), 7, 1);
                    currentParamOneByte = setBits(currentParamOneByte, currentParam.getType(), 0, 7);
                    paramSpace.push(int8ToStr(currentParamOneByte));
                    paramSpace.push(int32ToStr(currentParam.getValue().length + 5));
                    paramSpace.push(currentParam.getValue());
                }
                const paramData = paramSpace.join("");
                let twobytes = 0;
                twobytes = setBits(twobytes, 0, 15, 1);
                twobytes = setBits(twobytes, 0, 11, 4);
                twobytes = setBits(twobytes, 1, 8, 3);
                twobytes = setBits(twobytes, ccMsg.msgType, 0, 8);
                const data = [];
                data.push(int16ToStr(twobytes));
                data.push(int32ToStr(6 + paramData.length));
                data.push(paramData);
                return data.join("");
            }
            module.exports.parseCCAt = parseCCAt;
            module.exports.encCC = encCC;
        },
        "./modules/solclient-smf/lib/codec/content-summary-element.js": module => {
            class ContentSummaryElement {
                constructor(type = null, position = 0, length = 0) {
                    this.type = type;
                    this.position = position;
                    this.length = length;
                }
            }
            module.exports.ContentSummaryElement = ContentSummaryElement;
        },
        "./modules/solclient-smf/lib/codec/content-summary-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const ContentSummaryType = {
                XML_META: 0,
                XML_PAYLOAD: 1,
                BINARY_ATTACHMENT: 2,
                CID_LIST: 3,
                BINARY_METADATA: 4
            };
            module.exports.ContentSummaryType = Enum.new(ContentSummaryType);
        },
        "./modules/solclient-smf/lib/codec/decode.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const SolclientDestinationLib = __webpack_require__("./modules/solclient-destination/api.js");
            const SolclientMessageLib = __webpack_require__("./modules/solclient-message/api.js");
            const SolclientSDTLib = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                BinaryMetaBlock,
                KeepAliveMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                ContentSummaryType
            } = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js");
            const {
                Hex,
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                parseAdpAt
            } = __webpack_require__("./modules/solclient-smf/lib/codec/adprotocol.js");
            const {
                parseCCAt
            } = __webpack_require__("./modules/solclient-smf/lib/codec/client-ctrl.js");
            const {
                ParseSMF
            } = __webpack_require__("./modules/solclient-smf/lib/codec/parse-smf.js");
            const {
                PriorityUserCosMap
            } = __webpack_require__("./modules/solclient-smf/lib/codec/priority-user-cos-map.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            const {
                SMP
            } = __webpack_require__("./modules/solclient-smf/lib/codec/smp.js");
            const {
                Transport
            } = __webpack_require__("./modules/solclient-smf/lib/codec/transport.js");
            const {
                formatHexString
            } = Hex;
            const {
                lazyValue
            } = Lazy;
            const {
                parseSMFAt
            } = ParseSMF;
            const {
                parseSMPAt
            } = SMP;
            const {
                parseTsSmfMsgAt
            } = Transport;
            const logger = new LogFormatter("[smf-decode]");
            const {
                LOG_DEBUG,
                LOG_ERROR
            } = logger;
            const userCosForPriority = lazyValue(() => new PriorityUserCosMap().reverse);
            const BIN_STRUCTYPES = {
                10: SolclientMessageLib.MessageType.MAP,
                11: SolclientMessageLib.MessageType.STREAM,
                7: SolclientMessageLib.MessageType.TEXT
            };
            function adaptBinaryMetaToMessage(binaryMeta, messageIn) {
                const message = messageIn;
                const messageSdt = SolclientSDTLib.Codec.parseSingleElement(binaryMeta.payload, 0);
                if (!(messageSdt && messageSdt.getType() === SolclientSDTLib.SDTFieldType.STREAM)) {
                    return;
                }
                const sdtstream = messageSdt.getValue();
                let sdtfield = sdtstream.getNext();
                if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.BYTEARRAY && sdtfield._value && sdtfield._value.length > 0) {
                    const preambleByte0 = sdtfield._value.readUInt8(0);
                    if ((preambleByte0 & 128) === 0) {
                        message._messageType = BIN_STRUCTYPES[preambleByte0 & 15] || SolclientMessageLib.MessageType.BINARY;
                    }
                    if (sdtfield._value.length > 1) {
                        const preambleByte1 = sdtfield._value.readUInt8(1);
                        message.setAsReplyMessage((preambleByte1 & 128) !== 0);
                    }
                }
                sdtfield = sdtstream.getNext();
                if (sdtfield && sdtfield.getType() === SolclientSDTLib.SDTFieldType.MAP) {
                    const sdtMap = sdtfield.getValue();
                    const p = sdtMap.getField("p");
                    const h = sdtMap.getField("h");
                    if (p) {
                        message.setUserPropertyMap(p.getValue());
                    }
                    if (h) {
                        const headerMap = h.getValue();
                        const ci = headerMap.getField("ci");
                        const mi = headerMap.getField("mi");
                        const mt = headerMap.getField("mt");
                        const rt = headerMap.getField("rt");
                        const si = headerMap.getField("si");
                        const sn = headerMap.getField("sn");
                        const ts = headerMap.getField("ts");
                        const ex = headerMap.getField("ex");
                        if (ci) {
                            message.setCorrelationId(ci.getValue());
                        }
                        if (mi) {
                            message.setApplicationMessageId(mi.getValue());
                        }
                        if (mt) {
                            message.setApplicationMessageType(mt.getValue());
                        }
                        if (rt) {
                            message.setReplyTo(rt.getValue());
                        }
                        if (si) {
                            message.setSenderId(si.getValue());
                        }
                        if (sn) {
                            message.setSequenceNumber(sn.getValueNoThrow());
                        }
                        if (ts) {
                            message.setSenderTimestamp(ts.getValue());
                        }
                        if (ex) {
                            message.setGMExpiration(ex.getValue());
                        }
                    }
                }
            }
            function adaptSmfToMessage(smfHeader, messageIn, stream, offset) {
                const message = messageIn;
                message._setDeliverToOne(!!smfHeader.smf_dto);
                message._setDeliveryMode(smfHeader.pm_deliverymode || SolclientMessageLib.MessageDeliveryModeType.DIRECT);
                if (smfHeader.pm_tr_topicname_bytes !== null) {
                    message._setDestination(SolclientDestinationLib.DestinationFromNetwork.createDestinationFromBytes(smfHeader.pm_tr_topicname_bytes));
                }
                message._setDiscardIndication(!!smfHeader.smf_di);
                message._setElidingEligible(!!smfHeader.smf_elidingEligible);
                message._setDMQEligible(!!smfHeader.smf_deadMessageQueueEligible);
                message._setUserCos(userCosForPriority.value.get(smfHeader.smf_priority));
                message._setPriority(smfHeader.pm_msg_priority);
                if (smfHeader.pm_userdata) message._setUserData(smfHeader.pm_userdata);
                message.setRedelivered(!!smfHeader.pm_ad_redelflag || !!smfHeader.pm_ad_flowredelflag);
                message.setFlowId(smfHeader.pm_ad_flowid);
                message.setGuaranteedMessageId(smfHeader.pm_ad_msgid);
                message.setGuaranteedPreviousMessageId(smfHeader.pm_ad_prevmsgid);
                message.setPublisherId(smfHeader.pm_ad_publisherid);
                message.setPublisherMessageId(smfHeader.pm_ad_publishermsgid);
                message.setTopicSequenceNumber(smfHeader.pm_ad_topicSequenceNumber);
                if (message.getDeliveryMode() === SolclientMessageLib.MessageDeliveryModeType.DIRECT) {
                    message.setDeliveryCount(-1);
                } else if (smfHeader.pm_ad_redeliveryCount) {
                    message.setDeliveryCount(smfHeader.pm_ad_redeliveryCount + 1);
                } else {
                    message.setDeliveryCount(1);
                }
                if (smfHeader.pm_ad_spooler_unique_id) {
                    message._setSpoolerUniqueId(smfHeader.pm_ad_spooler_unique_id);
                }
                if (smfHeader.pm_ad_replication_mate_ack_message_id) {
                    message._setSpoolerMessageId(smfHeader.pm_ad_replication_mate_ack_message_id);
                } else if (smfHeader.pm_ad_local_spooler_message_id) {
                    message._setSpoolerMessageId(smfHeader.pm_ad_local_spooler_message_id);
                }
                if (Long.isLong(smfHeader.pm_ad_ttl)) {
                    message.setTimeToLive(smfHeader.pm_ad_ttl.toNumber());
                } else {
                    message.setTimeToLive(smfHeader.pm_ad_ttl);
                }
                const payloadOffset = offset + smfHeader.headerLength;
                const cs = smfHeader.pm_content_summary;
                if (!(cs && cs.length)) {
                    message._setBinaryAttachment(smfHeader.payloadLength > 0 ? stream.slice(payloadOffset, payloadOffset + smfHeader.payloadLength) : undefined);
                    return;
                }
                for (let i = 0, n = cs.length; i < n; ++i) {
                    const currentChunk = cs[i];
                    const chunkBegin = payloadOffset + currentChunk.position;
                    const chunkEnd = payloadOffset + currentChunk.position + currentChunk.length;
                    switch (currentChunk.type) {
                      case ContentSummaryType.BINARY_ATTACHMENT:
                        message._setBinaryAttachment(stream.slice(chunkBegin, chunkEnd));
                        break;

                      case ContentSummaryType.BINARY_METADATA:
                        {
                            const binaryMeta = BinaryMetaBlock.fromEncodedSmf(stream, chunkBegin);
                            message.binaryMetadataChunk = binaryMeta;
                            if (binaryMeta.type === 0) {
                                adaptBinaryMetaToMessage(binaryMeta, message);
                            }
                            break;
                        }

                      case ContentSummaryType.XML_META:
                        message._setXmlMetadata(stream.toString("latin1", chunkBegin, chunkEnd));
                        break;

                      case ContentSummaryType.XML_PAYLOAD:
                        message._setXmlContentInternal(stream.toString("latin1", chunkBegin, chunkEnd));
                        break;

                      default:
                        LOG_ERROR(`Unhandled ContentSummaryType: ${ContentSummaryType.describe(currentChunk.type)}`);
                    }
                }
            }
            function decodeCompoundMessage(dataBuf, pos) {
                const header = parseSMFAt(dataBuf, pos);
                if (!header) {
                    LOG_DEBUG("decodeCompoundMessage: SMF parsing failed");
                    return null;
                }
                const payloadPosition = pos + header.headerLength;
                const payloadLen = header.payloadLength;
                let message;
                switch (header.smf_protocol) {
                  case SMFProtocol.TSESSION:
                    message = parseTsSmfMsgAt(dataBuf, payloadPosition, header);
                    if (!message) break;
                    message.smfHeader = header;
                    return message;

                  case SMFProtocol.TRMSG:
                    message = new SolclientMessageLib.Message();
                    message._smfHeader = header;
                    adaptSmfToMessage(header, message, dataBuf, pos);
                    return message;

                  case SMFProtocol.ADCTRL:
                    message = parseAdpAt(dataBuf, payloadPosition, payloadLen);
                    message.smfHeader = header;
                    return message;

                  case SMFProtocol.CLIENTCTRL:
                    message = parseCCAt(dataBuf, payloadPosition, payloadLen);
                    if (!message) break;
                    message.smfHeader = header;
                    return message;

                  case SMFProtocol.SMP:
                    message = parseSMPAt(dataBuf, payloadPosition);
                    if (!message) break;
                    message.smfHeader = header;
                    return message;

                  case SMFProtocol.KEEPALIVE:
                  case SMFProtocol.KEEPALIVEV2:
                    message = new KeepAliveMessage();
                    message.smfHeader = header;
                    return message;

                  default:
                    LOG_ERROR(`Unknown protocol: 0x${formatHexString(header.smf_protocol)}, ` + `dump message content: \n${DebugLib.Debug.formatDumpBytes(dataBuf.slice(pos, pos + header.messageLength).toString("latin1"), true, 0)}`);
                    break;
                }
                return null;
            }
            const Decode = {
                decodeCompoundMessage: decodeCompoundMessage
            };
            module.exports.Decode = Decode;
        },
        "./modules/solclient-smf/lib/codec/encode.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
            const {
                Base64,
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                BinaryMetaBlock,
                SMFHeader,
                SMPMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ClientCtrlMessage,
                KeepAliveMessage,
                AdProtocolMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                Codec: SDTCodec
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                ContentSummaryElement
            } = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-element.js");
            const {
                ContentSummaryType
            } = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                encAdp
            } = __webpack_require__("./modules/solclient-smf/lib/codec/adprotocol.js");
            const {
                encCC
            } = __webpack_require__("./modules/solclient-smf/lib/codec/client-ctrl.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LOG_TRACE,
                LOG_INFO
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                ParamParse
            } = __webpack_require__("./modules/solclient-smf/lib/codec/param-parse.js");
            const {
                PriorityUserCosMap
            } = __webpack_require__("./modules/solclient-smf/lib/codec/priority-user-cos-map.js");
            const {
                SDTField,
                SDTFieldType,
                SDTMapContainer,
                SDTStreamContainer
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                SMFParameterType,
                SMFExtendedParameterType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-parameter-types.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            const {
                SMP
            } = __webpack_require__("./modules/solclient-smf/lib/codec/smp.js");
            const {
                encode: base64Encode
            } = Base64;
            const {
                set: setBits
            } = Bits;
            const {
                int8ToStr,
                int16ToStr,
                int24ToStr,
                int32ToStr,
                int64ToStr
            } = Convert;
            const {
                lazyValue
            } = Lazy;
            const {
                encContentSummary,
                encDeliveryMode,
                encLightSMFParam,
                encodeSMFParam,
                encodeSMFExtendedParam
            } = ParamParse;
            const {
                encodeSingleElement
            } = SDTCodec;
            const {
                encSmp
            } = SMP;
            const priorityForUserCos = lazyValue(() => new PriorityUserCosMap().forward);
            function addContentElementToArrays(csumm, payloadArray, dataChunk, cstype) {
                if (Check.anything(dataChunk) && dataChunk.length > 0) {
                    const cse = new ContentSummaryElement(cstype, NaN, dataChunk.length);
                    csumm.push(cse);
                    payloadArray.push(dataChunk);
                }
            }
            function addToMapIfPresent(headerMap, key, type, value) {
                if (Check.anything(value)) {
                    headerMap.addField(key, SDTField.create(type, value));
                }
            }
            function adaptMessageToBinaryMeta(message) {
                let result;
                const headerMap = new SDTMapContainer();
                addToMapIfPresent(headerMap, "ci", SDTFieldType.STRING, message.getCorrelationId());
                addToMapIfPresent(headerMap, "mi", SDTFieldType.STRING, message.getApplicationMessageId());
                addToMapIfPresent(headerMap, "mt", SDTFieldType.STRING, message.getApplicationMessageType());
                addToMapIfPresent(headerMap, "rt", SDTFieldType.DESTINATION, message.getReplyTo());
                addToMapIfPresent(headerMap, "si", SDTFieldType.STRING, message.getSenderId());
                addToMapIfPresent(headerMap, "sn", SDTFieldType.INT64, message.getSequenceNumber());
                addToMapIfPresent(headerMap, "ts", SDTFieldType.INT64, message.getSenderTimestamp());
                addToMapIfPresent(headerMap, "ex", SDTFieldType.INT64, message.getGMExpiration());
                const sdtMap = new SDTMapContainer();
                if (message.getUserPropertyMap()) {
                    sdtMap.addField("p", SDTField.create(SDTFieldType.MAP, message.getUserPropertyMap()));
                }
                if (headerMap.getKeys().length > 0) {
                    sdtMap.addField("h", SDTField.create(SDTFieldType.MAP, headerMap));
                }
                let preambleByte0 = 0;
                switch (message.getType()) {
                  case MessageLib.MessageType.BINARY:
                    preambleByte0 |= 128;
                    break;

                  case MessageLib.MessageType.MAP:
                    preambleByte0 |= 10;
                    result = encodeSingleElement(message._structuredContainer);
                    break;

                  case MessageLib.MessageType.STREAM:
                    preambleByte0 |= 11;
                    result = encodeSingleElement(message._structuredContainer);
                    break;

                  case MessageLib.MessageType.TEXT:
                    preambleByte0 |= 7;
                    result = encodeSingleElement(message._structuredContainer);
                    break;

                  default:
                    LOG_INFO(`Unhandled messageType: ${message.getType()}`);
                    break;
                }
                const preambleByte1 = message.isReplyMessage() ? 128 : 0;
                const sdtPreamble = SDTField.create(SDTFieldType.BYTEARRAY, String.fromCharCode(preambleByte0, preambleByte1));
                const sdtStreamContainer = new SDTStreamContainer();
                sdtStreamContainer.addField(sdtPreamble);
                sdtStreamContainer.addField(SDTField.create(SDTFieldType.MAP, sdtMap));
                const binaryMeta = new BinaryMetaBlock();
                binaryMeta.type = 0;
                binaryMeta.payload = encodeSingleElement(SDTField.create(SDTFieldType.STREAM, sdtStreamContainer));
                message.binaryMetadataChunk = binaryMeta;
                return result;
            }
            function adaptMessageToSmf_nonPayload(message, smfHeaderIn) {
                const smfHeader = smfHeaderIn;
                const deliveryMode = message.getDeliveryMode();
                smfHeader.smf_dto = message.isDeliverToOne();
                smfHeader.pm_deliverymode = deliveryMode;
                smfHeader.smf_adf = deliveryMode === MessageLib.MessageDeliveryModeType.DIRECT ? 0 : 1;
                smfHeader.smf_di = message.isDiscardIndication();
                smfHeader.smf_elidingEligible = message.isElidingEligible();
                smfHeader.smf_deadMessageQueueEligible = message.isDMQEligible();
                smfHeader.pm_ad_flowid = message.getFlowId();
                smfHeader.pm_ad_publisherid = message.getPublisherId();
                smfHeader.pm_ad_publishermsgId = message.getPublisherMessageId();
                smfHeader.pm_ad_msgid = message.getGuaranteedMessageId();
                smfHeader.pm_ad_prevmsgid = message.getGuaranteedPreviousMessageId();
                smfHeader.pm_ad_ttl = message.getTimeToLive();
                smfHeader.pm_ad_ackimm = message.isAcknowledgeImmediately();
                smfHeader.pm_ad_redelflag = message.isRedelivered();
                const dest = message.getDestination();
                if (dest) {
                    smfHeader.pm_tr_topicname_bytes = dest.getBytes();
                    if (dest.type === DestinationType.QUEUE || dest.type === DestinationType.TEMPORARY_QUEUE) {
                        const {
                            offset
                        } = dest;
                        smfHeader.pm_queue_len = smfHeader.pm_tr_topicname_bytes.length - offset;
                        smfHeader.pm_queue_offset = offset;
                    }
                }
                smfHeader.smf_priority = priorityForUserCos.value.get(message.getUserCos());
                if (message.getPriority() !== undefined && typeof message.getPriority() === "number" && message.getPriority() <= 255 && message.getPriority() >= 0) {
                    smfHeader.pm_msg_priority = message.getPriority();
                } else {
                    smfHeader.pm_msg_priority = null;
                }
                const userData = message.getUserData();
                smfHeader.pm_userdata = userData === null || userData === undefined ? null : message.getUserData();
            }
            function adaptMessageToSmf_payloadMemoize(message) {
                let encodedSdtPayload;
                if (message.getCorrelationId() || message.getApplicationMessageId() || message.getApplicationMessageType() || message.getReplyTo() || message.getSenderId() || message.getSequenceNumber() || message.getSenderTimestamp() || message.getUserPropertyMap() || message.isReplyMessage() || message.getType() !== MessageLib.MessageType.BINARY) {
                    encodedSdtPayload = adaptMessageToBinaryMeta(message);
                }
                const csumm = [];
                const payload = [];
                addContentElementToArrays(csumm, payload, message.getXmlMetadata(), ContentSummaryType.XML_META);
                addContentElementToArrays(csumm, payload, message.getXmlContent(), ContentSummaryType.XML_PAYLOAD);
                if (encodedSdtPayload) {
                    addContentElementToArrays(csumm, payload, encodedSdtPayload, ContentSummaryType.BINARY_ATTACHMENT);
                } else {
                    addContentElementToArrays(csumm, payload, message._binaryAttachment ? message._binaryAttachment.toString("latin1") : "", ContentSummaryType.BINARY_ATTACHMENT);
                }
                const binaryMeta = message.binaryMetadataChunk;
                if (binaryMeta !== null) {
                    const binaryMetaSMF = binaryMeta.asEncodedSmf();
                    const MAX_24BITS = 16777215;
                    if (binaryMetaSMF.length > MAX_24BITS) {
                        LOG_TRACE(`binary-meta data (${binaryMetaSMF.length}) over the ${MAX_24BITS} limit`);
                        throw new OperationError(`binary-meta data (${binaryMetaSMF.length}) over the ${MAX_24BITS} limit`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    } else {
                        addContentElementToArrays(csumm, payload, binaryMetaSMF, ContentSummaryType.BINARY_METADATA);
                    }
                }
                message._memoized_csumm = csumm;
                message._memoized_payload = payload.join("");
                message._payload_is_memoized = true;
                return message._memoized_payload ? message._memoized_payload.length : 0;
            }
            function adaptMessageToSmf_payloadFinalize(message, smfHeaderIn) {
                const smfHeader = smfHeaderIn;
                if (!message._payload_is_memoized) {
                    adaptMessageToSmf_payloadMemoize(message);
                }
                const csumm = message._memoized_csumm;
                const payloadBytes = message._memoized_payload;
                if (csumm.length === 0 || csumm.length === 1 && csumm[0].type === ContentSummaryType.BINARY_ATTACHMENT) {} else {
                    smfHeader.pm_content_summary = csumm;
                }
                smfHeader.payload = payloadBytes;
            }
            function adaptMessageToSmf(message, smfHeaderIn) {
                adaptMessageToSmf_payloadFinalize(message, smfHeaderIn);
                adaptMessageToSmf_nonPayload(message, smfHeaderIn);
            }
            const bitRange = bits => Array.from(Array(Math.pow(2, bits))).map((el, i) => i);
            const maskValues = (shift, bits) => bitRange(bits).map(val => setBits(0, val, shift, bits));
            const DI_BIT = maskValues(31, 1);
            const ELIDING_ELIGIBLE_BIT = maskValues(30, 1);
            const DTO_BIT = maskValues(29, 1);
            const ADF_BIT = maskValues(28, 1);
            const DMQE_BIT = maskValues(27, 1);
            const VERSION_BITS = maskValues(24, 3);
            const UH_BITS = maskValues(22, 2);
            const PROTOCOL_BITS = maskValues(16, 6);
            const PRIORITY_BITS = maskValues(12, 4);
            const TTL_BITS = maskValues(0, 8);
            const QT_OFFSET_BYTES = maskValues(8, 8);
            const QT_LEN_BYTES = maskValues(0, 8);
            function encodeSMF(header) {
                let w1 = 0;
                w1 |= DI_BIT[header.smf_di && 1 || 0];
                w1 |= ELIDING_ELIGIBLE_BIT[header.smf_elidingEligible && 1 || 0];
                w1 |= DTO_BIT[header.smf_dto && 1 || 0];
                w1 |= ADF_BIT[header.smf_adf && 1 || 0];
                w1 |= DMQE_BIT[header.smf_deadMessageQueueEligible && 1 || 0];
                w1 |= VERSION_BITS[header.smf_version || 0];
                w1 |= UH_BITS[header.smf_uh || 0];
                w1 |= PROTOCOL_BITS[header.smf_protocol || 0];
                w1 |= PRIORITY_BITS[header.smf_priority || 0];
                w1 |= TTL_BITS[header.smf_ttl || 0];
                const params = [];
                if (header.pm_tr_topicname_bytes) {
                    params.push(encodeSMFParam(2, SMFParameterType.TR_TOPICNAME, `${header.pm_tr_topicname_bytes}`));
                }
                if (header.pm_queue_len) {
                    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_QUEUE_NAME_OFFSET, int16ToStr(QT_OFFSET_BYTES[header.pm_queue_offset] | QT_LEN_BYTES[header.pm_queue_len])));
                }
                if (header.pm_topic_len) {
                    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_TOPIC_NAME_OFFSET, int16ToStr(QT_OFFSET_BYTES[header.pm_topic_offset] | QT_OFFSET_BYTES[header.pm_topic_len])));
                }
                if (header.pm_corrtag !== null && header.pm_corrtag !== undefined) {
                    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_CORRELATION, int24ToStr(header.pm_corrtag)));
                }
                if (header.pm_ad_ackimm) {
                    params.push(encLightSMFParam(0, SMFParameterType.LIGHT_ACK_IMMEDIATELY, ""));
                }
                if (header.pm_msg_priority !== null) {
                    params.push(encodeSMFParam(0, SMFParameterType.MESSAGEPRIORITY, int8ToStr(header.pm_msg_priority)));
                }
                if (header.pm_userdata !== null && header.pm_userdata !== "") {
                    params.push(encodeSMFParam(0, SMFParameterType.USERDATA, header.pm_userdata));
                }
                if (header.pm_username) {
                    params.push(encodeSMFParam(0, SMFParameterType.USERNAME, base64Encode(header.pm_username)));
                }
                if (header.pm_password) {
                    params.push(encodeSMFParam(0, SMFParameterType.PASSWORD, base64Encode(header.pm_password)));
                }
                if (header.pm_respcode) {
                    params.push(encodeSMFParam(0, SMFParameterType.RESPONSE, int32ToStr(header.pm_respcode) + header.pm_respstr));
                }
                if (header.pm_deliverymode !== null) {
                    params.push(encodeSMFParam(0, SMFParameterType.DELIVERY_MODE, encDeliveryMode(header.pm_deliverymode)));
                }
                if (header.pm_ad_msgid !== undefined) {
                    params.push(encodeSMFParam(2, SMFParameterType.ASSURED_MESSAGE_ID, int64ToStr(header.pm_ad_msgid)));
                    params.push(encodeSMFParam(2, SMFParameterType.ASSURED_PREVMESSAGE_ID, int64ToStr(header.pm_ad_prevmsgid)));
                }
                if (header.pm_ad_flowid) {
                    params.push(encodeSMFParam(0, SMFParameterType.ASSURED_FLOWID, int32ToStr(header.pm_ad_flowid)));
                }
                if (header.pm_ad_redelflag) {
                    params.push(encodeSMFParam(0, SMFParameterType.ASSURED_REDELIVERED_FLAG, undefined));
                }
                if (header.pm_ad_ttl !== undefined) {
                    params.push(encodeSMFParam(0, SMFParameterType.AD_TIMETOLIVE, int64ToStr(header.pm_ad_ttl)));
                }
                if (header.pm_ad_publisherid) {
                    params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_ID, int32ToStr(header.pm_ad_publisherid)));
                }
                if (header.pm_ad_publisherMsgId) {
                    params.push(encodeSMFParam(0, SMFParameterType.PUBLISHER_MSGID, int64ToStr(header.pm_ad_publisherMsgId)));
                }
                if (header.pm_content_summary) {
                    params.push(encodeSMFParam(2, SMFParameterType.MESSAGE_CONTENT_SUMMARY, encContentSummary(header.pm_content_summary)));
                }
                let extendedStreamContents = "";
                let extendedUH = 0;
                if (header.pm_oauth2_access_token) {
                    extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OAUTH2_ACCESS_TOKEN, header.pm_oauth2_access_token);
                    extendedUH = extendedUH || 0;
                }
                if (header.pm_oidc_id_token) {
                    extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OIDC_ID_TOKEN, header.pm_oidc_id_token);
                    extendedUH = extendedUH || 0;
                }
                if (header.pm_oauth2_issuer_identifier) {
                    extendedStreamContents += encodeSMFExtendedParam(0, SMFExtendedParameterType.OAUTH2_ISSUER_IDENTIFIER, header.pm_oauth2_issuer_identifier);
                    extendedUH = extendedUH || 0;
                }
                if (extendedStreamContents.length > 0) {
                    params.push(encodeSMFParam(extendedUH, SMFParameterType.EXTENDED_TYPE_STREAM, extendedStreamContents));
                }
                const encodedParams = params.join("");
                const hdrlen = 12 + encodedParams.length;
                const msglen = hdrlen + header.payloadLength;
                header.setMessageSizes(hdrlen, header.payloadLength);
                return int32ToStr(w1) + int32ToStr(hdrlen) + int32ToStr(msglen) + encodedParams;
            }
            function encodeCompoundMessage(msg) {
                let payload = "";
                if (msg instanceof MessageLib.Message) {
                    if (!msg.smfHeader) {
                        msg.smfHeader = new SMFHeader(SMFProtocol.TRMSG, 255);
                    }
                    adaptMessageToSmf(msg, msg._smfHeader);
                    payload = msg._smfHeader.payload;
                } else if (msg instanceof ClientCtrlMessage) {
                    payload = encCC(msg);
                } else if (msg instanceof SMPMessage) {
                    payload = encSmp(msg);
                } else if (msg instanceof KeepAliveMessage) {
                    LOG_TRACE("Skipping retrieve payload as there is none in a KeepAliveMessage");
                } else if (msg instanceof AdProtocolMessage) {
                    payload = encAdp(msg);
                }
                const header = msg.smfHeader;
                header.setPayloadSize(payload.length);
                const encodedHeader = encodeSMF(header);
                return encodedHeader + payload;
            }
            const Encode = {
                encodeCompoundMessage: encodeCompoundMessage,
                encodeSMF: encodeSMF,
                adaptMessageToSmf_payloadMemoize: adaptMessageToSmf_payloadMemoize
            };
            module.exports.Encode = Encode;
        },
        "./modules/solclient-smf/lib/codec/param-parse.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
            const {
                BidiMap,
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                ContentSummaryElement
            } = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-element.js");
            const {
                ContentSummaryType
            } = __webpack_require__("./modules/solclient-smf/lib/codec/content-summary-types.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SMFUH
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                lazyValue
            } = Lazy;
            const {
                int8ToStr,
                int16ToStr,
                int24ToStr,
                int32ToStr
            } = Convert;
            const delModeEnumBidiMap = lazyValue(() => {
                const source = [ [ 0, MessageLib.MessageDeliveryModeType.NON_PERSISTENT ], [ 1, MessageLib.MessageDeliveryModeType.PERSISTENT ], [ 2, MessageLib.MessageDeliveryModeType.DIRECT ] ].map(el => [ el[0], el[1] ]);
                return new BidiMap(...source);
            });
            const lutDelModeToEnum = lazyValue(() => delModeEnumBidiMap.value.forward);
            const lutEnumToDelMode = lazyValue(() => delModeEnumBidiMap.value.reverse);
            const uhTypeMap = (() => {
                const result = [];
                const paramTypeBits = 5;
                const paramTypeCount = Math.pow(2, paramTypeBits);
                SMFUH.values.forEach(uh => {
                    result[uh] = [];
                    for (let i = 0; i < paramTypeCount; ++i) {
                        let byte1 = 0;
                        byte1 = Bits.set(byte1, uh, 6, 2);
                        byte1 = Bits.set(byte1, i, 0, paramTypeBits);
                        result[uh][i] = int8ToStr(byte1);
                    }
                });
                return result;
            })();
            const lenMap = new Array(256).fill(null).map((_, idx) => int8ToStr(idx));
            const lightMap = (() => {
                const result = [];
                const paramTypeBits = 3;
                const paramTypeCount = Math.pow(2, paramTypeBits);
                const lenBits = 2;
                const lenCount = Math.pow(2, lenBits);
                SMFUH.values.forEach(uh => {
                    result[uh] = [];
                    for (let i = 0; i < paramTypeCount; ++i) {
                        result[uh][i] = [];
                        for (let j = 0; j < lenCount; ++j) {
                            let byte1 = 0;
                            byte1 = Bits.set(byte1, uh, 6, 2);
                            byte1 = Bits.set(byte1, 1, 5, 1);
                            byte1 = Bits.set(byte1, i, 2, 3);
                            byte1 = Bits.set(byte1, j, 0, 2);
                            result[uh][i][j] = int8ToStr(byte1);
                        }
                    }
                });
                return result;
            })();
            const ContentSummaryDecodeMap = [ ContentSummaryType.XML_META, ContentSummaryType.XML_PAYLOAD, ContentSummaryType.BINARY_ATTACHMENT, ContentSummaryType.CID_LIST, ContentSummaryType.BINARY_METADATA ];
            const ParamParse = {};
            ParamParse.parseTopicQueueOffsets = function parseTopicQueueOffsets(dataBuf, offset) {
                const result = [];
                result[0] = dataBuf.readUInt8(offset);
                result[1] = dataBuf.readUInt8(offset + 1);
                return result;
            };
            ParamParse.parseResponseParam = function parseResponseParam(dataBuf, offset, paramLen) {
                const result = [];
                result[0] = dataBuf.readInt32BE(offset);
                if (paramLen > 4) {
                    result[1] = dataBuf.toString("latin1", offset + 4, offset + paramLen);
                } else {
                    result[1] = "";
                }
                return result;
            };
            ParamParse.parseDeliveryMode = function parseDeliveryMode(dataBuf, offset) {
                const delmode = dataBuf.readUInt8(offset);
                const lookup = lutDelModeToEnum.value.get(delmode);
                return lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT;
            };
            ParamParse.encDeliveryMode = function encDeliveryMode(delmode) {
                const lut = lutEnumToDelMode.value;
                const lookup = lut.get(delmode);
                return int8ToStr(lookup !== undefined ? lookup : MessageLib.MessageDeliveryModeType.DIRECT);
            };
            ParamParse.parseContentSummary = function parseContentSummary(dataBuf, offset, length) {
                const elements = [];
                let cumulativeSize = 0;
                let pos = offset;
                while (pos < offset + length) {
                    const byte1 = dataBuf.readUInt8(pos);
                    const elementType = Bits.get(byte1, 4, 4);
                    const elementDeclaredLength = Bits.get(byte1, 0, 4);
                    let elementSize = 0;
                    switch (elementDeclaredLength) {
                      case 2:
                        elementSize = dataBuf.readUInt8(pos + 1);
                        break;

                      case 3:
                        elementSize = dataBuf.readUInt16BE(pos + 1);
                        break;

                      case 4:
                        elementSize = dataBuf.readUIntBE(pos + 1, 3);
                        break;

                      case 5:
                        elementSize = dataBuf.readInt32BE(pos + 1);
                        break;

                      default:
                        break;
                    }
                    if (elementDeclaredLength === 0) {
                        LOG_ERROR("Invalid content summary parameter - pos not advancing");
                        return null;
                    }
                    pos += elementDeclaredLength;
                    const cst = ContentSummaryDecodeMap[elementType];
                    if (cst === undefined) {
                        LOG_ERROR(`Unhandled element type ${elementType}`);
                    }
                    const currentElement = new ContentSummaryElement(cst, cumulativeSize, elementSize);
                    elements.push(currentElement);
                    cumulativeSize += elementSize;
                }
                return elements;
            };
            ParamParse.encContentSummary = function encContentSummary(contentSummaryArr) {
                const messageElementDescriptions = [];
                for (let i = 0, n = contentSummaryArr.length; i < n; ++i) {
                    const currentContentSummary = contentSummaryArr[i];
                    let currentSizeStr = "";
                    let firstByte = Bits.set(0, currentContentSummary.type, 4, 4);
                    if (currentContentSummary.length <= 255) {
                        firstByte = Bits.set(firstByte, 2, 0, 4);
                        currentSizeStr = int8ToStr(currentContentSummary.length);
                    } else if (currentContentSummary.length <= 65535) {
                        firstByte = Bits.set(firstByte, 3, 0, 4);
                        currentSizeStr = int16ToStr(currentContentSummary.length);
                    } else if (currentContentSummary.length <= 16777215) {
                        firstByte = Bits.set(firstByte, 4, 0, 4);
                        currentSizeStr = int24ToStr(currentContentSummary.length);
                    } else {
                        firstByte = Bits.set(firstByte, 5, 0, 4);
                        currentSizeStr = int32ToStr(currentContentSummary.length);
                    }
                    messageElementDescriptions.push(int8ToStr(firstByte));
                    messageElementDescriptions.push(currentSizeStr);
                }
                return messageElementDescriptions.join("");
            };
            ParamParse.encodeSMFParam = function encodeSMFParam(uh, paramtype, value) {
                if (value === undefined) {
                    return uhTypeMap[uh][paramtype] + lenMap[2];
                }
                const len = value.length;
                if (len <= 253) {
                    return uhTypeMap[uh][paramtype] + lenMap[len + 2] + value;
                }
                return uhTypeMap[uh][paramtype] + lenMap[0] + int32ToStr(len + 6) + value;
            };
            ParamParse.encodeSMFExtendedParam = function encodeSMFExtendedParam(uh, paramtype, value) {
                let byte1 = 0;
                byte1 = Bits.set(byte1, uh ? 1 : 0, 7, 1);
                const length = value === undefined || value === null ? 0 : value.length;
                const lengthModeMap = {
                    0: 0,
                    1: 1,
                    2: 2,
                    4: 3,
                    8: 4
                };
                let lengthMode = 0;
                let lengthString = "";
                if (Object.prototype.hasOwnProperty.call(lengthModeMap, length)) {
                    lengthMode = lengthModeMap[length];
                } else if (length < 253) {
                    lengthMode = 5;
                    lengthString = int8ToStr(length + 3);
                } else if (length < 256 * 256 - 4) {
                    lengthMode = 6;
                    lengthString = int16ToStr(length + 4);
                } else {
                    LOG_ERROR(`Extended parameter type ${paramtype} is too long (${length} bytes) `);
                    throw new OperationError(`Extended parameter (${paramtype}) over the 2^16 byte limit`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                }
                byte1 = Bits.set(byte1, lengthMode, 4, 3);
                byte1 = Bits.set(byte1, paramtype >> 8, 0, 4);
                const byte2 = paramtype & 255;
                return int8ToStr(byte1) + int8ToStr(byte2) + lengthString + value;
            };
            ParamParse.encLightSMFParam = function encLightSMFParam(uh, paramtype, value) {
                return lightMap[uh][paramtype][value.length] + value;
            };
            module.exports.ParamParse = ParamParse;
        },
        "./modules/solclient-smf/lib/codec/parse-smf.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const Long = __webpack_require__("./node_modules/long/umd/index.js");
            const {
                LOG_DEBUG,
                LOG_ERROR,
                LOG_INFO,
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Base64,
                Bits
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                ParamParse
            } = __webpack_require__("./modules/solclient-smf/lib/codec/param-parse.js");
            const {
                SMFHeader
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                SMFParameterType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-parameter-types.js");
            const {
                decode: base64Decode
            } = Base64;
            const {
                get: bits
            } = Bits;
            function isSMFHeaderAvailable(dataBuf, offset) {
                const remaining = dataBuf.length - offset;
                if (remaining < 12) {
                    return false;
                }
                return true;
            }
            function isSMFHeaderValid(dataBuf, offset) {
                if (!isSMFHeaderAvailable(dataBuf, offset)) {
                    return false;
                }
                const version = dataBuf.readUInt8(offset) & 7;
                if (version !== 3) {
                    LOG_ERROR(`Invalid smf version in smf header, version=${version}`);
                    return false;
                }
                return true;
            }
            function isSMFAvailable(dataBuf, offset) {
                if (!isSMFHeaderValid(dataBuf, offset)) {
                    return false;
                }
                const remaining = dataBuf.length - offset;
                const totalLen = dataBuf.readUInt32BE(offset + 8);
                return totalLen <= remaining;
            }
            function parseSMFExtendedStream(smfHeader, dataBuf, offset, streamLen) {
                let pos = offset;
                while (pos < offset + streamLen) {
                    if (pos + 2 > offset + streamLen) {
                        LOG_ERROR("Extended parameter stream had padding inside.");
                        break;
                    }
                    const byte1 = dataBuf.readUInt8(pos);
                    const byte2 = dataBuf.readUInt8(pos + 1);
                    const pUH = bits(byte1, 7, 1);
                    const lengthMode = bits(byte1, 4, 3);
                    const type = (bits(byte1, 0, 4) << 8) + byte2;
                    pos += 2;
                    const lengthModeMap = {
                        0: 0,
                        1: 1,
                        2: 2,
                        3: 4,
                        4: 8
                    };
                    let valueLen = 0;
                    if (Object.prototype.hasOwnProperty.call(lengthModeMap, lengthMode)) {
                        valueLen = lengthModeMap[lengthMode];
                    } else if (lengthMode === 5) {
                        valueLen = dataBuf.readUInt8(pos) - 3;
                        pos++;
                    } else if (lengthMode === 6) {
                        valueLen = dataBuf.readUInt16BE(pos) - 4;
                        pos += 2;
                    } else {
                        LOG_ERROR(`Invalid length mode ${lengthMode} in Extended Parameter type ${type}`);
                        return false;
                    }
                    switch (type) {
                      case SMFParameterType.AD_REDELIVERY_COUNT:
                        smfHeader.pm_ad_redeliveryCount = dataBuf.readUInt32BE(pos);
                        break;

                      case SMFParameterType.AD_SPOOLER_UNIQUE_ID:
                        smfHeader.pm_ad_spooler_unique_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                        break;

                      case SMFParameterType.AD_ACK_MESSAGE_ID:
                        smfHeader.pm_ad_local_spooler_message_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                        break;

                      case SMFParameterType.AD_REPL_MATE_ACK_MSGID:
                        smfHeader.pm_ad_replication_mate_ack_message_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                        break;

                      default:
                        if (pUH === 0) {
                            LOG_TRACE("Dropping unrecognised extended parameter " + `type ${type} value length ${valueLen} UH ${pUH}`);
                        } else {
                            smfHeader.discardMessage = true;
                            LOG_TRACE("Dropping whole message due to unrecognised extended parameter " + `type ${type} value length ${valueLen} UH ${pUH}`);
                        }
                        break;
                    }
                    pos += valueLen;
                }
                if (pos > offset + streamLen) {
                    LOG_ERROR(`Last extended parameter ran beyond extended stream length by ${pos - (offset + streamLen)}.`);
                }
                return true;
            }
            function parseSMFAt(dataBuf, offset, readHeaderOnly = false) {
                if (!isSMFHeaderValid(dataBuf, offset)) {
                    LOG_DEBUG("Valid SMF header not available");
                    return null;
                }
                let pos = offset;
                const word1 = dataBuf.readUInt32BE(pos);
                const headerLen = dataBuf.readUInt32BE(pos + 4);
                const word3 = dataBuf.readUInt32BE(pos + 8);
                const smfHeader = new SMFHeader();
                smfHeader.smf_di = bits(word1, 31, 1);
                smfHeader.smf_elidingEligible = bits(word1, 30, 1);
                smfHeader.smf_dto = bits(word1, 29, 1);
                smfHeader.smf_adf = bits(word1, 28, 1);
                smfHeader.smf_deadMessageQueueEligible = bits(word1, 27, 1);
                smfHeader.smf_version = bits(word1, 24, 3);
                smfHeader.smf_uh = bits(word1, 22, 2);
                smfHeader.smf_protocol = bits(word1, 16, 6);
                smfHeader.smf_priority = bits(word1, 12, 4);
                smfHeader.smf_ttl = bits(word1, 0, 8);
                const payloadLen = word3 - headerLen;
                if (payloadLen < 0) {
                    LOG_ERROR("SMF parse error: lost framing");
                    return null;
                }
                smfHeader.setMessageSizes(headerLen, payloadLen);
                if (readHeaderOnly) {
                    return smfHeader;
                }
                pos += 12;
                const end = offset + headerLen;
                while (pos < end) {
                    const paramByte1 = dataBuf.readUInt8(pos);
                    ++pos;
                    const prmUh = bits(paramByte1, 6, 2);
                    const paramIsLightweight = bits(paramByte1, 5, 1) !== 0;
                    if (paramIsLightweight) {
                        const lwpType = bits(paramByte1, 2, 3);
                        const lwpLen = bits(paramByte1, 0, 2) + 1;
                        const lwpValueLen = lwpLen - 1;
                        if (lwpLen <= 0) {
                            LOG_ERROR("Invalid lightweight parameter length");
                            return null;
                        }
                        switch (lwpType) {
                          case SMFParameterType.LIGHT_CORRELATION:
                            smfHeader.pm_corrtag = dataBuf.readUIntBE(pos, 3);
                            break;

                          case SMFParameterType.LIGHT_TOPIC_NAME_OFFSET:
                            {
                                const parsedQueueOffsets = ParamParse.parseTopicQueueOffsets(dataBuf, pos);
                                smfHeader.pm_queue_offset = parsedQueueOffsets[0];
                                smfHeader.pm_queue_len = parsedQueueOffsets[1];
                                break;
                            }

                          case SMFParameterType.LIGHT_QUEUE_NAME_OFFSET:
                            {
                                const parsedTopicOffsets = ParamParse.parseTopicQueueOffsets(dataBuf, pos);
                                smfHeader.pm_topic_offset = parsedTopicOffsets[0];
                                smfHeader.pm_topic_len = parsedTopicOffsets[1];
                                break;
                            }

                          case SMFParameterType.LIGHT_ACK_IMMEDIATELY:
                            smfHeader.pm_ad_ackimm = !!dataBuf.readUInt8(pos);
                            break;

                          default:
                            if (prmUh === 0) {
                                LOG_TRACE(`Unhandled LIGHTWEIGHT parameter type: ${lwpType} UH is ${prmUh} discarding parameter.`);
                            } else {
                                LOG_TRACE(`Unhandled LIGHTWEIGHT parameter type: ${lwpType} UH is ${prmUh} discarding message.`);
                                smfHeader.discardMessage = true;
                            }
                            break;
                        }
                        pos += lwpValueLen;
                    } else {
                        const pStart = pos;
                        const pType = bits(paramByte1, 0, 5);
                        if (pType === 0) {
                            break;
                        }
                        let pLen = dataBuf.readUInt8(pos);
                        pos++;
                        let pValueLen;
                        if (pLen === 0) {
                            pLen = dataBuf.readUInt32BE(pos);
                            pos += 4;
                            pValueLen = pLen - 6;
                        } else {
                            pValueLen = pLen - 2;
                        }
                        if (pLen <= 0) {
                            LOG_ERROR(`Invalid regular parameter length ${pLen}/${pValueLen} with suspect type ${SMFParameterType.describe(pType)} at parameter at position ${pStart}`);
                            return null;
                        }
                        switch (pType) {
                          case SMFParameterType.PUBLISHER_ID:
                            smfHeader.pm_ad_publisher_id = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.PUBLISHER_MSGID:
                            smfHeader.pm_ad_publishermsgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.MESSAGEPRIORITY:
                            smfHeader.pm_msg_priority = dataBuf.readUInt8(pos);
                            break;

                          case SMFParameterType.USERDATA:
                            smfHeader.pm_userdata = dataBuf.toString("latin1", pos, pos + pValueLen);
                            break;

                          case SMFParameterType.USERNAME:
                            smfHeader.pm_username = base64Decode(dataBuf.toString("latin1", pos, pos + pValueLen));
                            break;

                          case SMFParameterType.PASSWORD:
                            smfHeader.pm_password = base64Decode(dataBuf.toString("latin1", pos, pos + pValueLen));
                            break;

                          case SMFParameterType.RESPONSE:
                            {
                                const parsedResponse = ParamParse.parseResponseParam(dataBuf, pos, pValueLen);
                                smfHeader.pm_respcode = parsedResponse[0];
                                smfHeader.pm_respstr = parsedResponse[1];
                                break;
                            }

                          case SMFParameterType.SUB_ID_LIST:
                          case SMFParameterType.GENERIC_ATTACHMENT:
                          case SMFParameterType.BINARY_ATTACHMENT:
                            LOG_INFO("Skipping deprecated parameter type");
                            break;

                          case SMFParameterType.DELIVERY_MODE:
                            if (smfHeader.smf_adf) {
                                smfHeader.pm_deliverymode = ParamParse.parseDeliveryMode(dataBuf, pos);
                            }
                            break;

                          case SMFParameterType.ASSURED_MESSAGE_ID:
                            smfHeader.pm_ad_msgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.ASSURED_PREVMESSAGE_ID:
                            smfHeader.pm_ad_prevmsgid = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.ASSURED_REDELIVERED_FLAG:
                            smfHeader.pm_ad_redelflag = true;
                            break;

                          case SMFParameterType.AD_TIMETOLIVE:
                            smfHeader.pm_ad_ttl = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.AD_TOPICSEQUENCE_NUMBER:
                            smfHeader.pm_ad_topicSequenceNumber = Long.fromBits(dataBuf.readUInt32BE(pos + 4), dataBuf.readUInt32BE(pos), true);
                            break;

                          case SMFParameterType.MESSAGE_CONTENT_SUMMARY:
                            {
                                const contentSummary = ParamParse.parseContentSummary(dataBuf, pos, pValueLen);
                                if (!contentSummary) {
                                    LOG_ERROR(`Invalid message content summary at ${pos}, len ${pValueLen}`);
                                    return false;
                                }
                                smfHeader.pm_content_summary = contentSummary;
                                break;
                            }

                          case SMFParameterType.ASSURED_FLOWID:
                            smfHeader.pm_ad_flowid = dataBuf.readUInt32BE(pos);
                            break;

                          case SMFParameterType.TR_TOPICNAME:
                            smfHeader.pm_tr_topicname_bytes = dataBuf.toString("latin1", pos, pos + pValueLen);
                            break;

                          case SMFParameterType.AD_FLOWREDELIVERED_FLAG:
                            smfHeader.pm_ad_flowredelflag = true;
                            break;

                          case SMFParameterType.EXTENDED_TYPE_STREAM:
                            {
                                const extSuccess = parseSMFExtendedStream(smfHeader, dataBuf, pos, pValueLen);
                                if (!extSuccess) {
                                    return null;
                                }
                                break;
                            }

                          default:
                            if (prmUh === 0) {
                                LOG_TRACE(`Unhandled SMF parameter type: ${pType} UH is ${prmUh} discarding parameter.`);
                            } else {
                                LOG_TRACE(`Unhandled SMF parameter type: ${pType} UH is ${prmUh} discarding message.`);
                                smfHeader.discardMessage = true;
                            }
                            break;
                        }
                        pos += pValueLen;
                    }
                }
                return smfHeader;
            }
            const ParseSMF = {
                isSMFHeaderAvailable: isSMFHeaderAvailable,
                isSMFHeaderValid: isSMFHeaderValid,
                isSMFAvailable: isSMFAvailable,
                parseSMFAt: parseSMFAt
            };
            module.exports.ParseSMF = ParseSMF;
        },
        "./modules/solclient-smf/lib/codec/priority-user-cos-map.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
            const {
                BidiMap
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            class PriorityUserCosMap extends BidiMap {
                constructor() {
                    super([ MessageLib.MessageUserCosType.COS1, 0 ], [ MessageLib.MessageUserCosType.COS2, 1 ], [ MessageLib.MessageUserCosType.COS3, 2 ]);
                }
            }
            module.exports.PriorityUserCosMap = PriorityUserCosMap;
        },
        "./modules/solclient-smf/lib/codec/smp.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_DEBUG,
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SMFSMPMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-types.js");
            const {
                SMPMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                get: bits,
                set: setBits
            } = Bits;
            const {
                int8ToStr,
                int32ToStr
            } = Convert;
            const SMP = {};
            SMP.parseSMPAt = function parseSMPAt(dataBuf, offset) {
                if (offset + 6 > dataBuf.length) {
                    LOG_DEBUG("Not enough data to read an SMP message.");
                    return false;
                }
                let pos = offset;
                const onebyte = dataBuf.readUInt8(pos);
                pos++;
                const msgType = bits(onebyte, 0, 7);
                const smpMsg = new SMPMessage();
                if (!(msgType === SMFSMPMessageType.ADDSUBSCRIPTION || msgType === SMFSMPMessageType.REMSUBSCRIPTION || msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION)) {
                    LOG_DEBUG(`Found unsupported SMP messageType ${msgType}`);
                    return false;
                }
                LOG_TRACE("SMP.parseSMPAt called, ", dataBuf.toString("latin1"));
                const msgLength = dataBuf.readUInt32BE(pos);
                pos += 4;
                if (offset + msgLength > dataBuf.length) {
                    LOG_DEBUG(`Invalid declared length of ${msgLength}, unable to read SMP message.`);
                    return false;
                }
                const msgFlags = dataBuf.readUInt8(pos);
                pos++;
                smpMsg.msgType = msgType;
                smpMsg.smpFlags = msgFlags;
                if (msgType === SMFSMPMessageType.ADDSUBSCRIPTION || msgType === SMFSMPMessageType.REMSUBSCRIPTION) {
                    smpMsg.encodedUtf8Subscription = dataBuf.toString("latin1", pos, pos + msgLength - 6);
                } else {
                    const queueLength = dataBuf.readUInt8(pos);
                    pos++;
                    smpMsg.encodedUtf8QueueName = dataBuf.toString("latin1", pos, pos + queueLength);
                    pos += queueLength;
                    const subsLength = dataBuf.readUInt8(pos);
                    pos++;
                    smpMsg.encodedUtf8Subscription = dataBuf.toString("latin1", pos, pos + subsLength);
                    pos += subsLength;
                }
                return smpMsg;
            };
            SMP.encSmp = function encSmp(smpMsg) {
                if (!(smpMsg.msgType === SMFSMPMessageType.ADDSUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMSUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION)) {
                    LOG_DEBUG(`Unsupported SMP message for encoding: ${smpMsg}`);
                    return false;
                }
                LOG_TRACE("encSmp called.", smpMsg);
                const data = [];
                let onebyte = 0;
                onebyte = setBits(onebyte, 1, 7, 1);
                onebyte = setBits(onebyte, smpMsg.msgType, 0, 7);
                data.push(int8ToStr(onebyte));
                let msgLength = 6 + smpMsg.encodedUtf8Subscription.length;
                if (smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION) {
                    msgLength += 2 + smpMsg.encodedUtf8QueueName.length;
                }
                data.push(int32ToStr(msgLength));
                data.push(int8ToStr(smpMsg.smpFlags));
                if (smpMsg.msgType === SMFSMPMessageType.ADDQUEUESUBSCRIPTION || smpMsg.msgType === SMFSMPMessageType.REMQUEUESUBSCRIPTION) {
                    data.push(int8ToStr(smpMsg.encodedUtf8QueueName.length));
                    data.push(smpMsg.encodedUtf8QueueName);
                    data.push(int8ToStr(smpMsg.encodedUtf8Subscription.length));
                    data.push(smpMsg.encodedUtf8Subscription);
                } else {
                    data.push(smpMsg.encodedUtf8Subscription);
                }
                return data.join("");
            };
            module.exports.SMP = SMP;
        },
        "./modules/solclient-smf/lib/codec/transport.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SMFTransportSessionMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-transport-session-message-types.js");
            const {
                TransportSMFMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/api.js");
            const {
                get: bits
            } = Bits;
            const {
                int16ToStr,
                int32ToStr
            } = Convert;
            const {
                lazyValue
            } = Lazy;
            function remains(dataBuf, offset) {
                return dataBuf.length - offset;
            }
            function parseTsSmfHdrAt(dataBuf, offset, smfheader) {
                let pos = offset;
                if (remains(dataBuf, pos) < 10) {
                    LOG_ERROR("TsSmf parse failed: not enough data, expected at least 10B");
                    return false;
                }
                const transportSMFMessage = new TransportSMFMessage();
                transportSMFMessage.smfHeader = smfheader;
                const twobyte = dataBuf.readUInt16BE(pos);
                pos += 2;
                transportSMFMessage.uh = bits(twobyte, 15, 1);
                transportSMFMessage.messageType = bits(twobyte, 8, 7);
                const tsHdrLen = bits(twobyte, 0, 8);
                transportSMFMessage.tsHeaderLength = tsHdrLen;
                transportSMFMessage.sessionId = dataBuf.toString("latin1", pos, pos + 8);
                pos += 8;
                if (transportSMFMessage.messageType === SMFTransportSessionMessageType.CREATE_RESP) {
                    const rtrTagLen = dataBuf.readUInt8(pos);
                    pos++;
                    if (remains(dataBuf, pos) < rtrTagLen) {
                        LOG_ERROR(`TsSmf parse failed: not enough data for RouterTag, expected ${rtrTagLen}B`);
                        return false;
                    }
                    transportSMFMessage.routerTag = dataBuf.toString("latin1", pos, pos + rtrTagLen);
                    pos += rtrTagLen;
                }
                pos = offset + tsHdrLen;
                if (smfheader.payloadLength === 4294967295) {
                    transportSMFMessage.payloadLength = smfheader.payloadLength;
                } else {
                    transportSMFMessage.payloadLength = smfheader.payloadLength - tsHdrLen;
                }
                return transportSMFMessage;
            }
            const tsHeaderPreLength = lazyValue(() => int32ToStr(51642369) + int32ToStr(12));
            const tsDestroyHeaderPreSid = lazyValue(() => tsHeaderPreLength.value + int32ToStr(22) + int16ToStr(33290));
            const tsCreateHeader = lazyValue(() => tsHeaderPreLength.value + int32ToStr(22) + int16ToStr(32778) + int32ToStr(0) + int32ToStr(0));
            const tsDataTokenPreSid = lazyValue(() => int32ToStr(60030977) + int32ToStr(12) + int32ToStr(22) + int16ToStr(34058));
            const tsDataStreamTokenPreSid = lazyValue(() => int32ToStr(60030977) + int32ToStr(12) + int32ToStr(24) + int16ToStr(34316));
            function genTsCreateHeader() {
                return tsCreateHeader.value;
            }
            function genTsDestroyHeader(sid) {
                return tsDestroyHeaderPreSid.value + sid;
            }
            function genTsDataTokenMsg(sid) {
                return tsDataTokenPreSid.value + sid;
            }
            function genTsDataStreamTokenMsg(sid, paddingBytes) {
                return tsDataStreamTokenPreSid.value + sid + (paddingBytes && paddingBytes > 0 ? int16ToStr(paddingBytes) : int16ToStr(0));
            }
            function genTsDataMsgHeaderParts(sid) {
                return [ int32ToStr(60030977) + int32ToStr(12), int16ToStr(33802) + sid ];
            }
            function parseTsSmfMsgAt(dataBuf, offset, smfheader) {
                const transportSMFMessage = parseTsSmfHdrAt(dataBuf, offset, smfheader);
                if (!transportSMFMessage) {
                    return null;
                }
                const pos = offset + transportSMFMessage.tsHeaderLength;
                if (remains(dataBuf, pos) < transportSMFMessage.payloadLength) {
                    LOG_ERROR(`Couldn't read full encapsulated TsSmf payload, expected ${transportSMFMessage.payloadLength}B`);
                    return null;
                }
                transportSMFMessage.payload = dataBuf.slice(pos, pos + transportSMFMessage.payloadLength);
                return transportSMFMessage;
            }
            const Transport = {
                genTsCreateHeader: genTsCreateHeader,
                genTsDestroyHeader: genTsDestroyHeader,
                genTsDataTokenMsg: genTsDataTokenMsg,
                genTsDataStreamTokenMsg: genTsDataStreamTokenMsg,
                genTsDataMsgHeaderParts: genTsDataMsgHeaderParts,
                parseTsSmfHdrAt: parseTsSmfHdrAt,
                parseTsSmfMsgAt: parseTsSmfMsgAt
            };
            module.exports.Transport = Transport;
        },
        "./modules/solclient-smf/lib/message-objects/adprotocol-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                BaseMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js");
            const {
                Convert,
                Long
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                DestinationType
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                QueueAccessType,
                QueueDiscardBehavior
            } = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                QueuePermissions,
                QueueType
            } = __webpack_require__("./modules/solclient-queue/api.js");
            const {
                ReplayStartType
            } = __webpack_require__("./modules/solclient-replaystart/api.js");
            const {
                SMFAdProtocolMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-message-types.js");
            const {
                SMFAdProtocolParam
            } = __webpack_require__("./modules/solclient-smf/lib/smf-adprotocol-params.js");
            const {
                SMFHeader
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js");
            const {
                SMFParameter
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-parameter.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            const {
                SMFUH
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-uh.js");
            const {
                StringUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const BufferImpl = __webpack_require__("buffer").Buffer;
            const {
                strToInt8,
                strToInt16,
                strToUInt32,
                strToUInt64
            } = Convert;
            const bUInt8 = BufferImpl.prototype.readUInt8;
            const bUInt16BE = BufferImpl.prototype.readUInt16BE;
            const bUInt32BE = BufferImpl.prototype.readUInt32BE;
            const bUInt64BE = function bUInt64BE(pos) {
                return Long.fromBits(this.readUInt32BE(pos + 4), this.readUInt32BE(pos), true);
            };
            const {
                nullTerminate,
                stripNullTerminate
            } = StringUtils;
            const EndpointTypeToParam = {
                [DestinationType.TOPIC]: SMFAdProtocolParam.DTENAME,
                [DestinationType.QUEUE]: SMFAdProtocolParam.QUEUENAME
            };
            const QueueDescriptorTypeToParam = {
                [QueueType.TOPIC_ENDPOINT]: SMFAdProtocolParam.DTENAME,
                [QueueType.QUEUE]: SMFAdProtocolParam.QUEUENAME
            };
            const QUEUE_PERMISSIONS_TO_BITS = {
                [QueuePermissions.NONE]: 0,
                [QueuePermissions.READ_ONLY]: 1,
                [QueuePermissions.CONSUME]: 3,
                [QueuePermissions.MODIFY_TOPIC]: 7,
                [QueuePermissions.DELETE]: 15
            };
            const ACCESS_TYPE_INT_TO_ENUM = {
                1: QueueAccessType.EXCLUSIVE,
                2: QueueAccessType.NONEXCLUSIVE
            };
            const ACCESS_TYPE_ENUM_TO_BITS = {
                [QueueAccessType.EXCLUSIVE]: 1,
                [QueueAccessType.NONEXCLUSIVE]: 2
            };
            const DISCARD_ENUM_TO_VALUE = {
                [QueueDiscardBehavior.NOTIFY_SENDER_OFF]: 1,
                [QueueDiscardBehavior.NOTIFY_SENDER_ON]: 2
            };
            function addQueueProperties(message, queueProperties, skipAccessType = false) {
                if (!queueProperties) {
                    return;
                }
                const {
                    accessType,
                    discardBehavior,
                    maxMessageRedelivery,
                    maxMessageSize,
                    permissions,
                    quotaMB,
                    respectsTTL
                } = queueProperties;
                if (permissions && QUEUE_PERMISSIONS_TO_BITS[permissions] !== undefined) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_ALLOTHER_PERMISSION, QUEUE_PERMISSIONS_TO_BITS[permissions]));
                }
                if (!skipAccessType && accessType !== undefined && ACCESS_TYPE_ENUM_TO_BITS[accessType] !== undefined) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ACCESSTYPE, ACCESS_TYPE_ENUM_TO_BITS[accessType]));
                }
                if (quotaMB !== null && quotaMB !== undefined) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_QUOTA, quotaMB));
                }
                if (maxMessageSize !== undefined && maxMessageSize !== null) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_MAX_MSGSIZE, maxMessageSize));
                }
                let flags = 0;
                if (discardBehavior !== null && discardBehavior !== undefined) {
                    const discardBehaviorValue = DISCARD_ENUM_TO_VALUE[discardBehavior];
                    flags |= discardBehaviorValue << 12;
                }
                if (flags) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_BEHAVIOUR, flags));
                }
                if (maxMessageRedelivery !== undefined && maxMessageRedelivery !== null) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.MAX_REDELIVERY, maxMessageRedelivery));
                }
                if (respectsTTL !== undefined && respectsTTL !== null) {
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_RESPECTS_TTL, respectsTTL ? 1 : 0));
                }
            }
            class AdProtocolMessage extends BaseMessage {
                constructor(messageType = 0, version = 3) {
                    super(new SMFHeader(SMFProtocol.ADCTRL, 1));
                    this.msgType = messageType;
                    this.version = version;
                }
                _readParameter(paramtype, decoder = null, bufMethod = null) {
                    const param = this.getParameter(paramtype);
                    if (param === undefined) return undefined;
                    if (bufMethod && param.getBuffer()) {
                        return bufMethod.call(param.getBuffer(), param.getBegin());
                    }
                    const value = param.getValue();
                    return decoder ? decoder(value) : value;
                }
                getAccessType() {
                    const param = this._readParameter(SMFAdProtocolParam.ACCESSTYPE, strToInt8, bUInt8);
                    return ACCESS_TYPE_INT_TO_ENUM[param];
                }
                getActiveFlow() {
                    return this._readParameter(SMFAdProtocolParam.ACTIVE_FLOW_INDICATION, strToInt8, bUInt8);
                }
                getQueueDiscardBehavior() {
                    const param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16, bUInt16BE);
                    if (param === undefined) {
                        return undefined;
                    }
                    const masked = (param & 12288) >> 12;
                    if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_OFF]) {
                        return QueueDiscardBehavior.NOTIFY_SENDER_OFF;
                    } else if (masked === DISCARD_ENUM_TO_VALUE[QueueDiscardBehavior.NOTIFY_SENDER_ON]) {
                        return QueueDiscardBehavior.NOTIFY_SENDER_ON;
                    }
                    return undefined;
                }
                getEndpointDeliveryCountSent() {
                    const param = this._readParameter(SMFAdProtocolParam.EP_BEHAVIOUR, strToInt16, bUInt16BE);
                    const masked = (param & 3072) >> 10;
                    switch (masked) {
                      case 0:
                        return undefined;

                      case 1:
                        return false;

                      case 2:
                        return true;

                      default:
                        return undefined;
                    }
                }
                getEndpointId() {
                    return this._readParameter(SMFAdProtocolParam.ENDPOINT_ID, strToUInt32, bUInt32BE);
                }
                getRespectsTTL() {
                    const value = this._readParameter(SMFAdProtocolParam.EP_RESPECTS_TTL, strToInt8, bUInt8);
                    if (value === undefined) {
                        LOG_TRACE("respectsTTL missing from response.");
                        return undefined;
                    }
                    LOG_TRACE(`respectsTTL present in response: ${value}`);
                    return !!value;
                }
                getFlowName() {
                    return this._readParameter(SMFAdProtocolParam.FLOWNAME, stripNullTerminate);
                }
                getFlowId() {
                    return this._readParameter(SMFAdProtocolParam.FLOWID, strToUInt32, bUInt32BE);
                }
                getQuota() {
                    return this._readParameter(SMFAdProtocolParam.EP_QUOTA, strToUInt32, bUInt32BE);
                }
                getMaxMsgSize() {
                    return this._readParameter(SMFAdProtocolParam.EP_MAX_MSGSIZE, strToUInt32, bUInt32BE);
                }
                getTopicEndpointBytes() {
                    return this._readParameter(SMFAdProtocolParam.DTENAME);
                }
                getGrantedPermissions() {
                    const permissions = this._readParameter(SMFAdProtocolParam.GRANTED_PERMISSIONS, strToUInt32, bUInt32BE);
                    let result;
                    Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(key => {
                        if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) {
                            result = key;
                        }
                    });
                    return result;
                }
                getAllOthersPermissions() {
                    const permissions = this._readParameter(SMFAdProtocolParam.EP_ALLOTHER_PERMISSION, strToUInt32, bUInt32BE);
                    let result;
                    Object.keys(QUEUE_PERMISSIONS_TO_BITS).forEach(key => {
                        if (QUEUE_PERMISSIONS_TO_BITS[key] === permissions) {
                            result = key;
                        }
                    });
                    return result;
                }
                getLastMsgIdAcked() {
                    return this._readParameter(SMFAdProtocolParam.LASTMSGIDACKED, strToUInt64, bUInt64BE);
                }
                getLastMsgIdReceived() {
                    return this._readParameter(SMFAdProtocolParam.LASTMSGIDRECEIVED, strToUInt64, bUInt64BE);
                }
                getPublisherId() {
                    return this._readParameter(SMFAdProtocolParam.PUBLISHER_ID, strToUInt32, bUInt32BE);
                }
                getWantFlowChangeNotify() {
                    return !!this._readParameter(SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, strToInt8, bUInt8);
                }
                getWindow() {
                    return this._readParameter(SMFAdProtocolParam.WINDOW, strToInt8, bUInt8);
                }
                getMaxRedelivery() {
                    return this._readParameter(SMFAdProtocolParam.MAX_REDELIVERY, strToInt8, bUInt8);
                }
                getMaxUnackedMessages() {
                    return this._readParameter(SMFAdProtocolParam.MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW, strToUInt32, bUInt32BE);
                }
                getEndpointErrorId() {
                    return this._readParameter(SMFAdProtocolParam.ENDPOINT_ERROR_ID, strToUInt64, bUInt64BE);
                }
                getSpoolerUniqueId() {
                    return this._readParameter(SMFAdProtocolParam.SPOOLER_UNIQUE_ID, strToUInt64, bUInt64BE);
                }
                static getCloseMessagePublisher(flowId, correlationTag) {
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.CLOSEPUBFLOW);
                    const header = message.smfHeader;
                    header.pm_corrtag = correlationTag;
                    message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                    return message;
                }
                static getCreate(queueDescriptor, queueProperties, correlationTag) {
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.CREATE);
                    const header = message.smfHeader;
                    header.pm_corrtag = correlationTag;
                    const endpointTypeParam = QueueDescriptorTypeToParam[queueDescriptor.type];
                    if (endpointTypeParam === undefined) throw new OperationError("Unknown destination type");
                    message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, nullTerminate(queueDescriptor.name)));
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_DURABLE, queueDescriptor.durable));
                    addQueueProperties(message, queueProperties);
                    return message;
                }
                static getOpenMessagePublisher(lastMsgIdAcked, lastMsgIdSent, windowSize, flowName, correlationTag) {
                    const adMsg = new AdProtocolMessage(SMFAdProtocolMessageType.OPENPUBFLOW);
                    const smfHeader = adMsg.smfHeader;
                    smfHeader.pm_corrtag = correlationTag;
                    if (lastMsgIdAcked !== undefined) {
                        adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMsgIdAcked));
                    }
                    if (lastMsgIdSent !== undefined) {
                        adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDSENT, lastMsgIdSent));
                    }
                    adMsg.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.WINDOW, windowSize));
                    adMsg.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.FLOWNAME, flowName || ""));
                    LOG_TRACE(`Create open publisher: lastMsgIdAcked=${lastMsgIdAcked} lastMsgIdSent=${lastMsgIdSent} window=${windowSize} flowName=${flowName || "(null)"}`);
                    return adMsg;
                }
                static getOpenMessageConsumer(queueDescriptor, queueProperties, endpoint, topicSubscription, correlationTag, windowSize, noLocal, wantFlowChangeUpdate, lastMsgIdAcked = Long.UZERO, lastMsgIdReceived = Long.UZERO, browser = false, replayStartLocation = undefined, endpointErrorId = undefined) {
                    const durable = queueDescriptor.durable;
                    const endpointBytes = endpoint.bytes;
                    const endpointType = endpoint.type;
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.BIND);
                    const header = message.smfHeader;
                    header.pm_corrtag = correlationTag;
                    const endpointTypeParam = EndpointTypeToParam[endpointType];
                    if (endpointTypeParam === undefined) throw new OperationError("Unknown destination type");
                    message.addParameter(new SMFParameter(SMFUH.REJECT, endpointTypeParam, endpointBytes));
                    if (topicSubscription) {
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.TOPICNAME, topicSubscription.bytes));
                    }
                    if (endpointType === DestinationType.QUEUE) {
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMsgIdAcked));
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.LASTMSGIDRECEIVED, lastMsgIdReceived));
                    }
                    message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.WINDOW, windowSize));
                    message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.EP_DURABLE, durable));
                    addQueueProperties(message, queueProperties, true);
                    if (noLocal) {
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.NOLOCAL, 1));
                    }
                    if (wantFlowChangeUpdate) {
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.WANT_FLOW_CHANGE_NOTIFY, 1));
                    }
                    if (browser) {
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWTYPE, 2));
                    }
                    if (replayStartLocation !== undefined) {
                        let rsValue = replayStartLocation._replayStartValue;
                        if (replayStartLocation._type === ReplayStartType.DATE) {
                            const replayStartTimeMs = Long.fromNumber(replayStartLocation._replayStartValue, true);
                            const replayStartTimeNs = replayStartTimeMs.multiply(1e6);
                            rsValue = replayStartTimeNs;
                        }
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.REPLAY_START_LOCATION, {
                            type: replayStartLocation._type,
                            value: rsValue
                        }));
                    }
                    if (endpointErrorId !== undefined) {
                        LOG_TRACE(`Adding endpointErrorId to message: ${endpointErrorId}`);
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ENDPOINT_ERROR_ID, endpointErrorId));
                    }
                    return message;
                }
                static getCloseMessageConsumer(flowId, correlationTag) {
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);
                    const header = message.smfHeader;
                    header.pm_corrtag = correlationTag;
                    message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                    return message;
                }
                static getDTEUnsubscribeMessage(correlationTag, topic) {
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNSUBSCRIBE);
                    const header = message.smfHeader;
                    header.pm_corrtag = correlationTag;
                    message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.DTENAME, topic.getBytes()));
                    return message;
                }
                static getAck(flowId, lastMessageIdAcked = undefined, windowSize = undefined, applicationAckRanges = undefined) {
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.CLIENTACK);
                    message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                    if (lastMessageIdAcked) {
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.LASTMSGIDACKED, lastMessageIdAcked));
                    }
                    if (windowSize !== undefined && windowSize !== null) {
                        message.addParameter(new SMFParameter(SMFUH.REJECT, windowSize <= 255 ? SMFAdProtocolParam.WINDOW : SMFAdProtocolParam.TRANSPORT_WINDOW, windowSize));
                    }
                    if (applicationAckRanges && applicationAckRanges.length) {
                        if (applicationAckRanges.length > AdProtocolMessage.MAX_CLIENT_ACK_RANGES) {
                            throw new OperationError("Application ack range count exceeds limit of 64");
                        }
                        message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.APPLICATION_ACK, applicationAckRanges));
                    }
                    return message;
                }
                static getUnbindAck(flowId, endpointErrorId = undefined, lastMessageIdAcked = undefined) {
                    const message = new AdProtocolMessage(SMFAdProtocolMessageType.UNBIND);
                    message.addParameter(new SMFParameter(SMFUH.REJECT, SMFAdProtocolParam.FLOWID, flowId));
                    if (endpointErrorId) {
                        LOG_TRACE(`Adding endpointErrorId to unbind ack: ${endpointErrorId}`);
                        message.addParameter(new SMFParameter(SMFUH.IGNORE, SMFAdProtocolParam.ENDPOINT_ERROR_ID, endpointErrorId));
                    }
                    LOG_TRACE(`Not adding lastMessageIdAcked to unbind ack: ${lastMessageIdAcked}`);
                    return message;
                }
            }
            AdProtocolMessage.MAX_CLIENT_ACK_RANGES = 64;
            module.exports.AdProtocolMessage = AdProtocolMessage;
        },
        "./modules/solclient-smf/lib/message-objects/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                AdProtocolMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/adprotocol-message.js");
            const {
                BinaryMetaBlock
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/binary-meta-block.js");
            const {
                ClientCtrlMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/client-ctrl-message.js");
            const {
                KeepAliveMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/keep-alive-message.js");
            const {
                SMFHeader
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js");
            const {
                SMFParameter
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-parameter.js");
            const {
                SMFUH
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-uh.js");
            const {
                SMPMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smp-message.js");
            const {
                TransportSMFMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/transport-smf-message.js");
            module.exports.AdProtocolMessage = AdProtocolMessage;
            module.exports.BinaryMetaBlock = BinaryMetaBlock;
            module.exports.ClientCtrlMessage = ClientCtrlMessage;
            module.exports.KeepAliveMessage = KeepAliveMessage;
            module.exports.SMFHeader = SMFHeader;
            module.exports.SMFParameter = SMFParameter;
            module.exports.SMFUH = SMFUH;
            module.exports.SMPMessage = SMPMessage;
            module.exports.TransportSMFMessage = TransportSMFMessage;
        },
        "./modules/solclient-smf/lib/message-objects/base-message.js": module => {
            class BaseMessage {
                constructor(header = null, params = []) {
                    this._smfHeader = header;
                    this._parameters = params;
                }
                addParameter(param) {
                    this._parameters[param.getType()] = param;
                }
                getParameter(paramType) {
                    return this._parameters[paramType];
                }
                getParameterArray() {
                    return this._parameters;
                }
                get smfHeader() {
                    return this._smfHeader;
                }
                set smfHeader(val) {
                    this._smfHeader = val;
                }
                getResponse() {
                    const smf = this.smfHeader;
                    if (!(smf && smf.pm_respcode && smf.pm_respstr)) {
                        return null;
                    }
                    return {
                        responseCode: smf.pm_respcode,
                        responseString: smf.pm_respstr
                    };
                }
            }
            module.exports.BaseMessage = BaseMessage;
        },
        "./modules/solclient-smf/lib/message-objects/binary-meta-block.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                get: bits
            } = Bits;
            const {
                int8ToStr,
                int24ToStr
            } = Convert;
            class BinaryMetaBlock {
                constructor(type, payload) {
                    this.type = type;
                    this.payload = payload;
                }
                asEncodedSmf() {
                    const smf = [];
                    smf.push(int8ToStr(1));
                    smf.push(int8ToStr(this.type));
                    smf.push(int24ToStr(this.payload.length));
                    smf.push(this.payload.toString("latin1"));
                    return smf.join("");
                }
                static fromEncodedSmf(bufSmf, offset = 0) {
                    if (bufSmf.length - offset < 6) {
                        return null;
                    }
                    const chunkCount = bufSmf.readUInt8(offset);
                    const fourbyte = bufSmf.readInt32BE(offset + 1);
                    const type = bits(fourbyte, 24, 8);
                    const payloadLen = bits(fourbyte, 0, 24);
                    const payloadOffset = chunkCount * 4 + 1;
                    const payload = bufSmf.slice(offset + payloadOffset, offset + payloadOffset + payloadLen);
                    return new BinaryMetaBlock(type, payload);
                }
            }
            module.exports.BinaryMetaBlock = BinaryMetaBlock;
        },
        "./modules/solclient-smf/lib/message-objects/client-ctrl-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                AuthenticationScheme,
                CapabilityType,
                ClientCapabilityType,
                MutableSessionProperty,
                SessionProperties
            } = __webpack_require__("./modules/solclient-session/api.js");
            const {
                BaseMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js");
            const {
                Bits,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                DestinationType,
                DestinationUtil
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Process,
                StringUtils,
                Version
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                SMFClientCtrlMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-message-types.js");
            const {
                SMFClientCtrlParam,
                SMFClientCtrlAuthType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-client-ctrl-params.js");
            const {
                SMFHeader
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js");
            const {
                SMFParameter
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-parameter.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            const {
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                get: bits,
                set: setBits
            } = Bits;
            const {
                int8ToStr,
                strToInt8,
                int16ToStr,
                int32ToStr,
                strToInt16,
                strToInt32
            } = Convert;
            const {
                nullTerminate,
                stripNullTerminate
            } = StringUtils;
            const {
                validateAndEncode
            } = DestinationUtil;
            const BOOLEAN_CAPS_BITS = [ CapabilityType.JNDI, CapabilityType.COMPRESSION, CapabilityType.GUARANTEED_MESSAGE_CONSUME, CapabilityType.TEMPORARY_ENDPOINT, CapabilityType.GUARANTEED_MESSAGE_PUBLISH, CapabilityType.GUARANTEED_MESSAGE_BROWSE, CapabilityType.ENDPOINT_MGMT, CapabilityType.SELECTOR, CapabilityType.ENDPOINT_MESSAGE_TTL, CapabilityType.QUEUE_SUBSCRIPTIONS, null, CapabilityType.SUBSCRIPTION_MANAGER, CapabilityType.MESSAGE_ELIDING, CapabilityType.TRANSACTED_SESSION, CapabilityType.NO_LOCAL, CapabilityType.ACTIVE_CONSUMER_INDICATION, CapabilityType.PER_TOPIC_SEQUENCE_NUMBERING, CapabilityType.ENDPOINT_DISCARD_BEHAVIOR, CapabilityType.CUT_THROUGH, null, CapabilityType.MESSAGE_REPLAY, CapabilityType.COMPRESSED_SSL, null, CapabilityType.SHARED_SUBSCRIPTIONS, CapabilityType.BR_REPLAY_ERRORID ];
            const CLIENT_CAPS_VALUES = new Map([ [ ClientCapabilityType.UNBIND_ACK, 128 ], [ ClientCapabilityType.BR_ERRORID, 64 ] ]);
            class ClientCtrlMessage extends BaseMessage {
                constructor(messageType = 0) {
                    super(new SMFHeader(SMFProtocol.CLIENTCTRL, 1));
                    this.msgType = messageType;
                    this.version = 1;
                }
                getP2PTopicValue() {
                    const p2pParam = this.getParameter(SMFClientCtrlParam.P2PTOPIC);
                    if (!p2pParam) {
                        return null;
                    }
                    return stripNullTerminate(p2pParam.getValue());
                }
                getVpnNameInUseValue() {
                    const vpnParam = this.getParameter(SMFClientCtrlParam.MSGVPNNAME);
                    if (!vpnParam) {
                        return null;
                    }
                    return stripNullTerminate(vpnParam.getValue());
                }
                getVridInUseValue() {
                    const vridParam = this.getParameter(SMFClientCtrlParam.VRIDNAME);
                    if (!vridParam) {
                        return null;
                    }
                    return stripNullTerminate(vridParam.getValue());
                }
                getUserIdValue() {
                    const userIdParam = this.getParameter(SMFClientCtrlParam.USERID);
                    if (!userIdParam) {
                        return null;
                    }
                    return stripNullTerminate(userIdParam.getValue());
                }
                getRouterCapabilities() {
                    let caps = [];
                    let capParam = this.getParameter(SMFClientCtrlParam.ROUTER_CAPABILITIES);
                    if (capParam) {
                        caps = ClientCtrlMessage.prmParseCapabilitiesValue(capParam.getValue(), caps);
                    }
                    capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREVERSION);
                    if (capParam) {
                        caps[CapabilityType.PEER_SOFTWARE_VERSION] = stripNullTerminate(capParam.getValue());
                    }
                    capParam = this.getParameter(SMFClientCtrlParam.SOFTWAREDATE);
                    if (capParam) {
                        caps[CapabilityType.PEER_SOFTWARE_DATE] = stripNullTerminate(capParam.getValue());
                    }
                    capParam = this.getParameter(SMFClientCtrlParam.PLATFORM);
                    if (capParam) {
                        caps[CapabilityType.PEER_PLATFORM] = stripNullTerminate(capParam.getValue());
                    }
                    capParam = this.getParameter(SMFClientCtrlParam.PHYSICALROUTERNAME);
                    if (capParam) {
                        caps[CapabilityType.PEER_ROUTER_NAME] = stripNullTerminate(capParam.getValue());
                    }
                    return caps;
                }
                static prmGetDtoPriorityValue(dto) {
                    if (dto.local === undefined || dto.network === undefined) {
                        return false;
                    }
                    let twobyte = 0;
                    twobyte = setBits(twobyte, dto.local, 8, 8);
                    twobyte = setBits(twobyte, dto.network, 0, 8);
                    return int16ToStr(twobyte);
                }
                static prmParseDtoPriorityValue(strDtoPriority) {
                    const dto = {};
                    const twobyte = strToInt16(strDtoPriority.substr(0, 2));
                    dto.local = bits(twobyte, 8, 8);
                    dto.network = bits(twobyte, 0, 8);
                    return dto;
                }
                static prmParseCapabilitiesValue(strCapabilities, capsIn) {
                    const caps = capsIn;
                    if (!(strCapabilities && caps)) {
                        return false;
                    }
                    const CT = CapabilityType;
                    let pos = 0;
                    const boolCapCount = strToInt8(strCapabilities[pos]);
                    ++pos;
                    let capsByte;
                    for (let bitIndex = 0; bitIndex < boolCapCount; ++bitIndex) {
                        const msbIndex = bitIndex & 7;
                        if (msbIndex === 0) {
                            capsByte = strToInt8(strCapabilities[pos]);
                            ++pos;
                        }
                        const capsKey = BOOLEAN_CAPS_BITS[bitIndex];
                        if (!capsKey) continue;
                        caps[capsKey] = !!bits(capsByte, 7 - msbIndex, 1);
                    }
                    const sanityLoop = 500;
                    for (let i = 0; pos < strCapabilities.length && i < sanityLoop; ++i) {
                        const onebyte = strToInt8(strCapabilities[pos]);
                        pos++;
                        const capLen = strToInt32(strCapabilities.substr(pos, 4)) - 5;
                        pos += 4;
                        const strValue = strCapabilities.substr(pos, capLen);
                        pos += capLen;
                        switch (onebyte) {
                          case 0:
                            caps[CT.PEER_PORT_SPEED] = strValue.length === 4 ? strToInt32(strValue) : 0;
                            break;

                          case 1:
                            caps[CT.PEER_PORT_TYPE] = strValue.length === 1 ? strToInt8(strValue) : 0;
                            break;

                          case 2:
                            caps[CT.MAX_GUARANTEED_MSG_SIZE] = strValue.length === 4 ? strToInt32(strValue) : 0;
                            break;

                          case 3:
                            caps[CT.MAX_DIRECT_MSG_SIZE] = strValue.length === 4 ? strToInt32(strValue) : 0;
                            break;

                          default:
                            break;
                        }
                    }
                    return caps;
                }
                static getLogin(sprop, compressedTLS, plaintextTLS, correlationTag) {
                    function clientCapsToStr(clientCapList) {
                        const highestCap = Math.max.apply(null, clientCapList) + 1;
                        let capBits = 0;
                        clientCapList.forEach(cap => {
                            capBits += CLIENT_CAPS_VALUES.get(cap);
                        });
                        return int8ToStr(highestCap) + int8ToStr(capBits);
                    }
                    if (!(sprop instanceof SessionProperties)) {
                        return false;
                    }
                    const cc = new ClientCtrlMessage(SMFClientCtrlMessageType.LOGIN);
                    const smfHeader = cc._smfHeader;
                    const isClientCert = sprop.authenticationScheme === AuthenticationScheme.CLIENT_CERTIFICATE;
                    smfHeader.pm_corrtag = correlationTag;
                    if (sprop.password && !isClientCert) {
                        smfHeader.pm_password = sprop.password;
                    }
                    if (sprop.userName) {
                        smfHeader.pm_username = sprop.userName;
                    }
                    if (sprop.subscriberLocalPriority && sprop.subscriberNetworkPriority) {
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.DELIVERTOONEPRIORITY, ClientCtrlMessage.prmGetDtoPriorityValue({
                            local: sprop.subscriberLocalPriority,
                            network: sprop.subscriberNetworkPriority
                        })));
                    }
                    if (sprop.vpnName && sprop.vpnName.length > 0) {
                        cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.MSGVPNNAME, nullTerminate(sprop.vpnName)));
                    }
                    if (sprop.applicationDescription && sprop.applicationDescription.length > 0) {
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTDESC, nullTerminate(sprop.applicationDescription)));
                    }
                    if (sprop.userIdentification && sprop.userIdentification.length > 0) {
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.USERID, nullTerminate(sprop.userIdentification)));
                    }
                    if (sprop.authenticationScheme === AuthenticationScheme.OAUTH2) {
                        cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.AUTHENTICATION_SCHEME, SMFClientCtrlAuthType.OAUTH2));
                        if (sprop.idToken) {
                            smfHeader.pm_oidc_id_token = nullTerminate(sprop.idToken);
                        }
                        if (sprop.accessToken) {
                            smfHeader.pm_oauth2_access_token = nullTerminate(sprop.accessToken);
                        }
                        if (sprop.issuerIdentifier) {
                            smfHeader.pm_oauth2_issuer_identifier = nullTerminate(sprop.issuerIdentifier);
                        }
                    }
                    cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTNAME, nullTerminate(sprop.clientName)));
                    cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.PLATFORM, nullTerminate(`${Process.platform} - JS API (${Version.mode})`)));
                    if (sprop.noLocal) {
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.NO_LOCAL, ""));
                    }
                    if (isClientCert) {
                        cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.AUTHENTICATION_SCHEME, SMFClientCtrlAuthType.CLIENT_CERTIFICATE));
                    }
                    cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.SOFTWAREDATE, nullTerminate(Version.formattedDate)));
                    cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.SOFTWAREVERSION, nullTerminate(Version.version)));
                    if (compressedTLS && plaintextTLS) {
                        LOG_TRACE("Adding SslDowngrade=1 to login.");
                        cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, ""));
                    } else if (compressedTLS) {
                        LOG_TRACE("Adding SslDowngrade=2 to login.");
                        cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, ""));
                    } else if (plaintextTLS) {
                        LOG_TRACE("Adding SslDowngrade=0 to login.");
                        cc.addParameter(new SMFParameter(1, SMFClientCtrlParam.SSL_DOWNGRADE, "\0"));
                    }
                    const clientCaps = clientCapsToStr([ ClientCapabilityType.UNBIND_ACK, ClientCapabilityType.BR_ERRORID ]);
                    cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENT_CAPABILITIES, clientCaps));
                    const keepaliveVal = int32ToStr(sprop.keepAliveIntervalInMsecs / 1e3);
                    cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.KEEP_ALIVE_INTERVAL, keepaliveVal));
                    return cc;
                }
                static getUpdate(mutableSessionProperty, newValue, correlationTag) {
                    const cc = new ClientCtrlMessage(SMFClientCtrlMessageType.UPDATE);
                    const smfHeader = cc.smfHeader;
                    smfHeader.pm_corrtag = correlationTag;
                    if (mutableSessionProperty === MutableSessionProperty.CLIENT_DESCRIPTION) {
                        const appdesc = (newValue || "").toString().substr(0, 250);
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTDESC, nullTerminate(appdesc)));
                    } else if (mutableSessionProperty === MutableSessionProperty.CLIENT_NAME) {
                        const error = ClientCtrlMessage.validateClientName(newValue, errorMessage => new OperationError(`Invalid clientName: ${errorMessage}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE));
                        if (error) {
                            throw error;
                        }
                        cc.addParameter(new SMFParameter(0, SMFClientCtrlParam.CLIENTNAME, nullTerminate(newValue)));
                    }
                    return cc;
                }
                static validateClientName(strName, exceptionCreator) {
                    const encodeResult = validateAndEncode(DestinationType.TOPIC, strName, exceptionCreator);
                    if (encodeResult.error) {
                        return encodeResult.error;
                    }
                    if (encodeResult.bytes.length > 161) {
                        return exceptionCreator("Client Name too long (max length: 160).");
                    }
                    return null;
                }
            }
            module.exports.ClientCtrlMessage = ClientCtrlMessage;
        },
        "./modules/solclient-smf/lib/message-objects/keep-alive-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                BaseMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js");
            const {
                SMFHeader
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            class KeepAliveMessage extends BaseMessage {
                constructor() {
                    super(new SMFHeader(SMFProtocol.KEEPALIVEV2, 2));
                    this._smfHeader.smf_uh = 2;
                }
            }
            module.exports.KeepAliveMessage = KeepAliveMessage;
        },
        "./modules/solclient-smf/lib/message-objects/smf-header.js": module => {
            class SMFHeader {
                constructor(protocol = 0, ttl = 0) {
                    this._parameters = [];
                    this.smf_version = 3;
                    this.smf_uh = 0;
                    this.smf_protocol = protocol;
                    this.smf_priority = 0;
                    this.smf_ttl = ttl;
                    this.smf_msgLen = 0;
                    this.smf_di = 0;
                    this.smf_tqd = 0;
                    this.smf_elidingEligible = 0;
                    this.smf_dto = 0;
                    this.smf_adf = 0;
                    this.smf_deadMessageQueueEligible = 0;
                    this.pm_userdata = null;
                    this.pm_respcode = 0;
                    this.pm_respstr = null;
                    this.pm_username = null;
                    this.pm_password = null;
                    this.pm_tr_topicname_bytes = null;
                    this.pm_deliverymode = null;
                    this.pm_ad_msgid = undefined;
                    this.pm_ad_prevmsgid = undefined;
                    this.pm_ad_redelflag = 0;
                    this.pm_ad_flowredelflag = 0;
                    this.pm_ad_ttl = undefined;
                    this.pm_ad_ackimm = undefined;
                    this.pm_ad_flowid = 0;
                    this.pm_ad_publisherid = 0;
                    this.pm_ad_publishermsgid = 0;
                    this.pm_content_summary = null;
                    this.pm_corrtag = null;
                    this.pm_topic_offset = 0;
                    this.pm_topic_len = 0;
                    this.pm_queue_offset = 0;
                    this.pm_queue_len = 0;
                    this.pm_msg_priority = null;
                    this.pm_oauth2_access_token = null;
                    this.pm_oidc_id_token = null;
                    this.pm_oauth2_issuer_identifier = null;
                    this.unknownProtoFlag = false;
                    this.messageLength = 0;
                    this.payloadLength = 0;
                    this.headerLength = 0;
                    this.payload = null;
                    this.discardMessage = false;
                }
                setMessageSizes(headerLength, payloadLength) {
                    this.headerLength = headerLength;
                    this.payloadLength = payloadLength;
                    this.messageLength = headerLength + payloadLength;
                }
                setPayloadSize(payloadLength) {
                    this.payloadLength = payloadLength;
                }
            }
            module.exports.SMFHeader = SMFHeader;
        },
        "./modules/solclient-smf/lib/message-objects/smf-parameter.js": module => {
            class SMFParameter {
                constructor(uh, type, value, buffer, begin, end) {
                    this._type = type;
                    this._value = value;
                    this._uh = uh;
                    this._buffer = buffer;
                    this._begin = begin;
                    this._end = end;
                }
                getType() {
                    return this._type;
                }
                getValue() {
                    if (this._buffer && !this._value) {
                        return this._buffer.toString("latin1", this._begin, this._end);
                    }
                    return this._value;
                }
                getUh() {
                    return this._uh;
                }
                getBuffer() {
                    return this._buffer;
                }
                getBegin() {
                    return this._begin;
                }
                getEnd() {
                    return this._end;
                }
                toString() {
                    return `${this._uh}:0x${this._type.toString(16)} = ${this.getValue()}`;
                }
            }
            module.exports.SMFParameter = SMFParameter;
        },
        "./modules/solclient-smf/lib/message-objects/smf-uh.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFUH = {
                IGNORE: 0,
                REJECT: 2
            };
            module.exports.SMFUH = Enum.new(SMFUH);
        },
        "./modules/solclient-smf/lib/message-objects/smp-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                assert
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                BaseMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js");
            const {
                Destination,
                DestinationUtil
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                SMFHeader
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/smf-header.js");
            const {
                SMFProtocol
            } = __webpack_require__("./modules/solclient-smf/lib/smf-protocols.js");
            const {
                SMFSMPMessageType
            } = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-types.js");
            const {
                SMFSMPMessageTypeFlags
            } = __webpack_require__("./modules/solclient-smf/lib/smf-smp-message-type-flags.js");
            class SMPMessage extends BaseMessage {
                constructor() {
                    super(new SMFHeader(SMFProtocol.SMP, 1));
                    this.msgType = 0;
                    this.encodedUtf8Subscription = null;
                    this.encodedUtf8QueueName = null;
                    this.smpFlags = 0 | SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC;
                    this._encodedQueueName = null;
                    this._encodedClientName = null;
                }
                isFlag(flagMask) {
                    return this.smpFlags & flagMask;
                }
                setFlag(flagMask, value) {
                    if (value) {
                        this.smpFlags |= flagMask;
                    } else {
                        this.smpFlags &= ~flagMask;
                    }
                }
                static getSubscriptionMessage(correlationTag, topic, add, requestConfirm) {
                    assert(topic instanceof Destination, "Topics are not UCS-2 strings. Pass a Topic object.");
                    const smp = new SMPMessage();
                    smp.msgType = add ? SMFSMPMessageType.ADDSUBSCRIPTION : SMFSMPMessageType.REMSUBSCRIPTION;
                    smp.encodedUtf8Subscription = topic.getBytes();
                    assert(smp.encodedUtf8Subscription, "Topic had no encoding");
                    smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
                    if (requestConfirm) {
                        smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
                    }
                    smp._smfHeader.pm_corrtag = correlationTag;
                    return smp;
                }
                static getQueueSubscriptionMessage(correlationTag, topic, queue, add) {
                    assert(topic instanceof Destination, "Topics are not UCS-2 strings. Pass a Topic object.");
                    const smp = new SMPMessage();
                    smp.msgType = add ? SMFSMPMessageType.ADDQUEUESUBSCRIPTION : SMFSMPMessageType.REMQUEUESUBSCRIPTION;
                    smp.encodedUtf8QueueName = DestinationUtil.encodeBytes(queue.getName());
                    smp.encodedUtf8Subscription = topic.getBytes();
                    assert(smp.encodedUtf8Subscription, "Topic had no encoding");
                    assert(smp.encodedUtf8QueueName, "Queue had no encoding");
                    smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_TOPIC, true);
                    smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_RESPREQUIRED, true);
                    smp.setFlag(SMFSMPMessageTypeFlags.SMF_SMP_FLAG_PERSIST, true);
                    smp._smfHeader.pm_corrtag = correlationTag;
                    return smp;
                }
            }
            module.exports.SMPMessage = SMPMessage;
        },
        "./modules/solclient-smf/lib/message-objects/transport-smf-message.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                BaseMessage
            } = __webpack_require__("./modules/solclient-smf/lib/message-objects/base-message.js");
            class TransportSMFMessage extends BaseMessage {
                constructor() {
                    super(null, null);
                    this.uh = 0;
                    this.messageType = null;
                    this.sessionId = null;
                    this.routerTag = null;
                    this.payload = null;
                    this.payloadLength = 0;
                    this.tsHeaderLength = 0;
                }
            }
            module.exports.TransportSMFMessage = TransportSMFMessage;
        },
        "./modules/solclient-smf/lib/smf-adprotocol-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFAdProtocolMessageType = {
                OPENPUBFLOW: 0,
                CLIENTACK: 3,
                BIND: 4,
                UNBIND: 5,
                UNSUBSCRIBE: 6,
                CLOSEPUBFLOW: 7,
                CREATE: 8,
                DELETE: 9,
                TRANSACTIONCTRL: 11,
                FLOWCHANGEUPDATE: 12,
                XACTRL: 14,
                CLIENTNACK: 15
            };
            module.exports.SMFAdProtocolMessageType = Enum.new(SMFAdProtocolMessageType);
        },
        "./modules/solclient-smf/lib/smf-adprotocol-params.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFAdProtocolParam = {
                LASTMSGIDSENT: 1,
                LASTMSGIDACKED: 2,
                WINDOW: 3,
                TRANSPORT_PRIORITY: 4,
                APPLICATION_ACK: 5,
                FLOWID: 6,
                QUEUENAME: 7,
                DTENAME: 8,
                TOPICNAME: 9,
                FLOWNAME: 10,
                EP_DURABLE: 11,
                ACCESSTYPE: 12,
                SELECTOR: 13,
                TRANSPORT_WINDOW: 14,
                LINGER_OPTION: 15,
                LASTMSGIDRECEIVED: 16,
                EP_ALLOTHER_PERMISSION: 17,
                FLOWTYPE: 18,
                EP_QUOTA: 19,
                EP_MAX_MSGSIZE: 20,
                GRANTED_PERMISSIONS: 21,
                EP_RESPECTS_TTL: 22,
                TRANSACTION_CTRL_MESSAGE_TYPE: 23,
                TRANSACTED_SESSION_ID: 24,
                TRANSACTED_SESSION_NAME: 25,
                TRANSACTION_ID: 26,
                TRANSACTED_SESSION_STATE: 27,
                TRANSACTION_FLOW_DESCRIPTOR_PUB_NOTIFY: 28,
                TRANSACTION_FLOW_DESCRIPTOR_PUB_ACK: 29,
                TRANSACTION_FLOW_DESCRIPTOR_SUB_ACK: 30,
                NOLOCAL: 31,
                ACTIVE_FLOW_INDICATION: 32,
                WANT_FLOW_CHANGE_NOTIFY: 33,
                EP_BEHAVIOUR: 34,
                PUBLISHER_ID: 35,
                APPLICATION_PUB_ACK: 36,
                NUM_MESSAGES_SPOOLED: 37,
                CUT_THROUGH: 38,
                PUBLISHER_FLAGS: 39,
                APP_MSG_ID_TYPE: 40,
                QUEUE_ENDPOINT_HASH: 41,
                MAX_REDELIVERY: 42,
                PAYLOAD: 43,
                ENDPOINT_ID: 44,
                ACK_SEQUENCE_NUMBER: 45,
                ACK_RECONCILE_REQUEST: 46,
                START_OF_ACK_RECONCILE: 47,
                TIMESTAMP: 48,
                MAX_DELIVERED_UNACKED_MESSAGES_PER_FLOW: 49,
                REPLAY_START_LOCATION: 51,
                ENDPOINT_ERROR_ID: 52,
                SPOOLER_UNIQUE_ID: 54
            };
            module.exports.SMFAdProtocolParam = Enum.new(SMFAdProtocolParam);
        },
        "./modules/solclient-smf/lib/smf-client-ctrl-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFClientCtrlMessageType = {
                LOGIN: 0,
                UPDATE: 1
            };
            module.exports.SMFClientCtrlMessageType = Enum.new(SMFClientCtrlMessageType);
        },
        "./modules/solclient-smf/lib/smf-client-ctrl-params.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFClientCtrlParam = {
                SOFTWAREVERSION: 0,
                SOFTWAREDATE: 1,
                PLATFORM: 2,
                USERID: 3,
                CLIENTDESC: 4,
                CLIENTNAME: 5,
                MSGVPNNAME: 6,
                DELIVERTOONEPRIORITY: 7,
                P2PTOPIC: 8,
                ROUTER_CAPABILITIES: 9,
                VRIDNAME: 10,
                PHYSICALROUTERNAME: 12,
                BRIDGE_MSG_VPN_NAME: 13,
                BRIDGE_ROUTER_NAME: 14,
                NO_LOCAL: 15,
                BRIDGE_VERSION: 16,
                AUTHENTICATION_SCHEME: 17,
                CONNECTION_TYPE: 18,
                ROUTER_CAPABILITIES_EXTENDED: 19,
                REQUIRES_RELEASE_7: 20,
                SSL_DOWNGRADE: 21,
                CLIENT_CAPABILITIES: 23,
                KEEP_ALIVE_INTERVAL: 24
            };
            const SMFClientCtrlAuthType = {
                CLIENT_CERTIFICATE: "",
                OAUTH2: "\n"
            };
            module.exports.SMFClientCtrlAuthType = Enum.new(SMFClientCtrlAuthType);
            module.exports.SMFClientCtrlParam = Enum.new(SMFClientCtrlParam);
        },
        "./modules/solclient-smf/lib/smf-parameter-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFParameterType = {
                PADDING: 0,
                PUBLISHER_ID: 1,
                PUBLISHER_MSGID: 2,
                MESSAGEPRIORITY: 3,
                USERDATA: 4,
                USERNAME: 6,
                PASSWORD: 7,
                RESPONSE: 8,
                SUB_ID_LIST: 10,
                GENERIC_ATTACHMENT: 11,
                BINARY_ATTACHMENT: 12,
                DELIVERY_MODE: 16,
                ASSURED_MESSAGE_ID: 17,
                ASSURED_PREVMESSAGE_ID: 18,
                ASSURED_REDELIVERED_FLAG: 19,
                MESSAGE_CONTENT_SUMMARY: 22,
                ASSURED_FLOWID: 23,
                TR_TOPICNAME: 24,
                AD_FLOWREDELIVERED_FLAG: 25,
                AD_TIMETOLIVE: 28,
                AD_TOPICSEQUENCE_NUMBER: 30,
                EXTENDED_TYPE_STREAM: 31,
                AD_ACK_MESSAGE_ID: 41,
                AD_SPOOLER_UNIQUE_ID: 44,
                AD_REPL_MATE_ACK_MSGID: 45,
                AD_REDELIVERY_COUNT: 46,
                LIGHT_CORRELATION: 0,
                LIGHT_TOPIC_NAME_OFFSET: 1,
                LIGHT_QUEUE_NAME_OFFSET: 2,
                LIGHT_ACK_IMMEDIATELY: 3
            };
            const SMFExtendedParameterType = {
                OAUTH2_ISSUER_IDENTIFIER: 47,
                OIDC_ID_TOKEN: 48,
                OAUTH2_ACCESS_TOKEN: 49
            };
            module.exports.SMFParameterType = Enum.new(SMFParameterType);
            module.exports.SMFExtendedParameterType = Enum.new(SMFExtendedParameterType);
        },
        "./modules/solclient-smf/lib/smf-protocols.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFProtocol = {
                CSPF: 1,
                CSMP: 2,
                PUBMSG: 3,
                XMLLINK: 4,
                WSE: 5,
                SEMP: 6,
                SUBCTRL: 7,
                PUBCTRL: 8,
                ADCTRL: 9,
                KEEPALIVE: 10,
                KEEPALIVEV2: 11,
                CLIENTCTRL: 12,
                TRMSG: 13,
                JNDI: 14,
                SMP: 15,
                SMRP: 16,
                SMF_IN_SMF: 17,
                SMF_IN_RV: 18,
                ADCTRL_PASSTHROUGH: 19,
                TSESSION: 20
            };
            module.exports.SMFProtocol = Enum.new(SMFProtocol);
        },
        "./modules/solclient-smf/lib/smf-smp-message-type-flags.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFSMPMessageTypeFlags = {
                FLAG_FILTER: 1,
                FLAG_PERSIST: 2,
                SMF_SMP_FLAG_TOPIC: 4,
                SMF_SMP_FLAG_RESPREQUIRED: 8,
                SMF_SMP_FLAG_DELIVERALWAYS: 16
            };
            module.exports.SMFSMPMessageTypeFlags = Enum.new(SMFSMPMessageTypeFlags);
        },
        "./modules/solclient-smf/lib/smf-smp-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFSMPMessageType = {
                ADDSUBSCRIPTION: 0,
                REMSUBSCRIPTION: 1,
                ADDQUEUESUBSCRIPTION: 2,
                REMQUEUESUBSCRIPTION: 3,
                ADDSUBSCRIPTIONFORCLIENTNAME: 4,
                REMSUBSCRIPTIONFORCLIENTNAME: 5
            };
            module.exports.SMFSMPMessageType = Enum.new(SMFSMPMessageType);
        },
        "./modules/solclient-smf/lib/smf-transport-session-message-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const SMFTransportSessionMessageType = {
                CREATE: 0,
                CREATE_RESP: 1,
                DESTROY: 2,
                DESTROY_RESP: 3,
                DATA: 4,
                DATA_TOKEN: 5,
                DATA_STREAM_TOKEN: 6
            };
            module.exports.SMFTransportSessionMessageType = Enum.new(SMFTransportSessionMessageType);
        },
        "./modules/solclient-solcache-session/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                CacheCBInfo
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-cb-info.js");
            const {
                CacheContext
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-context.js");
            const {
                CacheLiveDataAction
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-live-data-actions.js");
            const {
                CacheRequest
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request.js");
            const {
                CacheRequestResult
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request-result.js");
            const {
                CacheReturnCode
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-codes.js");
            const {
                CacheReturnSubcode
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-subcodes.js");
            const {
                CacheSession
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session.js");
            const {
                CacheSessionProperties
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session-properties.js");
            module.exports.CacheCBInfo = CacheCBInfo;
            module.exports.CACHE_REQUEST_PREFIX = CacheContext.CACHE_REQUEST_PREFIX;
            module.exports.CacheLiveDataAction = CacheLiveDataAction;
            module.exports.CacheRequestResult = CacheRequestResult;
            module.exports.CacheReturnCode = CacheReturnCode;
            module.exports.CacheReturnSubcode = CacheReturnSubcode;
            module.exports.CacheRequest = CacheRequest;
            module.exports.CacheSession = CacheSession;
            module.exports.CacheSessionProperties = CacheSessionProperties;
        },
        "./modules/solclient-solcache-session/lib/cache-cb-info.js": module => {
            class CacheCBInfo {
                constructor(cacheCBFunction, userObject) {
                    this.cacheCBFunction = cacheCBFunction;
                    this.userObject = userObject;
                }
                getCallback() {
                    return this.cacheCBFunction;
                }
                getUserObject() {
                    return this.userObject;
                }
            }
            module.exports.CacheCBInfo = CacheCBInfo;
        },
        "./modules/solclient-solcache-session/lib/cache-context.js": module => {
            const CacheContext = {
                CACHE_REQUEST_PREFIX: "#CRQ",
                cacheRequestCorrelationId: 0
            };
            module.exports.CacheContext = CacheContext;
        },
        "./modules/solclient-solcache-session/lib/cache-get-result-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const CacheGetResultCode = {
                INVALID: 0,
                OK: 1
            };
            module.exports.CacheGetResultCode = Enum.new(CacheGetResultCode);
        },
        "./modules/solclient-solcache-session/lib/cache-get-result.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                CacheGetResultCode
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-get-result-codes.js");
            const DEFAULTS = {
                messageID: null,
                version: 0,
                responseCode: CacheGetResultCode.INVALID,
                responseString: "",
                matchTopic: "",
                sessionID: null,
                isSuspect: null,
                hasMore: null,
                hasTimestamps: null,
                replyTo: null,
                messageStream: null,
                clusterNameStream: null
            };
            class CacheGetResult {
                constructor(options = DEFAULTS) {
                    Object.assign(this, options);
                }
                readFromStream(stream) {
                    this.messageID = stream.getNext().getValue();
                    this.version = stream.getNext().getValue();
                    this.responseCode = stream.getNext().getValue();
                    this.responseString = stream.getNext().getValue();
                    this.matchTopic = stream.getNext().getValue();
                    this.sessionID = stream.getNext().getValue();
                    this.isSuspect = stream.getNext().getValue();
                    this.hasMore = stream.getNext().getValue();
                    this.hasTimestamps = stream.getNext().getValue();
                    if (stream.hasNext()) {
                        this.messageStream = stream.getNext().getValue();
                    }
                    if (stream.hasNext()) {
                        this.clusterNameStream = this.messageStream;
                        this.messageStream = stream.getNext().getValue();
                    }
                }
            }
            module.exports.CacheGetResult = CacheGetResult;
        },
        "./modules/solclient-solcache-session/lib/cache-live-data-actions.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const CacheLiveDataAction = {
                FULFILL: 1,
                QUEUE: 2,
                FLOW_THRU: 3
            };
            module.exports.CacheLiveDataAction = Enum.new(CacheLiveDataAction);
        },
        "./modules/solclient-solcache-session/lib/cache-request-result.js": module => {
            class CacheRequestResult {
                constructor(rc, subcode, topic, error) {
                    this._returnCode = rc;
                    this._subcode = subcode;
                    this._topic = topic;
                    this._error = error;
                }
                getReturnCode() {
                    return this._returnCode;
                }
                getReturnSubcode() {
                    return this._subcode;
                }
                getTopic() {
                    return this._topic;
                }
                getError() {
                    return this._error;
                }
            }
            module.exports.CacheRequestResult = CacheRequestResult;
        },
        "./modules/solclient-solcache-session/lib/cache-request-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const CacheRequestType = {
                INVALID: 0,
                BULK_MSG: 1,
                REGISTER_REQUEST: 2,
                REGISTER_RESPONSE: 3,
                HEARTBEAT_REQUEST: 4,
                HEARTBEAT_RESPONSE: 5,
                EVENT_NOTIFY: 6,
                EVENT_ACK: 7,
                ACTION_REQUEST: 8,
                ACTION_RESPONSE: 9,
                GET_REQUEST: 10,
                GET_RESPONSE: 11,
                GET_NEXT_REQUEST: 12,
                GET_NEXT_RESPONSE: 13,
                SET_REQUEST: 14,
                SET_RESPONSE: 15,
                GET_MSG_REQUEST: 16,
                GET_MSG_RESPONSE: 17,
                GET_NEXT_MSG_REQUEST: 18,
                GET_NEXT_MSG_RESPONSE: 19,
                UNREGISTER_IND: 20,
                BULK_SET_REQUEST: 21,
                BULK_SET_RESPONSE: 22,
                PURGE_MSG_SEQUENCE_REQUEST: 23,
                PURGE_MSG_SEQUENCE_RESPONSE: 24,
                GET_MSG_SEQUENCE_REQUEST: 25,
                GET_NEXT_MSG_SEQUENCE_REQUEST: 26,
                GET_TOPIC_INFO_REQUEST: 27,
                GET_TOPIC_INFO_RESPONSE: 28,
                READY_MARKER: 29,
                GET_TOPIC_INFO_REQUEST_RANGE: 30,
                SYNC_READY_MARKER: 31,
                VACUUM_REQUEST: 32,
                VACUUM_RESPONSE: 33
            };
            module.exports.CacheRequestType = Enum.new(CacheRequestType);
        },
        "./modules/solclient-solcache-session/lib/cache-request.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                CacheContext
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-context.js");
            const {
                LOG_DEBUG
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                CACHE_REQUEST_PREFIX
            } = CacheContext;
            class CacheRequest {
                constructor(cacheSession, cacheMessageType, requestID, cbInfo, liveDataAction, topic, cacheName) {
                    this.cacheSession = cacheSession;
                    this.cacheMessageType = cacheMessageType;
                    this.requestID = requestID;
                    this.cbInfo = cbInfo;
                    this.liveDataAction = liveDataAction;
                    this.topic = topic;
                    this.cacheName = cacheName;
                    this.subscriptionWaiting = null;
                    this.replyReceived = false;
                    this.dataReceived = false;
                    this.isSuspect = false;
                    this.correlationID = `${CACHE_REQUEST_PREFIX}${CacheContext.cacheRequestCorrelationId++}`;
                    this.childRequests = [];
                    this.parentRequest = null;
                    this.queuedLiveData = [];
                    this.liveDataFulfilled = false;
                    this.timeoutHandle = null;
                }
                getRootRequest() {
                    if (!this.parentRequest) {
                        return this;
                    }
                    return this.parentRequest.getRootRequest();
                }
                addChild(childIn) {
                    if (!(childIn instanceof CacheRequest)) {
                        throw new Error(`Invalid child ${childIn}`);
                    }
                    if (childIn === this) {
                        throw new Error("Constructing circular child reference");
                    }
                    const child = childIn;
                    child.parentRequest = this;
                    this.childRequests.push(child);
                }
                removeChild(childIn) {
                    if (childIn === this) {
                        throw new Error("Attempting to deconstruct invalid circular child reference");
                    }
                    const child = childIn;
                    const childIndex = this.childRequests.indexOf(child);
                    if (childIndex === -1) {
                        LOG_DEBUG(`Child ${child} not found in ${this}`);
                    }
                    this.childRequests.splice(childIndex, 1);
                    child.parentRequest = null;
                }
                collapse() {
                    const parentRequest = this.parentRequest;
                    parentRequest.isSuspect = parentRequest.isSuspect || this.isSuspect;
                    parentRequest.dataReceived = parentRequest.dataReceived || this.dataReceived;
                    parentRequest.removeChild(this);
                }
                cancel() {
                    if (this.parentRequest) {
                        this.collapse();
                    }
                    while (this.childRequests.length) {
                        const child = this.childRequests.shift();
                        if (child.childRequests) {
                            child.cancel();
                        }
                        this.removeChild(child);
                    }
                    this.clearRequestTimeout();
                }
                getRequestID() {
                    return this.requestID;
                }
                getCBInfo() {
                    return this.cbInfo;
                }
                getTopic() {
                    return this.topic;
                }
                getLiveDataAction() {
                    return this.liveDataAction;
                }
                startRequestTimeout(cacheSessionTimeoutCB, timeoutMsec) {
                    this.timeoutHandle = setTimeout(() => {
                        cacheSessionTimeoutCB(this);
                    }, timeoutMsec);
                }
                clearRequestTimeout() {
                    if (this.timeoutHandle === null || this.timeoutHandle === undefined) {
                        return;
                    }
                    LOG_DEBUG(`Clearing timeout for ${this}`);
                    clearTimeout(this.timeoutHandle);
                    this.timeoutHandle = null;
                }
                toString() {
                    return `CacheRequest[correlationID=${this.correlationID},requestID=${this.requestID},cacheName=${this.cacheName},topic=${this.topic.getName()}]`;
                }
            }
            CacheRequest.VERSION = 1;
            CacheRequest.DEFAULT_REPLY_SIZE_LIMIT = 1e6;
            CacheRequest.REPLY_SIZE_LIMIT = CacheRequest.DEFAULT_REPLY_SIZE_LIMIT;
            module.exports.CacheRequest = CacheRequest;
        },
        "./modules/solclient-solcache-session/lib/cache-return-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const CacheReturnCode = {
                OK: 1,
                FAIL: 2,
                INCOMPLETE: 3
            };
            module.exports.CacheReturnCode = Enum.new(CacheReturnCode);
        },
        "./modules/solclient-solcache-session/lib/cache-return-subcodes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const CacheReturnSubcode = {
                REQUEST_COMPLETE: 0,
                LIVE_DATA_FULFILL: 1,
                ERROR_RESPONSE: 2,
                INVALID_SESSION: 3,
                REQUEST_TIMEOUT: 4,
                REQUEST_ALREADY_IN_PROGRESS: 5,
                NO_DATA: 6,
                SUSPECT_DATA: 7,
                CACHE_SESSION_DISPOSED: 8,
                SUBSCRIPTION_ERROR: 9
            };
            module.exports.CacheReturnSubcode = Enum.new(CacheReturnSubcode);
        },
        "./modules/solclient-solcache-session/lib/cache-session-properties.js": module => {
            class CacheSessionProperties {
                constructor(cacheName, maxAgeSec, maxMessages, timeoutMsec) {
                    this.cacheName = cacheName;
                    this.maxAgeSec = maxAgeSec || 0;
                    this.maxMessages = maxMessages === null || maxMessages === undefined ? 1 : maxMessages;
                    this.timeoutMsec = timeoutMsec || 1e4;
                    this.includeOtherClusters = true;
                    this.cachePrefix = "#P2P/CACHEINST/";
                }
                getCacheName() {
                    return this.cacheName;
                }
                setCacheName(value) {
                    this.cacheName = value;
                }
                getMaxMessageAgeSec() {
                    return this.maxAgeSec;
                }
                setMaxMessageAgeSec(value) {
                    this.maxAgeSec = value;
                }
                getMaxMessages() {
                    return this.maxMessages;
                }
                setMaxMessages(value) {
                    this.maxMessages = value;
                }
                getTimeoutMsec() {
                    return this.timeoutMsec;
                }
                setTimeoutMsec(value) {
                    this.timeoutMsec = value;
                }
            }
            module.exports.CacheSessionProperties = CacheSessionProperties;
        },
        "./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js": module => {
            class CacheSessionSubscribeInfo {
                constructor(correlationID, topic, cacheSession) {
                    Object.assign(this, {
                        correlationID: correlationID,
                        topic: topic,
                        cacheSession: cacheSession
                    });
                }
            }
            module.exports.CacheSessionSubscribeInfo = CacheSessionSubscribeInfo;
        },
        "./modules/solclient-solcache-session/lib/cache-session.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const MessageLib = __webpack_require__("./modules/solclient-message/api.js");
            const SessionLib = __webpack_require__("./modules/solclient-session/api.js");
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const StatType = __webpack_require__("./modules/solclient-stats/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_INFO,
                LOG_WARN
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SDTField,
                SDTFieldType,
                SDTStreamContainer
            } = __webpack_require__("./modules/solclient-sdt/api.js");
            const {
                CacheCBInfo
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-cb-info.js");
            const {
                CacheContext
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-context.js");
            const {
                CacheGetResult
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-get-result.js");
            const {
                CacheLiveDataAction
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-live-data-actions.js");
            const {
                CacheRequest
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request.js");
            const {
                CacheRequestResult
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request-result.js");
            const {
                CacheRequestType
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-request-types.js");
            const {
                CacheReturnCode
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-codes.js");
            const {
                CacheReturnSubcode
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-return-subcodes.js");
            const {
                CacheSessionProperties
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session-properties.js");
            const {
                CacheSessionSubscribeInfo
            } = __webpack_require__("./modules/solclient-solcache-session/lib/cache-session-subscribe-info.js");
            const {
                Destination,
                Topic
            } = __webpack_require__("./modules/solclient-destination/api.js");
            const {
                CACHE_REQUEST_PREFIX
            } = CacheContext;
            const noOp = () => undefined;
            class CacheSession {
                constructor(props, session, privateInterface) {
                    CacheSession._validateProps(props);
                    const properties = new CacheSessionProperties(props.cacheName, props.maxAgeSec, props.maxMessages, props.timeoutMsec);
                    Object.assign(this, {
                        _outstandingRequests: {},
                        _outstandingIDs: {},
                        _disposed: false,
                        _nextMessageCallbackInfo: null,
                        _nextSessionEventCallbackInfo: null,
                        _properties: properties,
                        _session: session,
                        _sessionIF: privateInterface
                    });
                    this._connectToSession(session);
                }
                _connectToSession(session) {
                    this._nextSessionEventCallbackInfo = session.getEventCBInfo();
                    this._nextMessageCallbackInfo = session.getMessageCBInfo();
                    session.setMessageCBInfo(new SessionLib.MessageRxCBInfo((_, message) => {
                        this._handleMessage(message);
                    }, this));
                    session.setEventCBInfo(this._createCompoundEventCB(this._nextSessionEventCallbackInfo));
                }
                _createCompoundEventCB(nextDelegate) {
                    return new SessionLib.SessionEventCBInfo((session, sessionEvent, userObject, rfuObject) => {
                        this._handleSessionEvent(nextDelegate, session, sessionEvent, userObject, rfuObject);
                    }, null);
                }
                _handleSessionEvent(nextDelegate, session, sessionEvent) {
                    const passEvent = this._processSessionEvent(session, sessionEvent);
                    if (!passEvent) {
                        return;
                    }
                    const cbUserObject = nextDelegate.userObject;
                    if (!cbUserObject) {
                        nextDelegate.sessionEventCBFunction(session, sessionEvent);
                    } else {
                        nextDelegate.sessionEventCBFunction(session, sessionEvent, cbUserObject);
                    }
                }
                _sendToNextDelegate(message) {
                    const cbUserObject = this._nextMessageCallbackInfo.userObject;
                    if (!cbUserObject) {
                        this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message);
                    } else {
                        this._nextMessageCallbackInfo.messageRxCBFunction(this._session, message, cbUserObject);
                    }
                }
                _processSessionEvent(session, event) {
                    switch (event.sessionEventCode) {
                      case SessionLib.SessionEventCode.SUBSCRIPTION_ERROR:
                      case SessionLib.SessionEventCode.SUBSCRIPTION_OK:
                        return this._checkSubscriptionStatus(event);

                      case SessionLib.SessionEventCode.DOWN_ERROR:
                        this.dispose();
                        return true;

                      default:
                        LOG_TRACE(`Unhandled session event: ${event.sessionEventCode}`);
                        return true;
                    }
                }
                _checkSubscriptionStatus(event) {
                    if (event.correlationKey === null || event.correlationKey === undefined || !(event.correlationKey instanceof CacheSessionSubscribeInfo) || event.correlationKey.cacheSession !== this) {
                        return true;
                    }
                    const request = this._getOutstandingRequest(event.correlationKey.correlationID);
                    if (!request) {
                        LOG_WARN(`No request found for subscription success on ${event.correlationKey.topic}`);
                        return true;
                    }
                    if (event.sessionEventCode === SessionLib.SessionEventCode.SUBSCRIPTION_OK) {
                        this._handleSubscriptionSuccess(request, event.correlationKey.topic);
                        return false;
                    }
                    this._handleSubscriptionError(request, event);
                    return false;
                }
                _handleSubscriptionSuccess(requestIn) {
                    const request = requestIn;
                    request.subscriptionWaiting = null;
                    this._startCacheRequest(request);
                }
                _handleSubscriptionError(request) {
                    this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.SUBSCRIPTION_ERROR);
                }
                _checkRequestCompletion(request) {
                    if (request.childRequests.length) {
                        LOG_DEBUG(`Awaiting termination of ${request.childRequests.length} children`);
                        return;
                    }
                    if (request.subscriptionWaiting) {
                        LOG_DEBUG("Awaiting subscription");
                        return;
                    }
                    if (request.timeoutHandle !== null && !request.replyReceived) {
                        LOG_DEBUG("Awaiting timeout");
                        return;
                    }
                    if (request.parentRequest) {
                        const parent = request.parentRequest;
                        request.cancel();
                        this._unregisterRequest(request);
                        this._checkRequestCompletion(parent);
                        return;
                    }
                    let code;
                    let subcode;
                    if (request.isSuspect) {
                        code = CacheReturnCode.INCOMPLETE;
                        subcode = CacheReturnSubcode.SUSPECT_DATA;
                    } else if (request.dataReceived) {
                        code = CacheReturnCode.OK;
                        if (request.liveDataFulfilled) {
                            subcode = CacheReturnSubcode.LIVE_DATA_FULFILL;
                        } else {
                            subcode = CacheReturnSubcode.REQUEST_COMPLETE;
                        }
                    } else if (request.replyReceived) {
                        code = CacheReturnCode.INCOMPLETE;
                        subcode = CacheReturnSubcode.NO_DATA;
                    } else {
                        throw new Error("Sanity: should never happen");
                    }
                    this._terminateRequest(request, code, subcode);
                }
                _sendSeeOther(parentRequest, cacheGetResult) {
                    const clusterName = cacheGetResult.clusterNameStream.getNext().getValue();
                    LOG_DEBUG(`See Other for ${clusterName}. Sending child request`);
                    const childRequest = new CacheRequest(this, CacheRequestType.GET_MSG_REQUEST, parentRequest.requestID, new CacheCBInfo(noOp, null), parentRequest.liveDataAction, parentRequest.topic, clusterName);
                    parentRequest.addChild(childRequest);
                    this._registerRequest(childRequest);
                    childRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                    this._startCacheRequest(childRequest, null, null, true);
                }
                _sendGetNext(parentRequest, cacheGetResult) {
                    LOG_DEBUG("Cache result has more, sending GET_NEXT_MSG_REQUEST as child");
                    const nextRequest = new CacheRequest(this, CacheRequestType.GET_NEXT_MSG_REQUEST, parentRequest.requestID, new CacheCBInfo(noOp, null), parentRequest.liveDataAction, parentRequest.topic, parentRequest.cacheName);
                    parentRequest.addChild(nextRequest);
                    this._registerRequest(nextRequest);
                    nextRequest.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                    this._startCacheRequest(nextRequest, cacheGetResult.sessionID, cacheGetResult.replyTo);
                }
                _handleMessage(message) {
                    const correlationID = message.getCorrelationId();
                    const request = correlationID === null || correlationID === undefined ? null : this._outstandingRequests[correlationID];
                    if (!request) {
                        if (this._relevantLiveData(message)) {
                            this._sendToNextDelegate(message);
                        }
                        return;
                    }
                    LOG_DEBUG(`Processing reply to ${request}`);
                    request.clearRequestTimeout();
                    const streamField = message.getSdtContainer();
                    const stream = streamField && streamField.getValue();
                    if (!stream) {
                        LOG_INFO(`Invalid message format for cache response: no SDT container (${streamField}) or stream (${stream})`);
                        this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                    }
                    this._incStat(StatType.RX_REPLY_MSG_RECVED);
                    request.replyReceived = true;
                    if (request.getRootRequest().liveDataFulfilled) {
                        this._incStat(StatType.CACHE_REQUEST_FULFILL_DISCARD_RESPONSE);
                        this._checkRequestCompletion(request);
                        return;
                    }
                    if (!stream) {
                        LOG_INFO("Invalid cache response did not fulfill request. Skipping response processing");
                        return;
                    }
                    try {
                        const result = new CacheGetResult();
                        result.readFromStream(stream);
                        result.replyTo = message.getReplyTo();
                        if (result.responseString) {
                            LOG_DEBUG(`Cluster response: ${result.responseString}`);
                        }
                        if (result.responseCode === 7 || result.responseString == "Invalid Session") {
                            LOG_INFO(`Cluster response indicates invalid session: ${result.responseString} code: ${result.responseCode}`);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.INVALID_SESSION);
                        }
                        request.isSuspect = request.isSuspect || result.isSuspect;
                        const messages = CacheSession._decodeMessageStream(request, result);
                        this._incStat(StatType.RX_CACHE_MSG, messages.length);
                        if (result.hasMore) {
                            this._sendGetNext(request, result);
                        }
                        if (result.clusterNameStream) {
                            LOG_DEBUG("Receiving cluster stream");
                            while (result.clusterNameStream.hasNext()) {
                                this._sendSeeOther(request, result);
                            }
                        }
                        if (messages) {
                            messages.forEach(m => {
                                this._sendToNextDelegate(m);
                            });
                        }
                        this._checkRequestCompletion(request);
                    } catch (exception) {
                        LOG_INFO(`Invalid message format for cache response: ${exception.stack}`);
                        this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                    }
                }
                _relevantLiveData(message) {
                    if (message.getCorrelationId() && message.getCorrelationId().startsWith(CACHE_REQUEST_PREFIX) && !(this._nextMessageCallbackInfo.userObject instanceof CacheSession)) {
                        LOG_WARN("DROP: Dropping CRQ reply due to no remaining Cache Session processors on message " + "callback chain");
                        this._incStat(StatType.RX_REPLY_MSG_DISCARD);
                        return false;
                    }
                    return Object.keys(this._outstandingRequests).every(checkCID => this._performLiveDataAction(this._outstandingRequests[checkCID], message));
                }
                _performLiveDataAction(requestIn, message) {
                    const request = requestIn;
                    request.dataReceived = true;
                    switch (request.liveDataAction) {
                      case CacheLiveDataAction.QUEUE:
                        request.queuedLiveData.push(message);
                        return false;

                      case CacheLiveDataAction.FULFILL:
                        if (!request.liveDataFulfilled) {
                            this._fulfillRequest(request);
                        }
                        return true;

                      default:
                        return true;
                    }
                }
                _fulfillRequest(requestIn) {
                    const request = requestIn;
                    request.liveDataFulfilled = true;
                    this._trackCompletionStats(CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL);
                    setTimeout(() => {
                        CacheSession._notifyCallback(request, CacheReturnCode.OK, CacheReturnSubcode.LIVE_DATA_FULFILL, request.getTopic(), null);
                    }, 0);
                }
                dispose() {
                    const toTerminate = Object.keys(this._outstandingRequests).map(correlationID => this._outstandingRequests[correlationID]).filter(request => request instanceof CacheRequest);
                    toTerminate.forEach(request => {
                        this._terminateRequest(request, CacheReturnCode.INCOMPLETE, CacheReturnSubcode.CACHE_SESSION_DISPOSED);
                    });
                    this._outstandingRequests = [];
                    this._session.setEventCBInfo(this._nextSessionEventCallbackInfo);
                    this._session.setMessageCBInfo(this._nextMessageCallbackInfo);
                    this._disposed = true;
                }
                getProperties() {
                    return this._properties;
                }
                sendCacheRequest(requestID, topic, subscribe, liveDataAction, cbInfo) {
                    if (arguments.length !== 5) {
                        throw new OperationError(`sendCacheRequest() invoked with an illegal argument count of ${arguments.length}`);
                    }
                    if (typeof subscribe !== "boolean") {
                        throw new OperationError(`Invalid subscribe flag argument, should be a boolean but was ${typeof subscribe}`);
                    }
                    if (typeof requestID !== "number" || Number.isNaN(requestID)) {
                        throw new OperationError("Invalid requestID", ErrorSubcode.PARAMETER_INVALID_TYPE, null);
                    }
                    if (this._outstandingIDs[requestID]) {
                        throw new OperationError("Request already in progress with this requestID");
                    }
                    if (!(topic instanceof Destination)) {
                        throw new OperationError("Invalid topic", ErrorSubcode.PARAMETER_INVALID_TYPE, typeof topic);
                    }
                    topic.validate();
                    if (!(liveDataAction === CacheLiveDataAction.FLOW_THRU || liveDataAction === CacheLiveDataAction.FULFILL || liveDataAction === CacheLiveDataAction.QUEUE)) {
                        throw new OperationError("Invalid live data action", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (topic.isWildcarded() && liveDataAction !== CacheLiveDataAction.FLOW_THRU) {
                        throw new OperationError("Wildcarded topic not supported for this live data action", ErrorSubcode.PARAMETER_CONFLICT);
                    }
                    if (!(cbInfo instanceof CacheCBInfo)) {
                        throw new OperationError("Callback info was not an instance of CacheCBInfo");
                    }
                    if (this._disposed) {
                        CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL, CacheReturnSubcode.CACHE_SESSION_DISPOSED, topic, "Cache request failed: the cache session is disposed.");
                        return;
                    }
                    if (this._session._disposed) {
                        CacheSession._notifyCallbackError(cbInfo, requestID, CacheReturnCode.FAIL, CacheReturnSubcode.INVALID_SESSION, topic, "Cache request failed: the session is disposed.");
                        return;
                    }
                    const request = new CacheRequest(this, CacheRequestType.GET_MSG_REQUEST, requestID, cbInfo, liveDataAction, topic, this._properties.cacheName);
                    const matchingRequestKeys = Object.keys(this._outstandingRequests).filter(key => this._outstandingRequests[key].topic.getName() === topic.getName());
                    if (matchingRequestKeys.length) {
                        const conflictKeys = liveDataAction !== CacheLiveDataAction.FLOW_THRU ? matchingRequestKeys : matchingRequestKeys.filter(k => this._outstandingRequests[k].liveDataAction !== CacheLiveDataAction.FLOW_THRU);
                        if (conflictKeys.length) {
                            const conflictRequest = this._outstandingRequests[conflictKeys[0]];
                            LOG_WARN(`Existing request ${conflictRequest} conflicts. Rejecting request ${request}`);
                            this._registerRequest(request);
                            this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.REQUEST_ALREADY_IN_PROGRESS);
                            return;
                        }
                    }
                    this._registerRequest(request);
                    request.startRequestTimeout(CacheSession._handleCacheRequestTimeout, this._properties.timeoutMsec);
                    if (subscribe) {
                        const waitingForSubscribeInfo = new CacheSessionSubscribeInfo(request.correlationID, topic, this);
                        request._subscriptionWaiting = waitingForSubscribeInfo;
                        this._session.subscribe(topic, true, waitingForSubscribeInfo);
                        return;
                    }
                    this._startCacheRequest(request);
                }
                _handleCacheRequestFailed(session, sessionEvent, userObject) {
                    this._terminateRequest(userObject.getRequestID(), CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE);
                }
                _registerRequest(request) {
                    this._outstandingRequests[request.correlationID] = request;
                    if (!request.parentRequest) {
                        this._outstandingIDs[request.requestID] = request;
                    }
                }
                _getOutstandingRequest(correlationID) {
                    return this._outstandingRequests[correlationID];
                }
                _startCacheRequest(request, sessionID, destination, suppressClusters) {
                    const message = new MessageLib.Message();
                    message.setCorrelationId(request.correlationID);
                    if (destination) {
                        message.setDestination(destination);
                    } else {
                        message.setDestination(Topic.createFromName(this._properties.cachePrefix + request.cacheName));
                    }
                    message.setReplyTo(Topic.createFromName(this._session.getSessionProperties().p2pInboxInUse));
                    message.setDeliverToOne(request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST);
                    const stream = new SDTStreamContainer();
                    stream.addField(SDTFieldType.UINT32, request.cacheMessageType);
                    stream.addField(SDTFieldType.UINT32, CacheRequest.VERSION);
                    stream.addField(SDTFieldType.STRING, request.topic.getName());
                    stream.addField(SDTFieldType.UINT32, CacheRequest.REPLY_SIZE_LIMIT);
                    if (typeof sessionID === "number") {
                        LOG_DEBUG(`Including session ID: ${sessionID}`);
                        stream.addField(SDTFieldType.UINT32, sessionID);
                    }
                    stream.addField(SDTFieldType.UINT32, this._properties.maxMessages);
                    stream.addField(SDTFieldType.UINT32, this._properties.maxAgeSec);
                    if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
                        stream.addField(SDTFieldType.BOOL, this._properties.includeOtherClusters && !suppressClusters);
                    }
                    stream.addField(SDTFieldType.BOOL, false);
                    if (request.cacheMessageType === CacheRequestType.GET_MSG_REQUEST) {
                        stream.addField(SDTFieldType.UINT32, Math.round(this._properties.timeoutMsec / 1e3));
                    }
                    message.setSdtContainer(SDTField.create(SDTFieldType.STREAM, stream));
                    try {
                        LOG_DEBUG(`Sending ${request}`);
                        this._session.send(message);
                        if (!request.parentRequest) {
                            this._incStat(StatType.CACHE_REQUEST_SENT);
                        }
                    } catch (e) {
                        LOG_INFO(`Failed to send request: ${e.message}`);
                        this._terminateRequest(request, CacheReturnCode.FAIL, CacheReturnSubcode.ERROR_RESPONSE, e);
                    }
                }
                _incStat(statType, value) {
                    if (!this._session) {
                        LOG_DEBUG("Can't log stat: session is disposed");
                        return;
                    }
                    if (!this._sessionIF) {
                        LOG_INFO("Can't log stat: session statistics not available");
                        return;
                    }
                    this._sessionIF.incStat(statType, value);
                }
                _unregisterRequest(request) {
                    delete this._outstandingRequests[request.correlationID];
                    delete this._outstandingIDs[request.requestID];
                }
                _trackCompletionStats(returnCode, subcode) {
                    switch (returnCode) {
                      case CacheReturnCode.OK:
                        this._incStat(StatType.CACHE_REQUEST_OK_RESPONSE);
                        if (subcode === CacheReturnSubcode.LIVE_DATA_FULFILL) {
                            this._incStat(StatType.CACHE_REQUEST_LIVE_DATA_FULFILL);
                        }
                        break;

                      case CacheReturnCode.INCOMPLETE:
                        this._incStat(StatType.CACHE_REQUEST_INCOMPLETE_RESPONSE);
                        break;

                      case CacheReturnCode.FAIL:
                        this._incStat(StatType.CACHE_REQUEST_FAIL_RESPONSE);
                        break;

                      default:
                        throw new Error("Sanity: no return code supplied");
                    }
                }
                _terminateRequest(requestIn, returnCode, subcode, error) {
                    const request = requestIn.getRootRequest();
                    if (!this._outstandingRequests[request.correlationID]) {
                        return;
                    }
                    const cbInfo = request.cbInfo;
                    if (!cbInfo) {
                        LOG_WARN(`No callback info provided for ${request}. Cannot notify`);
                        return;
                    }
                    const callback = cbInfo.getCallback();
                    if (!callback) {
                        LOG_WARN(`No callback provided for ${request}. Cannot notify`);
                        return;
                    }
                    const topic = request.getTopic();
                    if (!topic) {
                        LOG_WARN(`No topic provided for ${request}`);
                    }
                    request.queuedLiveData.forEach(data => this._sendToNextDelegate(data));
                    request.cancel();
                    this._unregisterRequest(request);
                    if (!request.liveDataFulfilled) {
                        this._trackCompletionStats(returnCode, subcode);
                        CacheSession._notifyCallback(request, returnCode, subcode, topic, error);
                    }
                }
                static _decodeMessageStream(requestIn, result) {
                    if (!result.messageStream) {
                        return [];
                    }
                    LOG_DEBUG("Receiving messages");
                    const messages = [];
                    const request = requestIn;
                    while (result.messageStream.hasNext()) {
                        request.dataReceived = true;
                        const data = result.messageStream.getNext().getValue();
                        const innerMessage = SMFLib.Codec.Decode.decodeCompoundMessage(data, 0);
                        if (!innerMessage) {
                            continue;
                        }
                        const cacheStatus = result.isSuspect ? MessageLib.MessageCacheStatus.SUSPECT : MessageLib.MessageCacheStatus.CACHED;
                        innerMessage._setCacheStatus(cacheStatus);
                        innerMessage._setCacheRequestID(request.requestID);
                        messages.push(innerMessage);
                    }
                    LOG_DEBUG(`${messages.length} cached messages received`);
                    return messages;
                }
                static _handleCacheRequestTimeout(cacheRequest) {
                    const context = cacheRequest.cacheSession;
                    if (!context._getOutstandingRequest(cacheRequest.correlationID)) {
                        LOG_INFO(`Timeout for ${cacheRequest} was not unregistered. Ignoring`);
                        return;
                    }
                    LOG_INFO(`Request ${cacheRequest} timed out`);
                    context._terminateRequest(cacheRequest.getRootRequest(), CacheReturnCode.INCOMPLETE, CacheReturnSubcode.REQUEST_TIMEOUT);
                }
                static _notifyCallback(request, returnCode, subcode, topic, error) {
                    const cbInfo = request.cbInfo;
                    const callback = cbInfo.getCallback();
                    callback(request.requestID, new CacheRequestResult(returnCode, subcode, topic, error), cbInfo.getUserObject());
                }
                static _notifyCallbackError(cbInfo, requestID, returnCode, subcode, topic, error) {
                    const callback = cbInfo.getCallback();
                    callback(requestID, new CacheRequestResult(returnCode, subcode, topic, error), cbInfo.getUserObject());
                }
                static _validateProps(props) {
                    if (typeof props.cacheName !== "string") {
                        throw new OperationError("Invalid parameter type for cacheName", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (Topic.createFromName(props.cacheName).isWildcarded()) {
                        throw new OperationError(`Invalid cacheName '${props.cacheName}'. The cacheName cannot be wildcarded`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (typeof props.maxAgeSec !== "number") {
                        throw new OperationError("Invalid parameter type for maxAgeSec", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (props.maxAgeSec < 0) {
                        throw new OperationError("Invalid value for maxAgeSec; must be >= 0", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (typeof props.maxMessages !== "number") {
                        throw new OperationError("Invalid parameter type for maxMessages", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (props.maxMessages < 0) {
                        throw new OperationError("Invalid value for maxMessages; must be >= 0", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    if (typeof props.timeoutMsec !== "number") {
                        throw new OperationError("Invalid parameter type for timeoutMsec", ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (props.timeoutMsec < 3e3) {
                        throw new OperationError("Invalid value for timeoutMsec; must be >= 3000", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                }
            }
            module.exports.CacheSession = CacheSession;
        },
        "./modules/solclient-stats/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Stats
            } = __webpack_require__("./modules/solclient-stats/lib/stats.js");
            const {
                StatsByMode
            } = __webpack_require__("./modules/solclient-stats/lib/stat-bymode.js");
            const {
                StatType
            } = __webpack_require__("./modules/solclient-stats/lib/stat-types.js");
            module.exports = {
                Stats: Stats,
                StatType: StatType,
                StatsByMode: StatsByMode
            };
        },
        "./modules/solclient-stats/lib/stat-bymode.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                StatType
            } = __webpack_require__("./modules/solclient-stats/lib/stat-types.js");
            module.exports = {
                StatsByMode: {
                    STAT_TX_BYMODE_MSGS: [ StatType.TX_DIRECT_MSGS, StatType.TX_PERSISTENT_MSGS, StatType.TX_NONPERSISTENT_MSGS ],
                    STAT_TX_BYMODE_BYTES: [ StatType.TX_DIRECT_BYTES, StatType.TX_PERSISTENT_BYTES, StatType.TX_NONPERSISTENT_BYTES ],
                    STAT_TX_BYMODE_REDELIVERED: [ StatType.TX_DIRECT_MSGS, StatType.TX_PERSISTENT_REDELIVERED, StatType.TX_NONPERSISTENT_REDELIVERED ],
                    STAT_TX_BYMODE_BYTES_REDELIVERED: [ StatType.TX_DIRECT_BYTES, StatType.TX_PERSISTENT_BYTES_REDELIVERED, StatType.TX_NONPERSISTENT_BYTES_REDELIVERED ],
                    STAT_RX_BYMODE_MSGS: [ StatType.RX_DIRECT_MSGS, StatType.RX_PERSISTENT_MSGS, StatType.RX_NONPERSISTENT_MSGS ],
                    STAT_RX_BYMODE_BYTES: [ StatType.RX_DIRECT_BYTES, StatType.RX_PERSISTENT_BYTES, StatType.RX_NONPERSISTENT_BYTES ]
                }
            };
        },
        "./modules/solclient-stats/lib/stat-types.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const StatType = {
                TX_TOTAL_DATA_BYTES: 0,
                TX_TOTAL_DATA_MSGS: 1,
                TX_DIRECT_BYTES: 2,
                TX_DIRECT_MSGS: 3,
                TX_CONTROL_BYTES: 4,
                TX_CONTROL_MSGS: 5,
                TX_REQUEST_SENT: 6,
                TX_REQUEST_TIMEOUT: 7,
                RX_TOTAL_DATA_BYTES: 8,
                RX_TOTAL_DATA_MSGS: 9,
                RX_DIRECT_BYTES: 10,
                RX_DIRECT_MSGS: 11,
                RX_CONTROL_BYTES: 12,
                RX_CONTROL_MSGS: 13,
                RX_DISCARD_MSG_INDICATION: 14,
                RX_REPLY_MSG_RECVED: 15,
                RX_REPLY_MSG_DISCARD: 16,
                RX_DISCARD_SMF_UNKNOWN_ELEMENT: 17,
                CACHE_REQUEST_SENT: 18,
                CACHE_REQUEST_OK_RESPONSE: 19,
                CACHE_REQUEST_FAIL_RESPONSE: 20,
                CACHE_REQUEST_FULFILL_DISCARD_RESPONSE: 21,
                RX_CACHE_MSG: 22,
                CACHE_REQUEST_INCOMPLETE_RESPONSE: 23,
                CACHE_REQUEST_LIVE_DATA_FULFILL: 24,
                TX_PERSISTENT_BYTES: 25,
                TX_PERSISTENT_MSGS: 26,
                TX_NONPERSISTENT_BYTES: 27,
                TX_NONPERSISTENT_MSGS: 28,
                TX_PERSISTENT_BYTES_REDELIVERED: 29,
                TX_PERSISTENT_REDELIVERED: 30,
                TX_NONPERSISTENT_BYTES_REDELIVERED: 31,
                TX_NONPERSISTENT_REDELIVERED: 32,
                TX_ACKS_RXED: 33,
                TX_WINDOW_CLOSE: 34,
                TX_ACK_TIMEOUT: 35,
                RX_PERSISTENT_BYTES: 36,
                RX_PERSISTENT_MSGS: 37,
                RX_NONPERSISTENT_BYTES: 38,
                RX_NONPERSISTENT_MSGS: 39,
                RX_ACKED: 40,
                RX_DISCARD_DUPLICATE: 41,
                RX_DISCARD_NO_MATCHING_CONSUMER: 42,
                RX_DISCARD_OUT_OF_ORDER: 43
            };
            module.exports.StatType = Enum.new(StatType);
        },
        "./modules/solclient-stats/lib/stats.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                EventEmitter
            } = __webpack_require__("./modules/solclient-events/api.js");
            const {
                StatType
            } = __webpack_require__("./modules/solclient-stats/lib/stat-types.js");
            class Stats extends EventEmitter {
                constructor(parent) {
                    super();
                    this._parent = parent;
                    this._statsMap = [];
                    StatType.values.forEach(value => {
                        this._statsMap[value] = 0;
                    });
                }
                resetStats() {
                    this.emit("reset");
                    this._statsMap = this._statsMap.map(() => 0);
                }
                incStat(statType, value = 1) {
                    this._statsMap[statType] += value;
                    if (this._parent) {
                        this._parent.incStat(statType, value);
                    }
                }
                getStat(statType) {
                    return this._statsMap[statType];
                }
            }
            module.exports.Stats = Stats;
        },
        "./modules/solclient-transport/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                SMFClient
            } = __webpack_require__("./modules/solclient-transport/lib/smf-client.js");
            const {
                TransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/lib/transport-capabilities.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportFactory
            } = __webpack_require__("./modules/solclient-transport/lib/transport-factory.js");
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionStates
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            module.exports.SMFClient = SMFClient;
            module.exports.TransportCapabilities = TransportCapabilities;
            module.exports.TransportError = TransportError;
            module.exports.TransportFactory = TransportFactory;
            module.exports.TransportProtocol = TransportProtocol;
            module.exports.TransportReturnCode = TransportReturnCode;
            module.exports.TransportSessionEventCode = TransportSessionEventCode;
            module.exports.TransportSessionStates = TransportSessionStates;
        },
        "./modules/solclient-transport/lib/base-smf-client.js": module => {
            class BaseSMFClient {
                constructor(rxSmfCB, rxMessageErrorCB, session) {
                    this.reset();
                    this._rxSmfCB = rxSmfCB;
                    this._rxMessageErrorCB = rxMessageErrorCB;
                    this._session = session;
                }
                reset() {
                    this._correlationCounter = 0;
                }
                nextCorrelationTag() {
                    if (++this._correlationCounter >= BaseSMFClient.SMF_MAX_CORRELATION) {
                        this._correlationCounter = 1;
                    }
                    return this._correlationCounter;
                }
            }
            BaseSMFClient.SMF_MAX_CORRELATION = 16777215;
            module.exports.BaseSMFClient = BaseSMFClient;
        },
        "./modules/solclient-transport/lib/buffer-queue.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const BufferImpl = __webpack_require__("buffer").Buffer;
            function concatFrom(list, from, length) {
                const buffer = BufferImpl.allocUnsafe(length);
                let pos = 0;
                let i;
                const buf0 = list[0];
                pos += buf0.copy(buffer, 0, from, buf0.length);
                for (i = 1; i < list.length && pos < length; i++) {
                    const buf = list[i];
                    pos += buf.copy(buffer, pos, 0, buf.length);
                }
                return buffer;
            }
            function readUInt32BEFrag(bufList, listOffsetParam, byteIndexParam) {
                let listOffset = listOffsetParam;
                let byteIndex = byteIndexParam;
                const bytes = [];
                let i = 0;
                for (i = 0; i < 4; i++) {
                    while (bufList[listOffset].length <= byteIndex) {
                        byteIndex -= bufList[listOffset].length;
                        listOffset++;
                        if (listOffset >= bufList.length) {
                            return null;
                        }
                    }
                    bytes[i] = bufList[listOffset].readUInt8(byteIndex);
                    byteIndex++;
                }
                return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
            }
            class BufferQueue {
                constructor(maxSize) {
                    let _queue = [];
                    const _maxSize = maxSize;
                    let _size = 0;
                    let _offset = 0;
                    this.peekView = function peekView(size) {
                        const result = [];
                        if (_queue.length < 1 || size > _size) {
                            return null;
                        }
                        if (_queue[0].length >= size + _offset) {
                            result[0] = _queue[0];
                            result[1] = _offset;
                        } else {
                            result[0] = concatFrom(_queue, _offset, size);
                            result[1] = 0;
                        }
                        return result;
                    };
                    this.readUInt8 = function readUInt8(index) {
                        if (index >= _size) {
                            return null;
                        }
                        const oIndex = index + _offset;
                        if (oIndex < _queue[0].length) {
                            return _queue[0].readUInt8(oIndex);
                        }
                        let pos = _queue[0].length;
                        let i = 1;
                        while (pos + _queue[i].length <= oIndex) {
                            pos += _queue[i].length;
                            i++;
                        }
                        return _queue[i].readUInt8(oIndex - pos);
                    };
                    this.readUInt32BE = function readUInt32BE(index) {
                        if (index + 3 >= _size) {
                            return null;
                        }
                        const oIndex = index + _offset;
                        if (oIndex + 3 < _queue[0].length) {
                            return _queue[0].readUInt32BE(oIndex);
                        }
                        if (oIndex < _queue[0].length) {
                            return readUInt32BEFrag(_queue, 0, oIndex);
                        }
                        let pos = _queue[0].length;
                        let i = 1;
                        while (pos + _queue[i].length <= oIndex) {
                            pos += _queue[i].length;
                            i++;
                        }
                        if (oIndex - pos + 3 < _queue[i].length) {
                            return _queue[i].readUInt32BE(oIndex - pos);
                        }
                        return readUInt32BEFrag(_queue, i, oIndex - pos);
                    };
                    this.put = function put(dataIn) {
                        const buffer = BufferQueue.adaptData(dataIn);
                        const size = buffer.length;
                        if (size === 0) {
                            return true;
                        }
                        if (_size + size >= _maxSize) return false;
                        _queue.push(buffer);
                        _size += size;
                        return true;
                    };
                    this.advance = function advance(size) {
                        if (size < 1) {
                            return;
                        }
                        if (size >= _size) {
                            this.reset();
                            return;
                        }
                        let done = 0;
                        while (done < size) {
                            if (_queue[0].length - _offset <= size - done) {
                                const chunk = _queue[0].length - _offset;
                                _queue.shift();
                                done += chunk;
                                _size -= chunk;
                                _offset = 0;
                            } else {
                                _offset += size - done;
                                _size -= size - done;
                                break;
                            }
                        }
                    };
                    this.reset = function reset() {
                        _queue = [];
                        _size = 0;
                        _offset = 0;
                    };
                    this.remaining = function remaining() {
                        return _size;
                    };
                    this.isEmpty = function isEmpty() {
                        return _size === 0;
                    };
                }
                static adaptData(data) {
                    if (data instanceof BufferImpl) return data;
                    return BufferImpl.from(data);
                }
            }
            module.exports.BufferQueue = BufferQueue;
            module.exports.concatFrom = concatFrom;
        },
        "./modules/solclient-transport/lib/buffer-smf-client.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                BaseSMFClient
            } = __webpack_require__("./modules/solclient-transport/lib/base-smf-client.js");
            const {
                BufferQueue
            } = __webpack_require__("./modules/solclient-transport/lib/buffer-queue.js");
            const {
                Convert,
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const BufferImpl = __webpack_require__("buffer").Buffer;
            const {
                stringToUint8Array
            } = Convert;
            const {
                formatHexString
            } = Hex;
            const SMF_LOST_FRAMING_THRESHOLD = 8e7;
            const {
                LOG_ERROR
            } = new LogFormatter("[buffer-smf-client]");
            function logPeekBuffer(buffer) {
                const bufPair = buffer.peekView(Math.min(buffer.remaining(), 64));
                LOG_ERROR(`First 64 bytes (or fewer) of incoming buffer: \n${DebugLib.Debug.formatDumpBytes(bufPair[0].toString("latin1", bufPair[1]), true, 0)}`);
            }
            class BufferSMFClient extends BaseSMFClient {
                constructor(rxSmfCB, rxMessageErrorCB, session) {
                    super(rxSmfCB, rxMessageErrorCB, session);
                    this._incomingBuffer = new BufferQueue(SMF_LOST_FRAMING_THRESHOLD);
                }
                reset() {
                    super.reset();
                    if (this._incomingBuffer) this._incomingBuffer.reset();
                }
                rxDataString(data) {
                    this._rxDataCB(BufferImpl.from(stringToUint8Array(data)));
                }
                rxDataArrayBuffer(data) {
                    this._rxDataCB(BufferImpl.from(data));
                }
                rxDataBuffer(data) {
                    this._rxDataCB(data);
                }
                _rxDataCB(data) {
                    if (this._session) {
                        this._session.resetKeepAliveCounter();
                    }
                    const buffer = this._incomingBuffer;
                    const putSuccess = buffer.put(data);
                    let remaining = buffer.remaining();
                    if (!putSuccess) {
                        logPeekBuffer(buffer);
                        this._rxMessageErrorCB(`Buffer overflow (length: ${remaining})`);
                        this._incomingBuffer.reset();
                    }
                    while (remaining > 12) {
                        const version = buffer.readUInt8(0) & 7;
                        if (version !== 3) {
                            LOG_ERROR(`Invalid smf version in smf header, version=${version}`);
                            LOG_ERROR("BufferSMFClient._rxDataCB(): couldn't decode message due to invalid smf header");
                            logPeekBuffer(buffer);
                            this._incomingBuffer.reset();
                            this._rxMessageErrorCB("Error parsing incoming SMF - invalid SMF header detected");
                            return;
                        }
                        const messageLen = buffer.readUInt32BE(8);
                        if (messageLen > buffer.remaining()) {
                            break;
                        }
                        const msgBuffer = buffer.peekView(messageLen);
                        const incomingMsg = SMFLib.Codec.Decode.decodeCompoundMessage(msgBuffer[0], msgBuffer[1]);
                        if (incomingMsg && incomingMsg.smfHeader) {
                            buffer.advance(incomingMsg.smfHeader.messageLength);
                            this._rxSmfCB(incomingMsg);
                        } else {
                            const sessionId = this._session ? this._session._sessionId : null;
                            const sessionIdHex = sessionId ? formatHexString(sessionId) : "N/A";
                            LOG_ERROR(`BufferSMFClient._rxDataCB(): couldn't decode message (sessionId=${sessionIdHex})`);
                            logPeekBuffer(buffer);
                            this._incomingBuffer.reset();
                            this._rxMessageErrorCB("Error parsing incoming SMF");
                            return;
                        }
                        remaining = buffer.remaining();
                    }
                    if (remaining) {} else {
                        this._incomingBuffer.reset();
                    }
                }
            }
            module.exports.BufferSMFClient = BufferSMFClient;
        },
        "./modules/solclient-transport/lib/node-tls-opts-mixin.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const fs = __webpack_require__("fs");
            const SolclientSessionLib = __webpack_require__("./modules/solclient-session/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_WARN
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                parseURL
            } = __webpack_require__("./modules/solclient-util/api.js");
            class NodeTLSOptsMixin {
                checkCertificateCNs(host, cert) {
                    if (this._props.sslTrustedCommonNameList && this._props.sslTrustedCommonNameList.length > 0) {
                        LOG_DEBUG("server cert:", cert);
                        const subject = cert["subject"];
                        let valid = false;
                        if (subject) {
                            const cn = subject["CN"];
                            valid = this._props.sslTrustedCommonNameList.some(name => name.toLowerCase() === cn.toLowerCase());
                        }
                        if (!valid) {
                            const error = new Error("Server certificate not trusted - no common name match");
                            error.reason = "Server certificate not trusted - no common name match";
                            error.host = host;
                            error.cert = cert;
                            return error;
                        }
                    }
                    return undefined;
                }
                createTLSOptions() {
                    const props = this._props;
                    const options = {};
                    const useClientCert = props.authenticationScheme === SolclientSessionLib.AuthenticationScheme.CLIENT_CERTIFICATE;
                    options["secureProtocol"] = "SSLv23_method";
                    const constMap = SolclientSessionLib.SessionProperties.SslProtocolExcludeConstantMap;
                    options["secureOptions"] = constMap["sslv2"] | constMap["sslv3"];
                    (props.sslExcludedProtocols || []).forEach(protocol => {
                        options["secureOptions"] |= constMap[protocol.toLowerCase()];
                    });
                    if (props.sslCipherSuites) {
                        const ciphers = props.sslCipherSuites.split(",");
                        const trimmed = ciphers.map(cipher => cipher.trim());
                        options["ciphers"] = trimmed.join(":");
                    } else {
                        options["ciphers"] = props.sslCipherSuites;
                    }
                    options["rejectUnauthorized"] = props.sslValidateCertificate;
                    if (options["rejectUnauthorized"] && Array.isArray(props.sslTrustedCommonNameList)) {
                        options["checkServerIdentity"] = this.checkCertificateCNs.bind(this);
                    }
                    if ((options["rejectUnauthorized"] || useClientCert) && props.sslTrustStores && props.sslTrustStores.length) {
                        const tsContents = [];
                        props.sslTrustStores.forEach(tsFile => {
                            try {
                                tsContents.push(fs.readFileSync(tsFile));
                            } catch (e) {
                                LOG_WARN(`Failed to load trust store ${tsFile}`, e.message);
                                LOG_TRACE("Error details:", e.stack || e);
                                throw new OperationError(`Failed to load trust store ${tsFile}`, ErrorSubcode.FAILED_LOADING_TRUSTSTORE, e);
                            }
                        });
                        options["ca"] = tsContents;
                    }
                    if (useClientCert) {
                        if (props.sslPfx) {
                            try {
                                options["pfx"] = fs.readFileSync(props.sslPfx);
                                options["passphrase"] = props.sslPfxPassword;
                            } catch (e) {
                                LOG_WARN(`Failed to load pfx file ${props.sslPfx}`, e.message);
                                LOG_TRACE("Error details:", e.stack || e);
                                throw new OperationError(`Failed to load pfx ${props.sslPfx}`, ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
                            }
                        }
                        if (props.sslPrivateKey) {
                            try {
                                options["key"] = fs.readFileSync(props.sslPrivateKey);
                                options["passphrase"] = props.sslPrivateKeyPassword;
                            } catch (e) {
                                LOG_WARN(`Failed to load private key ${props.sslPrivateKey}`, e.message);
                                LOG_TRACE("Error details:", e.stack || e);
                                throw new OperationError(`Failed to load private key ${props.sslPrivateKey}`, ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
                            }
                        }
                        if (props.sslCertificate) {
                            try {
                                options["cert"] = fs.readFileSync(props.sslCertificate);
                            } catch (e) {
                                LOG_WARN(`Failed to load certificate file ${props.sslCertificate}`, e.message);
                                LOG_TRACE("Error details:", e.stack || e);
                                throw new OperationError(`Failed to load certificate ${props.sslCertificate}`, ErrorSubcode.FAILED_LOADING_CERTIFICATE_AND_KEY, e);
                            }
                        }
                    }
                    const hostname = parseURL(this._url).hostname;
                    options["servername"] = hostname;
                    return options;
                }
            }
            module.exports.NodeTLSOptsMixin = NodeTLSOptsMixin;
        },
        "./modules/solclient-transport/lib/smf-client.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                BaseSMFClient
            } = __webpack_require__("./modules/solclient-transport/lib/base-smf-client.js");
            const SMFClient = (() => {
                if (typeof navigator !== "undefined") {
                    if (navigator.appVersion.indexOf("MSIE 9.") !== -1 || navigator.appVersion.indexOf("Trident/") !== -1) {
                        return __webpack_require__("./modules/solclient-transport/lib/buffer-smf-client.js").BufferSMFClient;
                    }
                }
                return __webpack_require__("./modules/solclient-transport/lib/buffer-smf-client.js").BufferSMFClient;
            })();
            SMFClient.SMF_CLIENTCTRL_LOGIN_FAKE_CORRELATIONTAG = BaseSMFClient.SMF_MAX_CORRELATION;
            module.exports.SMFClient = SMFClient;
        },
        "./modules/solclient-transport/lib/tcp/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                CompressedTransport
            } = __webpack_require__("./modules/solclient-transport/lib/tcp/transport-compression.js");
            const {
                TcpRawTransport
            } = __webpack_require__("./modules/solclient-transport/lib/tcp/transport-tcp-plaintext.js");
            const {
                TcpTlsTransport
            } = __webpack_require__("./modules/solclient-transport/lib/tcp/transport-tcp-tls.js");
            const {
                TlsOnlyTransport
            } = __webpack_require__("./modules/solclient-transport/lib/tcp/transport-tls.js");
            module.exports.TcpRawTransport = TcpRawTransport;
            module.exports.CompressedTransport = CompressedTransport;
            module.exports.TlsOnlyTransport = TlsOnlyTransport;
            module.exports.TcpTlsTransport = TcpTlsTransport;
        },
        "./modules/solclient-transport/lib/tcp/shuntable-transport.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Duplex
            } = __webpack_require__("stream");
            const {
                LOG_WARN,
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            class ShuntableTransport extends Duplex {
                constructor(options) {
                    super(options);
                    this._shunted = false;
                    this._dontEnd = false;
                    this._underlyingTransport = options.underlyingTransport;
                    this._interimBuffer = [];
                    this._transportDrained = true;
                    this._connected = false;
                }
                shunt() {
                    this._shunted = true;
                }
                dontEnd() {
                    this._dontEnd = true;
                }
                _write(chunk, encoding, callback) {
                    if (!this._shunted) {
                        if (!this._transportDrained || !this._connected) {
                            this._interimBuffer.push([ chunk, callback ]);
                            return;
                        }
                        const rc = this._underlyingTransport.send(chunk);
                        switch (rc) {
                          case TransportReturnCode.OK:
                            this._transportDrained = true;
                            callback();
                            break;

                          case TransportReturnCode.NO_SPACE:
                            this._transportDrained = false;
                            this._interimBuffer.push([ chunk, callback ]);
                            break;

                          case TransportReturnCode.INVALID_STATE_FOR_OPERATION:
                            this.emit("error", "Underlying transport in invalid state for send.");
                            break;

                          default:
                            LOG_WARN(`Unknown return code from undelying transport ${rc}`);
                        }
                    }
                }
                _read() {
                    if (!this._shunted) {
                        this._underlyingTransport.unpause();
                    }
                }
                rxDataBuffer(data) {
                    if (!this._shunted) {
                        const noPause = this.push(data);
                        if (!noPause) {
                            this._underlyingTransport.pause();
                        }
                    }
                }
                eventCB(transportEvent) {
                    switch (transportEvent.getTransportEventCode()) {
                      case TransportSessionEventCode.UP_NOTICE:
                        this.onConnect();
                        break;

                      case TransportSessionEventCode.SEND_ERROR:
                        this.onError(transportEvent);
                        break;

                      case TransportSessionEventCode.DESTROYED_NOTICE:
                        this.onClose(transportEvent);
                        break;

                      case TransportSessionEventCode.CAN_ACCEPT_DATA:
                        this.onDrain();
                        break;

                      default:
                        LOG_WARN(`TLS layer got unkown event code ${transportEvent.getTransportEventCode}`);
                    }
                }
                onError(transportEvent) {
                    if (!this._shunted) {
                        this.emit("error", transportEvent.getInfoStr());
                    }
                }
                onClose(transportEvent) {
                    this._connected = false;
                    if (!this._shunted) {
                        LOG_TRACE(`ShuntableTransport emits close for transport event ${transportEvent}`);
                        this.emit("close");
                    }
                }
                onDrain() {
                    if (!this._shunted) {
                        this._transportDrained = true;
                        if (this._interimBuffer && this._interimBuffer.length > 0) {
                            const resendBuffer = this._interimBuffer;
                            this._interimBuffer = [];
                            resendBuffer.forEach(([ data, callback ]) => this._write(data, null, callback));
                        }
                        if (!this._transportDrained) {
                            return;
                        }
                        this.emit("drain");
                    }
                }
                onConnect() {
                    this._connected = true;
                    if (!this._shunted) {
                        this.onDrain();
                        this.emit("connect");
                    }
                }
                end(chunk, encoding, callback) {
                    if (!this._shunted && !this._dontEnd) {
                        if (typeof chunk === "function") {
                            this._underlyingTransport.destroy("End from TLS");
                            chunk();
                        } else {
                            const cb = () => {
                                this._underlyingTransport.destroy("End from TLS");
                                callback();
                            };
                            this._write(chunk, encoding, cb);
                        }
                    } else if (!this._shunted) {
                        if (typeof chunk !== "function") {
                            this._write(chunk, encoding, callback);
                        } else {
                            chunk();
                        }
                    }
                }
                destroy(error) {
                    if (!this._shunted && !this._dontEnd) {
                        this._underlyingTransport.destroy(error);
                    }
                }
                setNoDelay(arg) {
                    if (!this.shunted) {
                        LOG_TRACE(`Ignoring setNoDelay(${arg})`);
                    }
                }
            }
            module.exports.ShuntableTransport = ShuntableTransport;
        },
        "./modules/solclient-transport/lib/tcp/transport-compression.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const zlib = __webpack_require__("zlib");
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_INFO,
                LOG_WARN
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const {
                formatHexString
            } = Hex;
            class CompressedTransport extends TransportBase {
                constructor(eventCB, client, props) {
                    super("tcp://x", eventCB, client, props);
                    this._clientstats = null;
                    this._underlyingTransport = null;
                    this._sendBufferMaxSize = props.sendBufferMaxSize;
                    this._waitForSocketDrain = false;
                    this._waitForCompressorDrain = false;
                    this._flushCallback = null;
                    this._socketDrained = true;
                    this._compressorDrained = true;
                    this._interimBuffer = [];
                    this._state = TransportSessionState.DOWN;
                    this._socketError = null;
                    this._sessionId = new Date().getTime();
                    this._transportSession = this;
                    this._props.transportProtocol = null;
                    this._compressor = null;
                    this._decompressor = null;
                    this._compressionLevel = props.compressionLevel;
                }
                getClientStats() {
                    return this._clientstats;
                }
                setClientStats(value) {
                    this._clientstats = value;
                }
                setUnderlyingTransport(newUnderlyingTransoprt) {
                    this._underlyingTransport = newUnderlyingTransoprt;
                }
                rxDataBuffer(data) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_DEBUG("TcpTransportCompressedSession stray rxDataBuffer, ignoring.");
                        return;
                    }
                    this._decompressor.write(data);
                    this._decompressor.flush();
                }
                onData(data) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_DEBUG("TcpTransportSession stray onData, ignoring.");
                        return;
                    }
                    if (this._client) {
                        this._client.rxDataBuffer(data);
                    }
                }
                onError(transportEvent) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tcp transport is being destroyed, ignore error");
                        return;
                    }
                    this._state = TransportSessionState.WAITING_FOR_DESTROY;
                    const onErrorStage2 = () => {
                        if (this._eventCB) {
                            LOG_TRACE("Decompressor flush returned, passing error to eventCB.");
                            this._eventCB(transportEvent);
                        } else {
                            LOG_TRACE("Decompressor flush returned, but eventCB already cleared.");
                        }
                    };
                    LOG_TRACE("Flushing decompressor on socket error.");
                    this._decompressor.flush(zlib.Z_SYNC_FLUSH, onErrorStage2);
                }
                onZlibError(error) {
                    this._socketError = error;
                    this._underlyingTransport.destroy(`Connection closed by zlib error. Message:${error}`, ErrorSubcode.COMMUNICATION_ERROR);
                }
                onClose(transportEvent) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        this._destroy(transportEvent);
                    } else {
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        LOG_TRACE("Flushing decompressor on socket close.");
                        const stage2destroy = () => this._destroy(transportEvent);
                        this._decompressor.flush(zlib.Z_SYNC_FLUSH, stage2destroy);
                    }
                }
                onOpen(transportEvent) {
                    if (this._state !== TransportSessionState.WAITING_FOR_CREATE) {
                        LOG_INFO(`compressor stray onOpen when in state ${this._state}, ignoring.`);
                        return;
                    }
                    this._state = TransportSessionState.SESSION_UP;
                    this._eventCB(transportEvent);
                }
                connect() {
                    LOG_TRACE("Initializing compressed transport");
                    let rc = TransportReturnCode.OK;
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_INFO(`Invalid state for operation: ${TransportSessionState.nameOf(this._state)}`);
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    this._state = TransportSessionState.WAITING_FOR_CREATE;
                    if (this._underlyingTransport._state === TransportSessionState.DOWN) {
                        rc = this._underlyingTransport.connect();
                    } else {
                        this._state = TransportSessionState.SESSION_UP;
                    }
                    try {
                        const options = {
                            highWaterMark: this._sendBufferMaxSize,
                            level: this._compressionLevel,
                            flush: zlib.Z_SYNC_FLUSH
                        };
                        this._compressor = zlib.createDeflateRaw(options);
                        this._decompressor = zlib.createInflateRaw({
                            flush: zlib.Z_SYNC_FLUSH
                        });
                        this._decompressor.on("data", this.onData.bind(this));
                        this._decompressor.on("error", this.onZlibError.bind(this));
                        this._compressor.on("error", this.onZlibError.bind(this));
                        this._compressor.on("data", this.sendCompressed.bind(this));
                        this._compressor.on("drain", this.onCompressorDrain.bind(this));
                    } catch (error) {
                        LOG_DEBUG(`Error connecting: ${error}`);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        throw new TransportError(`Could not create Tcp zlib layer: ${error.message}`, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                    }
                    return rc;
                }
                destroy(msg, subcode) {
                    this._state = TransportSessionState.WAITING_FOR_DESTROY;
                    return this._underlyingTransport.destroy(msg, subcode);
                }
                _destroy(transportEvent) {
                    if (this._state !== TransportSessionState.DOWN) {
                        this._state = TransportSessionState.DOWN;
                        const onerrorStub = function onerrorStub() {};
                        this._waitForSocketDrain = false;
                        this._flushCallback = null;
                        this._socketDrained = true;
                        this._client = null;
                        this._compressor.removeAllListeners();
                        this._compressor.on("error", onerrorStub);
                        this._decompressor.removeAllListeners();
                        this._decompressor.on("error", onerrorStub);
                        this._compressor.unpipe();
                        this._compressor._hadError = true;
                        this._compressor.close();
                        this._compressor = null;
                        this._decompressor.close();
                        this._decompressor = null;
                    }
                    if (this._eventCB) {
                        this._eventCB(transportEvent);
                        this._eventCB = null;
                    }
                    return TransportReturnCode.OK;
                }
                eventCB(transportEvent) {
                    switch (transportEvent.getTransportEventCode()) {
                      case TransportSessionEventCode.UP_NOTICE:
                        this.onOpen(transportEvent);
                        break;

                      case TransportSessionEventCode.SEND_ERROR:
                        this.onError(transportEvent);
                        break;

                      case TransportSessionEventCode.DESTROYED_NOTICE:
                        this.onClose(transportEvent);
                        break;

                      case TransportSessionEventCode.CAN_ACCEPT_DATA:
                        this.onDrain(transportEvent);
                        break;

                      default:
                        LOG_WARN("Compressing transport layer got unkown event code " + `${transportEvent.getTransportEventCode}`);
                    }
                }
                flush(callback) {
                    const flushStage2 = () => this._underlyingTransport.flush(callback);
                    this._compressor.flush(flushStage2);
                    return TransportReturnCode.OK;
                }
                send(message, forceAllowEnqueue = false) {
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        LOG_INFO(`Compressing transport can't send in state ${this._state}`);
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (forceAllowEnqueue || this._socketDrained && this._compressorDrained) {
                        if (this._interimBuffer.length > 0) {
                            LOG_WARN(`Allowing send when interimBuffer is ${this._interimBuffer.length}`);
                        }
                        this._compressorDrained = this._compressor.write(message, "ascii");
                        this._compressor.flush();
                        this._clientstats.bytesWritten += message.length;
                        ++this._clientstats.msgWritten;
                        return TransportReturnCode.OK;
                    }
                    if (!this._socketDrained) {
                        this._waitForSocketDrain = true;
                    }
                    if (!this._compressorDrained) {
                        this._waitForCompressorDrain = true;
                    }
                    return TransportReturnCode.NO_SPACE;
                }
                sendCompressed(data) {
                    if (!this._socketDrained) {
                        this._interimBuffer.push(data);
                        this._compressor.pause();
                        return;
                    }
                    const rc = this._underlyingTransport.send(data);
                    switch (rc) {
                      case TransportReturnCode.OK:
                        this._socketDrained = true;
                        break;

                      case TransportReturnCode.NO_SPACE:
                        this._socketDrained = false;
                        this._interimBuffer.push(data);
                        this._compressor.pause();
                        break;

                      case TransportReturnCode.INVALID_STATE_FOR_OPERATION:
                        this.onError(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, "Underlying transport in invalid state for send.", null, ErrorSubcode.CONNECTION_ERROR, null));
                        break;

                      default:
                        LOG_WARN(`Unknown return code from undelying transport ${rc}`);
                    }
                }
                onDrain() {
                    this._socketDrained = true;
                    if (this._interimBuffer && this._interimBuffer.length > 0) {
                        const resendBuffer = this._interimBuffer;
                        this._interimBuffer = [];
                        resendBuffer.forEach(data => this.sendCompressed(data));
                    }
                    if (!this._socketDrained) {
                        return;
                    }
                    this._compressor.resume();
                    if (this._flushCallback) {
                        LOG_DEBUG("Transport emitting FLUSH after drain.");
                        const prevCallback = this._flushCallback;
                        this._flushCallback = null;
                        prevCallback();
                    }
                    if (this._waitForSocketDrain) {
                        this._waitForSocketDrain = false;
                        if (!this._waitForCompressorDrain) {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                        }
                    }
                }
                onCompressorDrain() {
                    this._compressorDrained = true;
                    if (this._waitForCompressorDrain) {
                        this._waitForCompressorDrain = false;
                        if (!this._waitForSocketDrain) {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                        }
                    }
                }
                getInfoStr() {
                    const str = `TcpTransportSession; sid=${formatHexString(this._sessionId)}`;
                    return str;
                }
                pause() {
                    this._underlyingTransport.pause();
                    this._decompressor.pause();
                }
                unpause() {
                    this._underlyingTransport.unpause();
                    this._decompressor.resume();
                }
            }
            module.exports.CompressedTransport = CompressedTransport;
        },
        "./modules/solclient-transport/lib/tcp/transport-tcp-plaintext.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const net = __webpack_require__("net");
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_WARN,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                parseURL
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportClientStats
            } = __webpack_require__("./modules/solclient-transport/lib/transport-client-stats.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const {
                formatHexString
            } = Hex;
            class TcpRawTransport extends TransportBase {
                constructor(url, eventCB, client, props) {
                    super(url, eventCB, client, props);
                    this._clientstats = new TransportClientStats();
                    this._sendBufferMaxSize = props.sendBufferMaxSize;
                    this._canSendNeeded = false;
                    this._flushCallback = null;
                    this._drained = true;
                    this._state = TransportSessionState.DOWN;
                    this._rawSocket = null;
                    this._socketError = null;
                    this._sessionId = new Date().getTime();
                    this._transportSession = this;
                    this._props.transportProtocol = null;
                }
                getClientStats() {
                    return this._clientstats;
                }
                setClientStats(value) {
                    this._clientstats = value;
                }
                rehome(eventCB, client) {
                    this._eventCB = eventCB;
                    this._client = client;
                }
                parseHostPort(urlString) {
                    let port = null;
                    const urlParsed = parseURL(urlString);
                    if (urlParsed.protocol !== "tcp:" && urlParsed.protocol !== "tcps:") {
                        LOG_ERROR(`Tcp Transport: URL with unexpected scheme: ${urlParsed.protocol}`);
                    }
                    const host = urlParsed.hostname;
                    port = urlParsed.port;
                    if (port === null) {
                        if (this._ssl) {
                            port = 55443;
                        } else {
                            port = this._props._compressionLevel > 0 ? 55003 : 55555;
                        }
                    }
                    LOG_TRACE(`Parsing url ${urlString} -> host: ${host} , port: ${port}`);
                    return {
                        host: host,
                        port: port
                    };
                }
                onData(originalSocket, data) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY || originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onData for previous socket, ignoring.");
                        return;
                    }
                    if (this._client) {
                        this._client.rxDataBuffer(data);
                    }
                }
                onError(originalSocket, error) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onError for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tcp transport is being destroyed, ignore error");
                        return;
                    }
                    LOG_DEBUG(`Tcp transport connection error ${error}`);
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        if (this._state === TransportSessionState.WAITING_FOR_CREATE) {
                            LOG_DEBUG(`Tcp transport connection error during establishment. ${error}`);
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._destroy(originalSocket, `Connection failed. Message:${error.message}`, ErrorSubcode.CONNECTION_ERROR);
                        } else {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error${error}`, null, ErrorSubcode.CONNECTION_ERROR, null));
                        }
                    } else {
                        this._socketError = error;
                    }
                }
                onClose(originalSocket, hadError) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onClose for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tcp transport is being destroyed, ignore close");
                        return;
                    }
                    const msg = hadError ? "with error" : "cleanly";
                    const errorMsg = this._socketError && this._socketError.message;
                    this._socketError = null;
                    LOG_DEBUG(`Tcp transport connection is closed ${msg}. Message: ${errorMsg}`);
                    this._state = TransportSessionState.CONNECTION_FAILED;
                    this._destroy(this._rawSocket, `Connection closed ${msg}. Message:${errorMsg}`, ErrorSubcode.COMMUNICATION_ERROR);
                }
                onOpen(originalSocket) {
                    LOG_TRACE("Plaintext transport received socket open event.");
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("Plaintext transport stray onOpen for previous socket, ignoring.");
                        return;
                    }
                    if (this._state !== TransportSessionState.WAITING_FOR_CREATE) {
                        LOG_DEBUG(`TcpTransportSession stray onOpen when in state ${this._state}, ignoring.`);
                        return;
                    }
                    this._state = TransportSessionState.SESSION_UP;
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, "Connected", 0, null, this._sessionId));
                }
                connect() {
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_ERROR(`Invalid state for operation: ${TransportSessionState.nameOf(this._state)}`);
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (this._rawSocket) {
                        LOG_ERROR("TCP transport can not connect once _rawsocket exists.");
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (!this._url) {
                        LOG_WARN("Cannot connect to null URL");
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    LOG_DEBUG("Establishing Tcp transport session");
                    try {
                        this._state = TransportSessionState.WAITING_FOR_CREATE;
                        const {
                            host,
                            port
                        } = this.parseHostPort(this._url);
                        LOG_DEBUG("Constructing socket");
                        this._rawSocket = new net.Socket();
                        this._rawSocket.on("connect", this.onOpen.bind(this, this._rawSocket));
                        this._rawSocket.connect(port, host);
                        LOG_TRACE("Assigning properties to socket");
                        this._rawSocket.on("data", this.onData.bind(this, this._rawSocket));
                        this._rawSocket.on("error", this.onError.bind(this, this._rawSocket));
                        this._rawSocket.on("close", this.onClose.bind(this, this._rawSocket));
                        this._rawSocket.on("drain", this.onDrain.bind(this, this._rawSocket));
                        this._rawSocket.setNoDelay(true);
                        LOG_TRACE("Prepared socket");
                    } catch (error) {
                        LOG_DEBUG(`Error connecting: ${error}`);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        throw new TransportError(`Could not create Tcp socket: ${error.message}`, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                    }
                    LOG_DEBUG("Tcp transport is connecting");
                    return TransportReturnCode.OK;
                }
                destroy(msg, subcode) {
                    return this._destroy(this._rawSocket, msg, subcode);
                }
                _destroy(originalSocket, msg, subcode) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray _destroy for previous socket, ignoring.");
                        return TransportReturnCode.OK;
                    }
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_DEBUG(`Destroy Tcp transport: ${msg}`);
                        this._state = TransportSessionState.WAITING_FOR_DESTROY;
                        const onerrorStub = function onerrorStub() {};
                        if (this._rawSocket) {
                            this._rawSocket.removeAllListeners();
                            this._rawSocket.on("error", onerrorStub);
                            this._rawSocket.destroy();
                            this._rawSocket = null;
                        }
                        this._canSendNeeded = false;
                        this._flushCallback = null;
                        this._drained = true;
                        this._state = TransportSessionState.DOWN;
                        this._client = null;
                    }
                    LOG_TRACE(`Destroying TCP transport. msg: ${msg} subcode: ${subcode}`);
                    if (this._eventCB) {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, msg || "Session is destroyed", null, subcode || 0, this._sessionId));
                        this._eventCB = null;
                    }
                    return TransportReturnCode.OK;
                }
                flush(callback) {
                    if (this._drained) {
                        LOG_DEBUG("Transport emitting FLUSH immediately.");
                        callback();
                    } else if (callback) {
                        this._flushCallback = callback;
                    }
                    return TransportReturnCode.OK;
                }
                send(message, forceAllowEnqueue = false) {
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        LOG_ERROR("plaintext: INVALID_STATE_FOR_OPERATION");
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (forceAllowEnqueue || this._drained || message.length < this._sendBufferMaxSize - this._rawSocket.bufferSize) {
                        this._drained = this._rawSocket.write(message, "ascii");
                        if (this._clientstats) {
                            this._clientstats.bytesWritten += message.length;
                            ++this._clientstats.msgWritten;
                        }
                        return TransportReturnCode.OK;
                    }
                    this._canSendNeeded = true;
                    return TransportReturnCode.NO_SPACE;
                }
                onDrain(originalSocket) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onDrain for previous socket, ignoring.");
                        return;
                    }
                    this._drained = true;
                    if (this._flushCallback) {
                        LOG_DEBUG("Transport emitting FLUSH after drain.");
                        const prevCallback = this._flushCallback;
                        this._flushCallback = null;
                        prevCallback();
                    }
                    if (this._canSendNeeded) {
                        LOG_TRACE("Transport emitting CAN_ACCEPT_DATA");
                        this._canSendNeeded = false;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                    }
                }
                getInfoStr() {
                    const str = `TcpTransportSession; sid=${formatHexString(this._sessionId)}`;
                    return str;
                }
                pause() {
                    if (this._rawSocket) {
                        this._rawSocket.pause();
                    }
                }
                unpause() {
                    if (this._rawSocket) {
                        this._rawSocket.resume();
                    }
                }
            }
            module.exports.TcpRawTransport = TcpRawTransport;
        },
        "./modules/solclient-transport/lib/tcp/transport-tcp-tls.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const net = __webpack_require__("net");
            const tls = __webpack_require__("tls");
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_WARN,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                mixin
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                NodeTLSOptsMixin
            } = __webpack_require__("./modules/solclient-transport/lib/node-tls-opts-mixin.js");
            const {
                parseURL
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportClientStats
            } = __webpack_require__("./modules/solclient-transport/lib/transport-client-stats.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const {
                formatHexString
            } = Hex;
            class TcpTlsTransport extends TransportBase {
                constructor(url, eventCB, client, props) {
                    super(url, eventCB, client, props);
                    this._clientstats = new TransportClientStats();
                    this._sendBufferMaxSize = props.sendBufferMaxSize;
                    this._canSendNeeded = false;
                    this._flushCallback = null;
                    this._drained = true;
                    this._state = TransportSessionState.DOWN;
                    this._tlsSocket = null;
                    this._writable = null;
                    this._socketError = null;
                    this._sessionId = new Date().getTime();
                    this._transportSession = this;
                    this._props.transportProtocol = null;
                }
                getClientStats() {
                    return this._clientstats;
                }
                setClientStats(newValue) {
                    this._clientstats = newValue;
                }
                rehome(eventCB, client) {
                    this._eventCB = eventCB;
                    this._client = client;
                }
                parseHostPort(urlString) {
                    let port = null;
                    const urlParsed = parseURL(urlString);
                    if (urlParsed.protocol !== "tcp:" && urlParsed.protocol !== "tcps:") {
                        LOG_ERROR(`Tcp Transport: URL with unexpected scheme: ${urlParsed.protocol}`);
                    }
                    const host = urlParsed.hostname;
                    port = urlParsed.port;
                    if (port === null) {
                        if (this._ssl) {
                            port = 55443;
                        } else {
                            port = this._compressionLevel > 0 ? 55003 : 55555;
                        }
                    }
                    LOG_TRACE(`Parsing url ${urlString} -> host: ${host} , port: ${port}`);
                    return {
                        host: host,
                        port: port
                    };
                }
                onData(originalSocket, data) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY || originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onData for previous socket, ignoring.");
                        return;
                    }
                    if (this._client) {
                        this._client.rxDataBuffer(data);
                    }
                }
                onError(originalSocket, error) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onError for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tcp transport is being destroyed, ignore error");
                        return;
                    }
                    LOG_DEBUG(`Tcp transport connection error ${error}`);
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        if (this._state === TransportSessionState.WAITING_FOR_CREATE) {
                            LOG_DEBUG(`Tcp transport connection error during establishment. ${error}`);
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._destroy(originalSocket, `Connection failed. Message:${error.message}`, ErrorSubcode.CONNECTION_ERROR);
                        } else {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error${error}`, null, ErrorSubcode.CONNECTION_ERROR, null));
                        }
                    } else {
                        this._socketError = error;
                    }
                }
                onClose(originalSocket, hadError) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onClose for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tcp transport is being destroyed, ignore close");
                        return;
                    }
                    const msg = hadError ? "with error" : "cleanly";
                    const errorMsg = this._socketError && this._socketError.message;
                    this._socketError = null;
                    LOG_DEBUG(`Tcp transport connection is closed ${msg}. Message: ${errorMsg}`);
                    this._state = TransportSessionState.CONNECTION_FAILED;
                    this._destroy(this._rawSocket, `Connection closed ${msg}. Message:${errorMsg}`, ErrorSubcode.COMMUNICATION_ERROR);
                }
                onOpen(originalSocket) {
                    LOG_TRACE("TcpTransportSession received socket open event.");
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onOpen for previous socket, ignoring.");
                        return;
                    }
                    if (this._state !== TransportSessionState.WAITING_FOR_CREATE) {
                        LOG_DEBUG(`TcpTransportSession stray onOpen when in state ${this._state}, ignoring.`);
                        return;
                    }
                    this._state = TransportSessionState.SESSION_UP;
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, "Connected", 0, null, this._sessionId));
                }
                connect() {
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_ERROR(`Invalid state for operation: ${TransportSessionState.nameOf(this._state)}`);
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (this._rawSocket) {
                        LOG_ERROR("TCP transport can not connect once _rawsocket exists.");
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (!this._url) {
                        LOG_WARN("Cannot connect to null URL");
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    LOG_DEBUG("Establishing Tcp transport session");
                    try {
                        this._state = TransportSessionState.WAITING_FOR_CREATE;
                        const {
                            host,
                            port
                        } = this.parseHostPort(this._url);
                        LOG_DEBUG("Constructing socket");
                        this._rawSocket = new net.Socket();
                        this._rawSocket.connect(port, host);
                        const tlsOptions = this.createTLSOptions();
                        tlsOptions.socket = this._rawSocket;
                        this._tlsSocket = tls.connect(tlsOptions);
                        this._tlsSocket.on("secureConnect", this.onOpen.bind(this, this._rawSocket));
                        this._writable = this._tlsSocket;
                        LOG_TRACE("Assigning properties to socket");
                        this._writable.on("data", this.onData.bind(this, this._rawSocket));
                        this._writable.on("error", this.onError.bind(this, this._rawSocket));
                        this._writable.on("close", this.onClose.bind(this, this._rawSocket));
                        this._writable.on("drain", this.onDrain.bind(this, this._rawSocket));
                        this._writable.setNoDelay(true);
                        LOG_TRACE("Prepared socket");
                    } catch (error) {
                        LOG_DEBUG(`Error connecting: ${error}`);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        throw new TransportError(`Could not create Tcp socket: ${error.message}`, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                    }
                    LOG_DEBUG("Tcp transport is connecting");
                    return TransportReturnCode.OK;
                }
                destroy(msg, subcode) {
                    return this._destroy(this._rawSocket, msg, subcode);
                }
                _destroy(originalSocket, msg, subcode) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray _destroy for previous socket, ignoring.");
                        return TransportReturnCode.OK;
                    }
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_DEBUG(`Destroy Tcp transport: ${msg}`);
                        this._state = TransportSessionState.WAITING_FOR_DESTROY;
                        const onerrorStub = function onerrorStub() {};
                        if (this._writable) {
                            this._writable.removeAllListeners();
                            this._writable.on("error", onerrorStub);
                            this._writable.destroy();
                            this._rawSocket = null;
                            this._writable = null;
                        }
                        this._canSendNeeded = false;
                        this._flushCallback = null;
                        this._drained = true;
                        this._state = TransportSessionState.DOWN;
                        this._client = null;
                    }
                    LOG_TRACE(`Destroying TCP transport. msg: ${msg} subcode: ${subcode}`);
                    if (this._eventCB) {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, msg || "Session is destroyed", null, subcode || 0, this._sessionId));
                        this._eventCB = null;
                    }
                    return TransportReturnCode.OK;
                }
                flush(callback) {
                    if (this._drained) {
                        LOG_DEBUG("Transport emitting FLUSH immediately.");
                        callback();
                    } else if (callback) {
                        this._flushCallback = callback;
                    }
                    return TransportReturnCode.OK;
                }
                send(message, forceAllowEnqueue = false) {
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (forceAllowEnqueue || this._drained || message.length < this._sendBufferMaxSize - this._writable.bufferSize) {
                        this._drained = this._writable.write(message, "ascii");
                        if (this._clientstats) {
                            this._clientstats.bytesWritten += message.length;
                            ++this._clientstats.msgWritten;
                        }
                        return TransportReturnCode.OK;
                    }
                    this._canSendNeeded = true;
                    return TransportReturnCode.NO_SPACE;
                }
                onDrain(originalSocket) {
                    if (originalSocket !== this._rawSocket) {
                        LOG_DEBUG("TcpTransportSession stray onDrain for previous socket, ignoring.");
                        return;
                    }
                    this._drained = true;
                    if (this._flushCallback) {
                        LOG_DEBUG("Transport emitting FLUSH after drain.");
                        const prevCallback = this._flushCallback;
                        this._flushCallback = null;
                        prevCallback();
                    }
                    if (this._canSendNeeded) {
                        LOG_TRACE("Transport emitting CAN_ACCEPT_DATA");
                        this._canSendNeeded = false;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                    }
                }
                getInfoStr() {
                    const str = `TcpTransportSession; sid=${formatHexString(this._sessionId)}`;
                    return str;
                }
            }
            mixin(TcpTlsTransport, NodeTLSOptsMixin);
            module.exports.TcpTlsTransport = TcpTlsTransport;
        },
        "./modules/solclient-transport/lib/tcp/transport-tls.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const tls = __webpack_require__("tls");
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                mixin
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                NodeTLSOptsMixin
            } = __webpack_require__("./modules/solclient-transport/lib/node-tls-opts-mixin.js");
            const {
                ShuntableTransport
            } = __webpack_require__("./modules/solclient-transport/lib/tcp/shuntable-transport.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const {
                formatHexString
            } = Hex;
            class TlsOnlyTransport extends TransportBase {
                constructor(url, eventCB, client, props) {
                    super(url, eventCB, client, props);
                    this._clientstats = null;
                    this._underlyingTransport = null;
                    this._sendBufferMaxSize = props.sendBufferMaxSize;
                    this._canSendNeeded = false;
                    this._flushCallback = null;
                    this._drained = true;
                    this._state = TransportSessionState.DOWN;
                    this._tlsSocket = null;
                    this._socketError = null;
                    this._sessionId = new Date().getTime();
                    this._transportSession = this;
                    this._props.transportProtocol = null;
                }
                getClientStats() {
                    return this._clientstats;
                }
                setClientStats(value) {
                    this._clientstats = value;
                }
                setUnderlyingTransport(newUnderlyingTransoprt) {
                    this._underlyingTransport = newUnderlyingTransoprt;
                }
                getUnderlyingTransport() {
                    return this._underlyingTransport;
                }
                rehome(eventCB, client) {
                    this._eventCB = eventCB;
                    this._client = client;
                }
                eventCB(transportEvent) {
                    this._shuntableTransport.eventCB(transportEvent);
                }
                rxDataBuffer(data) {
                    this._shuntableTransport.rxDataBuffer(data);
                }
                onData(originalSocket, data) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY || originalSocket !== this._tlsSocket) {
                        LOG_DEBUG("TcpTransportSession stray onData for previous socket, ignoring.");
                        return;
                    }
                    if (this._client) {
                        this._client.rxDataBuffer(data);
                    }
                }
                onError(originalSocket, error) {
                    if (originalSocket !== this._tlsSocket) {
                        LOG_DEBUG("Tls transport stray onError for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tls transport is being destroyed, ignore error");
                        return;
                    }
                    LOG_DEBUG(`Tls transport connection error ${error}`);
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error${error}`, null, ErrorSubcode.CONNECTION_ERROR, null));
                    } else {
                        this._socketError = error;
                    }
                }
                onClose(originalSocket, hadError) {
                    if (originalSocket !== this._tlsSocket) {
                        LOG_DEBUG("TcpTransportSession stray onClose for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("Tls transport is being destroyed, ignore close");
                        return;
                    }
                    const msg = hadError ? "with error" : "cleanly";
                    const errorMsg = this._socketError && this._socketError.message;
                    this._socketError = null;
                    LOG_DEBUG(`Tls transport connection is closed ${msg}. Message: ${errorMsg}`);
                    this._state = TransportSessionState.CONNECTION_FAILED;
                    this._destroy(this._tlsSocket, `Connection closed ${msg}. Message:${errorMsg}`, ErrorSubcode.COMMUNICATION_ERROR);
                }
                onOpen(originalSocket) {
                    LOG_TRACE("TlsTransportSession received socket open event.");
                    if (originalSocket !== this._tlsSocket) {
                        LOG_DEBUG("TlsTransportSession stray onOpen for previous socket, ignoring.");
                        return;
                    }
                    if (this._state !== TransportSessionState.WAITING_FOR_CREATE) {
                        LOG_DEBUG(`TcpTransportSession stray onOpen when in state ${this._state}, ignoring.`);
                        return;
                    }
                    this._state = TransportSessionState.SESSION_UP;
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, "Connected", 0, null, this._sessionId));
                }
                connect() {
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_ERROR(`Invalid state for operation: ${TransportSessionState.nameOf(this._state)}`);
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (this._tlsSocket) {
                        LOG_ERROR("TCP transport can not connect once _tlsSocket exists.");
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    LOG_DEBUG("Establishing TLS transport session");
                    this._state = TransportSessionState.WAITING_FOR_CREATE;
                    try {
                        const duplexOptions = {
                            underlyingTransport: this._underlyingTransport
                        };
                        this._shuntableTransport = new ShuntableTransport(duplexOptions);
                        this._underlyingTransport.connect();
                        const tlsOptions = this.createTLSOptions();
                        tlsOptions.socket = this._shuntableTransport;
                        this._tlsSocket = tls.connect(tlsOptions);
                        this._tlsSocket.on("secureConnect", this.onOpen.bind(this, this._tlsSocket));
                        LOG_TRACE("Assigning properties to socket");
                        this._tlsSocket.on("data", this.onData.bind(this, this._tlsSocket));
                        this._tlsSocket.on("error", this.onError.bind(this, this._tlsSocket));
                        this._tlsSocket.on("close", this.onClose.bind(this, this._tlsSocket));
                        this._tlsSocket.on("drain", this.onDrain.bind(this, this._tlsSocket));
                        this._tlsSocket.setNoDelay(true);
                        LOG_TRACE("Prepared socket");
                    } catch (error) {
                        LOG_DEBUG(`Error connecting: ${error}`);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        throw new TransportError(`Could not create TLS socket: ${error.message}`, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                    }
                    LOG_DEBUG("TLS transport is connecting");
                    return TransportReturnCode.OK;
                }
                destroy(msg, subcode) {
                    return this._destroy(this._tlsSocket, msg, subcode);
                }
                _destroy(originalSocket, msg, subcode) {
                    if (originalSocket !== this._tlsSocket) {
                        LOG_DEBUG("TcpTransportSession stray _destroy for previous socket, ignoring.");
                        return TransportReturnCode.OK;
                    }
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_DEBUG(`Destroy Tls transport: ${msg}`);
                        this._state = TransportSessionState.WAITING_FOR_DESTROY;
                        const onerrorStub = function onerrorStub() {};
                        if (this._tlsSocket) {
                            this._tlsSocket.removeAllListeners();
                            this._tlsSocket.on("error", onerrorStub);
                            this._tlsSocket.destroy();
                            this._tlsSocket = null;
                        }
                        if (this._underlyingTransport) {
                            this._underlyingTransport.destroy(msg, subcode);
                            this._underlyingTransport = null;
                        }
                        this._canSendNeeded = false;
                        this._flushCallback = null;
                        this._drained = true;
                        this._state = TransportSessionState.DOWN;
                        this._client = null;
                    }
                    LOG_TRACE(`Destroying TCP transport. msg: ${msg} subcode: ${subcode}`);
                    if (this._eventCB) {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, msg || "Session is destroyed", null, subcode || 0, this._sessionId));
                        this._eventCB = null;
                    }
                    return TransportReturnCode.OK;
                }
                flush(callback) {
                    if (this._drained) {
                        LOG_DEBUG("Transport emitting FLUSH immediately.");
                        callback();
                    } else if (callback) {
                        this._flushCallback = callback;
                    }
                    return TransportReturnCode.OK;
                }
                send(message, forceAllowEnqueue = false) {
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (forceAllowEnqueue || this._drained || message.length < this._sendBufferMaxSize - this._tlsSocket.bufferSize) {
                        this._drained = this._tlsSocket.write(message, "ascii");
                        if (this._clientstats) {
                            this._clientstats.bytesWritten += message.length;
                            ++this._clientstats.msgWritten;
                        }
                        return TransportReturnCode.OK;
                    }
                    this._canSendNeeded = true;
                    return TransportReturnCode.NO_SPACE;
                }
                onDrain(originalSocket) {
                    if (originalSocket !== this._tlsSocket) {
                        LOG_DEBUG("TcpTransportSession stray onDrain for previous socket, ignoring.");
                        return;
                    }
                    this._drained = true;
                    if (this._flushCallback) {
                        LOG_DEBUG("Transport emitting FLUSH after drain.");
                        const prevCallback = this._flushCallback;
                        this._flushCallback = null;
                        prevCallback();
                    }
                    if (this._canSendNeeded) {
                        LOG_TRACE("Transport emitting CAN_ACCEPT_DATA");
                        this._canSendNeeded = false;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                    }
                }
                getInfoStr() {
                    const str = `TcpTransportSession; sid=${formatHexString(this._sessionId)}`;
                    return str;
                }
                tlsShutdown(callback) {
                    this._tlsSocket.removeAllListeners("close");
                    this._tlsSocket.on("close", this.tlsShutdownStage2.bind(this, callback));
                    this._shuntableTransport.dontEnd();
                    this._tlsSocket.end();
                }
                tlsShutdownStage2(callback) {
                    this._shuntableTransport.shunt();
                    this._tlsSocket.removeAllListeners();
                    this._tlsSocket = null;
                    this._shuntableTransport = null;
                    this._underlyingTransport.rehome(this._eventCB, this._client);
                    this._underlyingTransport.setClientStats(this.getClientStats());
                    this.setClientStats(null);
                    this._eventCB = null;
                    this._client = null;
                    callback(this._underlyingTransport);
                }
            }
            mixin(TlsOnlyTransport, NodeTLSOptsMixin);
            module.exports.TlsOnlyTransport = TlsOnlyTransport;
        },
        "./modules/solclient-transport/lib/transport-base.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            class TransportBase {
                constructor(url, eventCB, client, transportProps, interceptor = null) {
                    this._url = url;
                    this._ssl = TransportBase.useSsl(url);
                    this._client = client;
                    this._eventCB = eventCB;
                    this._props = transportProps;
                    this.setInterceptor(interceptor);
                }
                connect() {
                    return TransportReturnCode.OK;
                }
                destroy(immediate, msg, subcode) {
                    return TransportReturnCode.OK;
                }
                flush(callback) {
                    callback();
                    return TransportReturnCode.OK;
                }
                send(message, forceAllowEnqueue = false) {
                    return TransportReturnCode.OK;
                }
                getTransportProtocol() {
                    return this._props.transportProtocol;
                }
                getInfoStr() {
                    return null;
                }
                getClientStats() {
                    return null;
                }
                beginDowngrade(msg, subcode) {
                    return false;
                }
                setInterceptor(interceptor) {
                    if (this._interceptor) {
                        if (this._interceptor.removed) this._interceptor.removed(this);
                    }
                    this._interceptor = interceptor;
                    if (interceptor) {
                        if (interceptor.installed) interceptor.installed(this);
                    }
                }
                toString() {
                    return `${this.getTransportProtocol()}${this._ssl ? " (SSL)" : ""}`;
                }
                static useSsl(url) {
                    const urlParts = (url || "").split("://");
                    if (urlParts.length === 0 || TransportBase.validSchemes.indexOf(urlParts[0]) < 0) {
                        throw new OperationError(`Invalid url "${url}": Only [${TransportBase.validSchemes.join(", ")}] URL schemes are supported`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    const useSSL = urlParts[0] === "https" || urlParts[0] === "wss" || urlParts[0] === "tcps";
                    return useSSL;
                }
            }
            TransportBase.validSchemes = [ "http", "https", "ws", "wss", "tcp", "tcps" ];
            module.exports.TransportBase = TransportBase;
        },
        "./modules/solclient-transport/lib/transport-capabilities.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                WebTransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/lib/web/api.js");
            const TransportCapabilities = {
                web: WebTransportCapabilities
            };
            module.exports.TransportCapabilities = TransportCapabilities;
        },
        "./modules/solclient-transport/lib/transport-client-stats.js": module => {
            class TransportClientStats {
                constructor() {
                    this.bytesWritten = 0;
                    this.msgWritten = 0;
                }
            }
            module.exports.TransportClientStats = TransportClientStats;
        },
        "./modules/solclient-transport/lib/transport-error.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                SolaceError
            } = __webpack_require__("./modules/solclient-error/api.js");
            class TransportError extends SolaceError {
                constructor(message, subcode) {
                    super("TransportError", message);
                    this.subcode = subcode;
                }
                toString() {
                    return `${super.toString()}, subcode=${this.subcode}`;
                }
            }
            module.exports.TransportError = TransportError;
        },
        "./modules/solclient-transport/lib/transport-factory.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                TcpRawTransport,
                CompressedTransport,
                TlsOnlyTransport,
                TcpTlsTransport
            } = true ? __webpack_require__("./modules/solclient-transport/lib/tcp/api.js") : 0;
            const {
                WebTransport
            } = __webpack_require__("./modules/solclient-transport/lib/web/api.js");
            const TransportFactory = {
                createTransport(host, eventCB, client, props, getId) {
                    const url = host;
                    Object.assign(props, {
                        connectTimeoutInMsecs: 1e5
                    });
                    if (TcpRawTransport && url.trim().startsWith("tcp")) {
                        if (!url.trim().startsWith("tcps")) {
                            if (props.compressionLevel === 0) {
                                LOG_TRACE("createTransport raw tcp");
                                return new TcpRawTransport(url, eventCB, client, props);
                            }
                            LOG_TRACE("createTransport compressed plaintex.");
                            const compressingLayer = new CompressedTransport(eventCB, client, props);
                            const plaintextTransport = new TcpRawTransport(url, compressingLayer.eventCB.bind(compressingLayer), compressingLayer, props);
                            compressingLayer.setClientStats(plaintextTransport.getClientStats());
                            plaintextTransport.setClientStats(null);
                            compressingLayer.setUnderlyingTransport(plaintextTransport);
                            return compressingLayer;
                        }
                        if (props.sslConnectionDowngradeTo !== "PLAIN_TEXT") {
                            LOG_TRACE("createTransport monolithic tls");
                            return new TcpTlsTransport(url, eventCB, client, props);
                        }
                        LOG_TRACE("createTransport composite tls (anticipating downgrade)");
                        const tlsLayer = new TlsOnlyTransport(url, eventCB, client, props);
                        const plaintextTransport = new TcpRawTransport(url, tlsLayer.eventCB.bind(tlsLayer), tlsLayer, props);
                        tlsLayer.setClientStats(plaintextTransport.getClientStats());
                        plaintextTransport.setClientStats(null);
                        tlsLayer.setUnderlyingTransport(plaintextTransport);
                        return tlsLayer;
                    }
                    LOG_TRACE("createTransport WebTransport");
                    return new WebTransport(url, eventCB, client, props, getId);
                },
                startCompression(uncompressedTransport) {
                    const eventCB = uncompressedTransport._eventCB;
                    const client = uncompressedTransport._client;
                    const props = uncompressedTransport._props;
                    const compressingLayer = new CompressedTransport(eventCB, client, props);
                    uncompressedTransport.rehome(compressingLayer.eventCB.bind(compressingLayer), compressingLayer);
                    compressingLayer.setClientStats(uncompressedTransport.getClientStats());
                    uncompressedTransport.setClientStats(null);
                    compressingLayer.setUnderlyingTransport(uncompressedTransport);
                    compressingLayer.connect();
                    return compressingLayer;
                },
                severTls(encryptedTransport, compress, callback) {
                    if (!compress) {
                        encryptedTransport.tlsShutdown(callback);
                    } else {
                        const precallback = plaintextTransport => callback(this.startCompression(plaintextTransport));
                        encryptedTransport.tlsShutdown(precallback);
                    }
                }
            };
            module.exports.TransportFactory = TransportFactory;
        },
        "./modules/solclient-transport/lib/transport-protocol-handler.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const WebTransportsLib = __webpack_require__("./modules/solclient-transport/lib/web/api.js");
            const {
                Lazy
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                lazyValue
            } = Lazy;
            const lutTransportProtocols = lazyValue(() => {
                const protocols = {
                    [TransportProtocol.HTTP_BASE64]: WebTransportsLib.StateBase64,
                    [TransportProtocol.HTTP_BINARY]: WebTransportsLib.StateBinary,
                    [TransportProtocol.HTTP_BINARY_STREAMING]: WebTransportsLib.StateStreamingAndBinary,
                    [TransportProtocol.WS_BINARY]: WebTransportsLib.StateWebSocketBinary
                };
                return protocols;
            });
            class TransportProtocolHandler {
                constructor(url, webTransportProtocolList) {
                    const useSSL = TransportBase.useSsl(url);
                    let transport = null;
                    let downgradeTransport = null;
                    webTransportProtocolList.slice().reverse().forEach(el => {
                        const TransportConstructor = lutTransportProtocols.value[el];
                        transport = new TransportConstructor(useSSL, this.switchState.bind(this), downgradeTransport);
                        downgradeTransport = transport;
                    });
                    this._transport = transport;
                    this._transport.onEnter();
                }
                getTransportProtocol() {
                    return this._transport.getTransportProtocol();
                }
                completeDowngrade(err) {
                    return this._transport.completeDowngrade(err);
                }
                canCompleteDowngrade() {
                    return this._transport.getNextState() !== null;
                }
                toString() {
                    return this._transport.toString();
                }
                switchState(newState, reason) {
                    LOG_TRACE(`Switching ${this._transport} => ${newState} (${reason})`);
                    this._transport = newState;
                    newState.onEnter();
                }
            }
            module.exports.TransportProtocolHandler = TransportProtocolHandler;
        },
        "./modules/solclient-transport/lib/transport-protocols.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const TransportProtocol = {
                HTTP_BASE64: "HTTP_BASE64",
                HTTP_BINARY: "HTTP_BINARY",
                HTTP_BINARY_STREAMING: "HTTP_BINARY_STREAMING",
                WS_BINARY: "WS_BINARY"
            };
            module.exports.TransportProtocol = Enum.new(TransportProtocol);
        },
        "./modules/solclient-transport/lib/transport-return-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const TransportReturnCode = {
                OK: 0,
                FAIL: 1,
                NO_SPACE: 2,
                DATA_DECODE_ERROR: 3,
                INVALID_STATE_FOR_OPERATION: 4,
                CONNECTION_ERROR: 5
            };
            module.exports.TransportReturnCode = Enum.new(TransportReturnCode);
            module.exports.TransportReturnCode._setCanonical({
                OK: TransportReturnCode.OK,
                FAIL: TransportReturnCode.FAIL,
                NO_SPACE: TransportReturnCode.NO_SPACE,
                DATA_DECODE_ERROR: TransportReturnCode.DATA_DECODE_ERROR,
                INVALID_STATE_FOR_OPERATION: TransportReturnCode.INVALID_STATE_FOR_OPERATION,
                CONNECTION_ERROR: TransportReturnCode.CONNECTION_ERROR
            });
        },
        "./modules/solclient-transport/lib/transport-session-event-codes.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const TransportSessionEventCode = {
                UP_NOTICE: 1,
                DESTROYED_NOTICE: 2,
                CAN_ACCEPT_DATA: 4,
                DATA_DECODE_ERROR: 5,
                PARSE_FAILURE: 6,
                CONNECT_TIMEOUT: 7,
                SEND_ERROR: 8,
                DOWNGRADE_FAILED: 10,
                DOWNGRADE_SUCCEEDED: 11
            };
            module.exports.TransportSessionEventCode = Enum.new(TransportSessionEventCode);
        },
        "./modules/solclient-transport/lib/transport-session-event.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                formatHexString
            } = Hex;
            class TransportSessionEvent {
                constructor(tsEventCode, infoStr, responseCode, subcode, sessionId) {
                    this._transportEventCode = tsEventCode;
                    this._infoStr = infoStr;
                    this._responseCode = responseCode;
                    this._errorSubcode = subcode;
                    this._sid = sessionId;
                }
                getTransportEventCode() {
                    return this._transportEventCode;
                }
                get transportEventCode() {
                    return this._transportEventCode;
                }
                getInfoStr() {
                    return this.infoStr;
                }
                get infoStr() {
                    return this._infoStr;
                }
                getResponseCode() {
                    return this.responseCode;
                }
                get responseCode() {
                    return this._responseCode;
                }
                getSubcode() {
                    return this.errorSubcode;
                }
                get errorSubcode() {
                    return this._errorSubcode;
                }
                getSessionId() {
                    return this.sessionId;
                }
                get sessionId() {
                    return this._sid;
                }
                [Symbol.for("nodejs.util.inspect.custom")]() {
                    return {
                        transportEventCode: TransportSessionEventCode.describe(this.transportEventCode),
                        infoStr: this.infoStr,
                        responseCode: this.responseCode,
                        errorSubcode: ErrorSubcode.describe(this.errorSubcode),
                        sid: this.sid && formatHexString(this.sid) || "N/A"
                    };
                }
                toString() {
                    return util_inspect(this);
                }
            }
            module.exports.TransportSessionEvent = TransportSessionEvent;
        },
        "./modules/solclient-transport/lib/transport-session-states.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const TransportSessionState = {
                DOWN: 0,
                WAITING_FOR_CREATE: 1,
                SESSION_UP: 2,
                WAITING_FOR_DESTROY: 4,
                CONNECTION_FAILED: 5
            };
            module.exports.TransportSessionState = Enum.new(TransportSessionState);
        },
        "./modules/solclient-transport/lib/tsh-state.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LOG_INFO,
                LOG_WARN
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                Process
            } = __webpack_require__("./modules/solclient-util/api.js");
            class TSHState {
                constructor(useSsl, tpProtocol, exitCallback, nextState) {
                    this._ssl = !!useSsl;
                    this._transportProtocol = tpProtocol;
                    this._exitCallback = exitCallback;
                    this._nextState = nextState;
                    this._unsupportedRuntimeMessage = `${this._transportProtocol} not supported by this runtime: ${Process.userAgent}`;
                }
                getNextState() {
                    return this._nextState;
                }
                setNextState(nextState) {
                    this._nextState = nextState;
                }
                getTransportProtocol() {
                    return this._transportProtocol;
                }
                getUseSsl() {
                    return this._ssl;
                }
                validateLegal() {
                    return true;
                }
                onEnter() {
                    if (!this.validateLegal()) {
                        if (this._nextState && this._exitCallback) {
                            this._exitCallback(this._nextState, this._unsupportedRuntimeMessage);
                        } else {
                            LOG_WARN(`${this._unsupportedRuntimeMessage}, no next state.`);
                        }
                    }
                }
                completeDowngrade(err) {
                    if (this._nextState && this._exitCallback) {
                        LOG_INFO(`Connect failed (${err}), try next state.`);
                        this._exitCallback(this._nextState, "Connect failed");
                        return true;
                    }
                    LOG_WARN(`Connect failed (${err}), no next state.`);
                    return false;
                }
                toString() {
                    return this._transportProtocol + (this._ssl ? " (SSL)" : "");
                }
            }
            module.exports.TSHState = TSHState;
        },
        "./modules/solclient-transport/lib/web/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const HTTPLib = __webpack_require__("./modules/solclient-transport/lib/web/http/api.js");
            const {
                StateBase64
            } = __webpack_require__("./modules/solclient-transport/lib/web/state-base64.js");
            const {
                StateBinary
            } = __webpack_require__("./modules/solclient-transport/lib/web/state-binary.js");
            const {
                StateStreamingAndBinary
            } = __webpack_require__("./modules/solclient-transport/lib/web/state-streaming-and-binary.js");
            const {
                StateWebSocketBinary
            } = __webpack_require__("./modules/solclient-transport/lib/web/state-websocket-binary.js");
            const {
                WebTransport
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport.js");
            const {
                WebTransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js");
            const {
                HTTPConnection,
                HTTPTransportSession
            } = HTTPLib;
            module.exports.HTTPConnection = HTTPConnection;
            module.exports.HTTPTransportSession = HTTPTransportSession;
            module.exports.StateBase64 = StateBase64;
            module.exports.StateBinary = StateBinary;
            module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
            module.exports.StateWebSocketBinary = StateWebSocketBinary;
            module.exports.WebTransport = WebTransport;
            module.exports.WebTransportCapabilities = WebTransportCapabilities;
        },
        "./modules/solclient-transport/lib/web/http/api.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
            const {
                HTTPConnection
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/http-connection.js");
            const {
                HTTPTransportSession
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/http-transport-session.js");
            if (false) {}
        },
        "./modules/solclient-transport/lib/web/http/http-connection.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const {
                Convert,
                Base64
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                LOG_DEBUG,
                LOG_INFO,
                LOG_WARN,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                sendXhrBinary,
                sendXhrText
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/send-xhr.js");
            const {
                StringBuffer,
                TimingBucket
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                XHRFactory
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/xhr-factory.js");
            const {
                arrayBufferToString
            } = Convert;
            const SOL_CONNECTION_DEBUG = false;
            function prependOrigin(url) {
                if (!url.match(/^(http|ws)(s?):/i) && window.location && window.location.origin) {
                    return window.location.origin + (url.charAt(0) !== "/" ? "/" : "") + url;
                }
                return url;
            }
            function getTs() {
                return new Date().getTime();
            }
            class Stats {
                constructor() {
                    this.WaitedToken = new TimingBucket("WaitedToken", 100);
                    this.HadToken = new TimingBucket("HadToken", 100);
                    this.ReturnedToken = new TimingBucket("ReturnedToken", 100);
                }
                toString() {
                    let s = "";
                    [ this.WaitedToken, this.HadToken, this.ReturnedToken ].forEach(b => {
                        if (b && b.bucketCount() > 0) {
                            s += `${b.name} >> ${b}\n`;
                        }
                    });
                    return s;
                }
            }
            class HTTPConnection {
                constructor(url, base64Enc, streamProgressEvents, rxDataCb, connectionErrorCb, contentType, connectionClose) {
                    this.Options = {
                        url: prependOrigin(url),
                        contentType: contentType,
                        base64Enc: base64Enc,
                        streamProgressEvents: streamProgressEvents,
                        connectionClose: connectionClose
                    };
                    this._streamProgressBytes = 0;
                    this._xhr = null;
                    this._rxDataCb = rxDataCb;
                    this._connErrorCb = connectionErrorCb;
                    this._reqActive = false;
                    this._REQCOUNTER = 0;
                    this._REQBASE = Math.floor(Math.random() * 1e3);
                    this._xhr = XHRFactory.create();
                    this._handleAbortedReq = !HTTPConnection.browserSupportsXhrBinary();
                    this.stats = new Stats();
                }
                recStat(s) {
                    if (!SOL_CONNECTION_DEBUG) {
                        return;
                    }
                    const stats = this.stats;
                    if (s === "GotToken") {
                        stats.LastGotToken = getTs();
                        if (stats.LastSendMsg) {
                            const waitedTok = stats.LastGotToken - stats.LastSendMsg;
                            stats.WaitedToken.log(waitedTok);
                            if (waitedTok > 100) {
                                LOG_WARN(`Abnormally long waitToken, last request: ${this._REQBASE}_${this._REQCOUNTER}`);
                            }
                        }
                    }
                    if (s === "SendMsg") {
                        stats.LastSendMsg = getTs();
                        const hadToken = stats.LastSendMsg - stats.LastGotToken;
                        stats.HadToken.log(hadToken);
                    }
                    if (s === "GotData") {
                        stats.LastGotData = getTs();
                    }
                    if (s === "ReturnToken") {
                        stats.LastReturnToken = getTs();
                        if (stats.LastGotData) {
                            const returnedToken = stats.LastReturnToken - stats.LastGotData;
                            stats.ReturnedToken.log(returnedToken);
                        }
                    }
                }
                send(data, attempt = 0, maxRetry = 1) {
                    if (attempt > 0) {
                        this._xhr.abort();
                        this._xhr = XHRFactory.create();
                    }
                    this._xhr.open("POST", this.Options.url, true);
                    this._streamProgressBytes = 0;
                    this._xhr.onreadystatechange = () => this.xhrStateChange(data, attempt, maxRetry);
                    this._reqActive = true;
                    if (SOL_CONNECTION_DEBUG) {
                        this._REQCOUNTER++;
                        this._xhr.setRequestHeader("sol-request-track", `${this._REQBASE}_${this._REQCOUNTER}`);
                    }
                    if (this.Options.base64Enc) {
                        sendXhrText(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
                    } else {
                        sendXhrBinary(this._xhr, data, this.Options.contentType, this.Options.connectionClose);
                    }
                    this.recStat("SendMsg");
                }
                xhrStateChange(sentdata, attempt, maxRetry) {
                    const readyState = this._xhr.readyState;
                    const RS_LOADING = this._xhr.LOADING;
                    const RS_DONE = this._xhr.DONE;
                    if (!(this.Options.streamProgressEvents && readyState === RS_LOADING || readyState === RS_DONE)) {
                        return;
                    }
                    if (!this._reqActive) {
                        return;
                    }
                    let status = null;
                    if (this._handleAbortedReq) {
                        try {
                            status = this._xhr.status;
                        } catch (e) {
                            LOG_INFO(`Error trying to access status in XHR due to request aborted: ${e.message}`);
                            return;
                        }
                    } else {
                        status = this._xhr.status;
                    }
                    if (status === 200 || status === 304) {
                        let data = null;
                        if (this._xhr.responseType && this._xhr.responseType === "arraybuffer") {
                            data = arrayBufferToString(this._xhr.response);
                        } else {
                            data = this._xhr.responseText;
                        }
                        data = data.substring(this._streamProgressBytes, data.length);
                        this._streamProgressBytes += data.length;
                        if (data.length === 0 && readyState === RS_LOADING) {
                            return;
                        }
                        if (this.Options.base64Enc) {
                            try {
                                data = Base64.decode(data);
                            } catch (e) {
                                LOG_ERROR(`Data decode error on: ${data}`);
                                LOG_ERROR(`Data decode error is: ${e.message}`);
                                this._rxDataCb(TransportReturnCode.DATA_DECODE_ERROR, data);
                                return;
                            }
                        } else {
                            const decodedData = [];
                            const dataLength = data.length;
                            for (let i = 0; i < dataLength; i++) {
                                decodedData.push(String.fromCharCode(data.charCodeAt(i) & 255));
                            }
                            data = decodedData.join("");
                        }
                        if (readyState === RS_DONE) {
                            this._reqActive = false;
                        }
                        this._rxDataCb(TransportReturnCode.OK, data);
                        if (readyState === RS_DONE && data.length > 0) {
                            this._rxDataCb(TransportReturnCode.OK, "");
                        }
                        return;
                    }
                    const statusText = this._xhr.statusText;
                    let responseText = "";
                    if (this._xhr.responseType && this._xhr.responseType === "arraybuffer") {
                        responseText = arrayBufferToString(this._xhr.response);
                    } else {
                        responseText = this._xhr.responseText || "";
                    }
                    const responseTextLen = responseText.length;
                    const requestUrl = this.Options.url;
                    const sentdataLen = sentdata ? sentdata.length : 0;
                    const {
                        formatDumpBytes
                    } = DebugLib.Debug;
                    const responseTextDump = formatDumpBytes(responseText.substr(0, Math.min(responseTextLen, 64)), true, 0);
                    const sentTextDump = formatDumpBytes((sentdata || "").substr(0, Math.min(sentdataLen, 256)), true, 0);
                    if (false) {}
                    const nextMaxRetry = maxRetry;
                    if (this._reqActive && status !== 400 && responseText.length === 0 && (attempt === 0 || attempt < nextMaxRetry)) {
                        LOG_INFO(`XHR failed while request active, will retry send, retry=${attempt + 1}`);
                        this.send(sentdata, attempt + 1, nextMaxRetry);
                    } else {
                        this._reqActive = false;
                        this._connErrorCb(status, new StringBuffer(`HTTP request failed(status=${status} statusText=${statusText}, `, `responseText length=${responseTextLen}, responseText[0..64]=\n`, responseTextDump, `XHR errorCode=${this._xhr._error ? this._xhr._error.code : ""})`).toString());
                    }
                }
                isUsingBase64() {
                    return this.Options.base64Enc;
                }
                abort() {
                    this._reqActive = false;
                    if (this._xhr && this._xhr.abort) {
                        this._xhr.abort();
                    }
                }
                static browserSupportsXhrBinary() {
                    return sendXhrBinary !== sendXhrText;
                }
                static browserSupportsStreamingResponse() {
                    const xhr = XHRFactory.create();
                    const check = xhr && xhr.onprogress === null;
                    LOG_INFO(`http browserStreamingCheck - if XMLHTTPRequest supported and XMLHTTPRequest support onprogress: ${check}`);
                    return check;
                }
            }
            module.exports.HTTPConnection = HTTPConnection;
        },
        "./modules/solclient-transport/lib/web/http/http-transport-session.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const DebugLib = __webpack_require__("./modules/solclient-debug/api.js");
            const SMFLib = __webpack_require__("./modules/solclient-smf/api.js");
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                Convert,
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                HTTPConnection
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/http-connection.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                SMFClient
            } = __webpack_require__("./modules/solclient-transport/lib/smf-client.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const {
                WebTransportSessionBase
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-session-base.js");
            const {
                int32ToStr,
                strToByteArray,
                strToHexArray
            } = Convert;
            const {
                formatHexString
            } = Hex;
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_ERROR,
                LOG_INFO
            } = new LogFormatter("[http-transport-session]");
            const PacketReadState = {
                READING_HEADER: 0,
                STREAMING: 1
            };
            const BufferImpl = __webpack_require__("buffer").Buffer;
            const MSIE_TRANSPORT_PADDING = 257;
            function adaptURL(url) {
                const v = url.match(/(ws|http)(s?:\/\/.+)/);
                return `http${v[2]}`;
            }
            class HTTPTransportSession extends WebTransportSessionBase {
                constructor(baseUrl, eventCB, client, props) {
                    super(baseUrl, eventCB, client, props);
                    this._haveToken = true;
                    this._confMaxWebPayload = props.maxWebPayload;
                    this._maxPayloadBytes = 0;
                    this._destroyTimer = null;
                    this._destroyTimeout = props.connectTimeoutInMsecs;
                    this._createUrl = adaptURL(baseUrl);
                    this._routerUrl = this._createUrl;
                    this._rxChannelClient = null;
                    this._httpSendConn = null;
                    this._httpReceiveConn = null;
                    this._smfDataTokenTSHeader = null;
                    this._routerTag = "";
                    this._sid = null;
                    if (props.transportProtocol === null || props.transportProtocol === undefined) {
                        throw new OperationError("transportProtocol is not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    this._transportProtocol = props.transportProtocol;
                    this._useBinaryTransport = false;
                    this._useStreamingTransport = false;
                    this._streamingTransportPadding = 0;
                    this._useBinaryTransport = props.transportProtocol !== TransportProtocol.HTTP_BASE64;
                    this._useStreamingTransport = props.transportProtocol === TransportProtocol.HTTP_BINARY_STREAMING;
                    this._incomingBuffer = "";
                    this._packetReadState = PacketReadState.READING_HEADER;
                    const agent = navigator.userAgent || "";
                    if (agent.match(/trident/i) || agent.match(/msie/i)) {
                        this._streamingTransportPadding = MSIE_TRANSPORT_PADDING;
                    }
                    if (props.transportContentType === null || props.transportContentType === undefined) {
                        throw new OperationError("transportContentType is not set", ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                    this._contentType = props.transportContentType;
                }
                connectTimerExpiry() {
                    LOG_INFO("HTTP transport connect timeout");
                    this.destroyCleanup("HTTP transport connect timeout", ErrorSubcode.TIMEOUT);
                }
                get sessionIdHex() {
                    return this._sid ? formatHexString(this._sid) : "";
                }
                updateMaxWebPayload() {
                    const trLessEncapSMF = this._confMaxWebPayload - 22;
                    this._maxPayloadBytes = this._useBinaryTransport ? trLessEncapSMF : Math.floor(trLessEncapSMF * .75);
                }
                connect() {
                    if (this._state !== TransportSessionState.DOWN) {
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    return this.connectInternal();
                }
                connectInternal() {
                    this._connError = null;
                    try {
                        this._createConn = new HTTPConnection(this._createUrl, !this._useBinaryTransport, false, (rc, data) => this.handleCreateResponse(rc, data), (rc, data) => this.handleCreateConnFailure(rc, data), this._contentType);
                    } catch (e) {
                        LOG_INFO(`Failed to create connection to router: ${e.message}`);
                        this._connError = e;
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    if (Check.nothing(this._createConn)) {
                        LOG_INFO("Failed to create connection to router");
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    const createMsg = SMFLib.Codec.Transport.genTsCreateHeader();
                    if (this._state === TransportSessionState.WAITING_FOR_CREATE) {
                        LOG_DEBUG("Connect attempt while in WAITING_FOR_CREATE (retry)");
                    } else {
                        this.createConnectTimeout();
                        this._state = TransportSessionState.WAITING_FOR_CREATE;
                    }
                    try {
                        this._createConn.send(createMsg);
                    } catch (connError) {
                        LOG_INFO(`Error connecting: ${connError.message}`);
                        LOG_TRACE("Error details:", connError.stack || connError);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        this.cancelConnectTimeout();
                        if (connError instanceof TransportError) {
                            this._connError = connError;
                        } else {
                            this._connError = new TransportError(`Could not create HTTP transport session: ${connError.message}`, connError.subcode || ErrorSubcode.CONNECTION_ERROR);
                        }
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    return TransportReturnCode.OK;
                }
                destroy(msg, subcode) {
                    LOG_TRACE(`Destroy transport session when in state ${this._state}`);
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY || this._state === TransportSessionState.DOWN) {
                        return TransportReturnCode.OK;
                    }
                    if (this._state === TransportSessionState.CONNECTION_FAILED || this._state === TransportSessionState.WAITING_FOR_CREATE) {
                        LOG_INFO("The connection is in unreliable state, close transport");
                        this.destroyCleanup(msg, subcode, true);
                        return TransportReturnCode.OK;
                    }
                    LOG_INFO("Destroy transport session immediately");
                    this._state = TransportSessionState.WAITING_FOR_DESTROY;
                    if (this._httpSendConn !== null) {
                        LOG_INFO("Destroy transport session: abort sendConn");
                        this._httpSendConn.abort();
                    }
                    if (this._httpReceiveConn !== null) {
                        LOG_INFO("Destroy transport session: abort receiveConn");
                        this._httpReceiveConn.abort();
                    }
                    this._destroyTimer = setTimeout(() => {
                        this.destroyTimerExpiry();
                    }, this._destroyTimeout);
                    this._httpSendConn = new HTTPConnection(this._routerUrl, !this._useBinaryTransport, false, (rc, data) => this.handleRxDataToken(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType, true);
                    const destroyMsg = SMFLib.Codec.Transport.genTsDestroyHeader(this._sid);
                    LOG_TRACE(`destroy message: ${strToHexArray(destroyMsg)}`);
                    this._httpSendConn.send(destroyMsg);
                    return TransportReturnCode.OK;
                }
                send(dataIn, forceAllowEnqueue = false) {
                    let data = dataIn;
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (this._queuedData.length > 0 || !this._haveToken) {
                        return this.enqueueData(data, forceAllowEnqueue);
                    }
                    let remainder = null;
                    if (data.length > this._maxPayloadBytes) {
                        remainder = data.substr(this._maxPayloadBytes);
                        data = data.substr(0, this._maxPayloadBytes);
                        if (!this.allowEnqueue(remainder.length)) {
                            return this.enqueueFailNoSpace();
                        }
                    }
                    this._haveToken = false;
                    const transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 + this._smfDataTSHeaderParts[1].length + data.length;
                    this._httpSendConn.send(this._smfDataTSHeaderParts[0] + int32ToStr(transportPacketLen) + this._smfDataTSHeaderParts[1] + data);
                    this._clientstats.bytesWritten += data.length;
                    if (remainder) {
                        return this.enqueueData(remainder, null);
                    }
                    this._clientstats.msgWritten++;
                    return TransportReturnCode.OK;
                }
                enqueueData(data, forceAllowEnqueue = false) {
                    const dataLen = data.length;
                    if (forceAllowEnqueue || this.allowEnqueue(dataLen)) {
                        this._queuedDataSize += dataLen;
                        this._queuedData.push(data);
                    } else {
                        return this.enqueueFailNoSpace();
                    }
                    return TransportReturnCode.OK;
                }
                initPreformattedHeaders(sid) {
                    this._smfDataTSHeaderParts = SMFLib.Codec.Transport.genTsDataMsgHeaderParts(sid);
                    if (this._useStreamingTransport) {
                        this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataStreamTokenMsg(sid, this._streamingTransportPadding);
                    } else {
                        this._smfDataTokenTSHeader = SMFLib.Codec.Transport.genTsDataTokenMsg(sid);
                    }
                }
                flush(callback) {
                    if (this._queuedDataSize) {
                        this._flushCallback = callback;
                    } else {
                        callback();
                    }
                }
                sendQueuedData() {
                    if (this._queuedDataSize === 0) {
                        return;
                    }
                    this._haveToken = false;
                    const data = this.getQueuedDataToSend();
                    const transportPacketLen = this._smfDataTSHeaderParts[0].length + 4 + this._smfDataTSHeaderParts[1].length + data.length;
                    this._httpSendConn.send(this._smfDataTSHeaderParts[0] + int32ToStr(transportPacketLen) + this._smfDataTSHeaderParts[1] + data);
                    this._clientstats.bytesWritten += data.length;
                    if (this._canSendNeeded) {
                        this._canSendNeeded = false;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sid));
                    }
                    if (this._flushCallback) {
                        const cb = this._flushCallback;
                        this._flushCallback = null;
                        cb();
                    }
                }
                handleCreateResponse(tsRc, response) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY || this._state === TransportSessionState.DOWN) {
                        LOG_DEBUG("Received create response on a destroyed transport session, ignore");
                        return;
                    }
                    this.updateMaxWebPayload();
                    if (tsRc !== TransportReturnCode.OK) {
                        LOG_INFO(`Received create response with return code ${TransportReturnCode.describe(tsRc)}`);
                        if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
                            this.destroyCleanup("Received data decode error on create session response", ErrorSubcode.DATA_DECODE_ERROR);
                        } else {
                            this.destroyCleanup("Failed to handle create session response", ErrorSubcode.CONNECTION_ERROR);
                        }
                        return;
                    }
                    if (response.length === 0) {
                        return;
                    }
                    const parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(BufferImpl.from(response, "latin1"), 0);
                    if (!parsedResponse) {
                        LOG_ERROR("Could not parse create response as SMF. Destroying transport");
                        this.destroyCleanup("Failed to parse create response message", ErrorSubcode.CONNECTION_ERROR);
                        return;
                    }
                    const smfresponse = parsedResponse.getResponse();
                    if (smfresponse.responseCode !== 200) {
                        this.destroyCleanup(`Transport create request failed (${smfresponse.responseCode}, ${smfresponse.responseString})`, ErrorSubcode.CONNECTION_ERROR);
                        return;
                    }
                    this.cancelConnectTimeout();
                    this._createConn.abort();
                    this._createConn = null;
                    this._state = TransportSessionState.SESSION_UP;
                    this._sid = parsedResponse.sessionId;
                    this._routerTag = parsedResponse.routerTag;
                    this._routerUrl = this._createUrl.replace(/\?.*/, "");
                    if (this._routerTag !== "") {
                        this._routerUrl = this._routerUrl + this._routerTag;
                    }
                    this.initPreformattedHeaders(this._sid);
                    const useBase64 = !this._useBinaryTransport;
                    const useStreaming = this._useStreamingTransport;
                    this._httpSendConn = new HTTPConnection(this._routerUrl, useBase64, false, (rc, data) => this.handleRxDataToken(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType);
                    if (this._useStreamingTransport) {
                        this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming, (rc, data) => this.handleRxStreaming(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType, true);
                    } else {
                        this._rxChannelClient = new SMFClient(rxData => this.handleSmfMessage(rxData), rxError => this.handleSmfParseError(rxError), null);
                        this._httpReceiveConn = new HTTPConnection(this._routerUrl, useBase64, useStreaming, (rc, data) => this.handleRxData(rc, data), (rc, data) => this.handleSendFailure(rc, data), this._contentType);
                    }
                    this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, smfresponse.responseString, smfresponse.responseCode, 0, parsedResponse.sessionId));
                }
                handleDestroyResponse(response) {
                    LOG_DEBUG("Handle destroy response");
                    this.cancelDestroyTimeout();
                    const innerResponse = response.getResponse();
                    const responseString = innerResponse ? innerResponse.responseString : "";
                    this.destroyCleanup(`${responseString} handled Destroy Response addressed to session ${formatHexString(response.sessionId)}, on session ${formatHexString(this._sid)}`, 0);
                }
                handleSmfMessage(tsmsg) {
                    const smfHeader = tsmsg.smfHeader;
                    if (smfHeader.smf_protocol !== SMFLib.SMFProtocol.TSESSION) {
                        this.handleSmfParseError(`Unexpected Message Prototcol (${smfHeader.smf_protocol}) on ReceiveData connection`);
                        return;
                    }
                    const data = tsmsg.payload;
                    const TotalPayloadToRead = tsmsg.payloadLength;
                    switch (tsmsg.messageType) {
                      case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
                        this.handleDestroyResponse(tsmsg);
                        return;

                      case SMFLib.SMFTransportSessionMessageType.DATA:
                        if (tsmsg.sessionId !== this._sid) {
                            const smfErrResponse = tsmsg.getResponse();
                            const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                            const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                            LOG_DEBUG(`HandleRxData Bad Session ID received in message. Expected: ${strToByteArray(this._sid)}, Received: ${strToByteArray(tsmsg.sessionId)}${responseErrStr}`);
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in data message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(tsmsg.sessionId)}, ${responseErrStr}`, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                            return;
                        }
                        if (TotalPayloadToRead > 0) {
                            this._client.rxDataBuffer(data);
                        }
                        break;

                      default:
                        this.handleSmfParseError(`Unexpected message type (${tsmsg.messageType}) on ReceiveData connection`);
                    }
                }
                handleSmfParseError() {
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR, "Received data decode error", null, ErrorSubcode.DATA_DECODE_ERROR, this._sid));
                }
                handleRxData(tsRc, data) {
                    if (this._httpReceiveConn === null || this._rxChannelClient === null) {
                        if (this._state === TransportSessionState.DOWN) {
                            LOG_INFO("Transport session is down, ignore data from receive connection");
                        } else {
                            LOG_ERROR(`Transport session is not in working state, state: ${this._state}`);
                        }
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_DEBUG("Transport session is being destroyed, ignore data from receive connection, " + `dump first 64 bytes (or fewer) of data:\n${DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)}`);
                        return;
                    }
                    this._httpReceiveConn.recStat("GotData");
                    if (tsRc !== TransportReturnCode.OK) {
                        this.handleRxError(tsRc, data);
                        return;
                    }
                    if (data.length === 0) {
                        LOG_DEBUG("Send write token to router");
                        this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                    } else {
                        this._rxChannelClient.rxDataString(data);
                    }
                }
                handleRxStreaming(tsRc, data) {
                    if (this._httpReceiveConn === null) {
                        if (this._state === TransportSessionState.DOWN) {
                            LOG_DEBUG("Transport session is down, ignore data from receive connection");
                        } else {
                            LOG_ERROR(`Transport session is not in working state, state: ${this._state}`);
                        }
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_DEBUG("Transport session is being destroyed, ignore data from streaming receive " + `connection, dump first 64 bytes (or fewer) of data:\n${DebugLib.Debug.formatDumpBytes(data.substring(0, 64), true, 0)}`);
                        return;
                    }
                    this._httpReceiveConn.recStat("GotData");
                    if (tsRc !== TransportReturnCode.OK) {
                        this.handleRxError(tsRc, data);
                        return;
                    }
                    if (data.length === 0) {
                        LOG_TRACE("Send write token to router");
                        this._packetReadState = PacketReadState.READING_HEADER;
                        this._httpReceiveConn.send(this._smfDataTokenTSHeader);
                        return;
                    }
                    if (this._packetReadState === PacketReadState.STREAMING) {
                        this._client.rxDataString(data);
                        return;
                    }
                    this._incomingBuffer += data;
                    const smfheader = SMFLib.Codec.ParseSMF.parseSMFAt(BufferImpl.from(this._incomingBuffer, "latin1"), 0, true);
                    if (smfheader) {
                        const tsmsg = SMFLib.Codec.Transport.parseTsSmfHdrAt(BufferImpl.from(this._incomingBuffer, "latin1"), smfheader.headerLength, smfheader);
                        if (!tsmsg) {
                            return;
                        }
                        switch (tsmsg.messageType) {
                          case SMFLib.SMFTransportSessionMessageType.DESTROY_RESP:
                            this.handleDestroyResponse(tsmsg);
                            return;

                          case SMFLib.SMFTransportSessionMessageType.DATA:
                            if (tsmsg.sessionId !== this._sid) {
                                const smfErrResponse = tsmsg.getResponse();
                                const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                                const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                                LOG_DEBUG(`HandleRxData Bad Session ID received in message.  Expected: ${strToByteArray(this._sid)}, Received: ${strToByteArray(tsmsg.sessionId)}${responseErrStr}`);
                                LOG_DEBUG(`First 64 bytes (or fewer) of message: ${strToByteArray(data.substr(0, 64))}`);
                                this._state = TransportSessionState.CONNECTION_FAILED;
                                this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in data message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(tsmsg.sessionId)}, ${responseErrStr}`, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                                return;
                            }
                            this._packetReadState = PacketReadState.STREAMING;
                            if (this._incomingBuffer.length > smfheader.headerLength + tsmsg.tsHeaderLength) {
                                this._client.rxDataString(this._incomingBuffer.substr(smfheader.headerLength + tsmsg.tsHeaderLength));
                            }
                            this._incomingBuffer = "";
                            return;

                          default:
                            throw new TransportError(`Unexpected message type (${tsmsg.messageType}) on ReceiveData connection`, 0);
                        }
                    } else if (SMFLib.Codec.ParseSMF.isSMFHeaderAvailable(BufferImpl.from(this._incomingBuffer, "latin1"), 0) && !SMFLib.Codec.ParseSMF.isSMFHeaderValid(BufferImpl.from(this._incomingBuffer, "latin1"), 0)) {
                        LOG_ERROR(`Couldn't decode message due to invalid smf header, dump first 64 bytes (or fewer) of buffer content:\n${DebugLib.Debug.formatDumpBytes(this._incomingBuffer.substring(0, 64), true, 0)}`);
                        const errorInfo = "Error parsing incoming message - invalid SMF header detected";
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, errorInfo, null, ErrorSubcode.PROTOCOL_ERROR, null));
                    }
                }
                handleRxDataToken(tsRc, data) {
                    if (tsRc !== TransportReturnCode.OK) {
                        this.handleRxError(tsRc, data);
                        return;
                    }
                    if (data.length === 0) {
                        return;
                    }
                    const parsedResponse = SMFLib.Codec.Decode.decodeCompoundMessage(BufferImpl.from(data, "latin1"), 0);
                    if (!parsedResponse) {
                        if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, "Failed to parse received data message", null, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                        } else {
                            this.destroyCleanup("Failed to parse received data message", ErrorSubcode.PROTOCOL_ERROR);
                        }
                        return;
                    }
                    if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DESTROY_RESP) {
                        this.handleDestroyResponse(parsedResponse);
                        return;
                    }
                    if (parsedResponse.sessionId !== this._sid) {
                        const smfErrResponse = parsedResponse.getResponse();
                        const responseErrStr = smfErrResponse ? ` (${smfErrResponse.responseCode} ${smfErrResponse.responseString})` : "";
                        const responseCode = smfErrResponse ? smfErrResponse.responseCode : null;
                        LOG_DEBUG(`HandleRxDataToken Bad SID received in message.  Expected: ${strToByteArray(this._sid)}, Received: ${strToByteArray(parsedResponse.sessionId)}${responseErrStr}`);
                        LOG_DEBUG(`First 64 bytes (or fewer) of message: ${strToByteArray(data.substr(0, 64))}`);
                        if (this._state !== TransportSessionState.WAITING_FOR_DESTROY) {
                            this._state = TransportSessionState.CONNECTION_FAILED;
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.PARSE_FAILURE, `Session ID mismatch in response message, expected: ${formatHexString(this._sid)}, got: ${formatHexString(parsedResponse.sessionId)}, ${responseErrStr}`, responseCode, ErrorSubcode.PROTOCOL_ERROR, this._sid));
                        } else {
                            this.destroyCleanup("Session ID mismatch in response message", ErrorSubcode.PROTOCOL_ERROR);
                        }
                        return;
                    }
                    if (parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DATA_TOKEN || parsedResponse.messageType === SMFLib.SMFTransportSessionMessageType.DATA_STREAM_TOKEN) {
                        this._haveToken = true;
                        this._httpSendConn.recStat("GotToken");
                        this.sendQueuedData();
                    } else {
                        throw new TransportError(`Unexpected message type (${parsedResponse.messageType}) on SendData connection`, 0);
                    }
                }
                handleRxError(tsRc) {
                    LOG_INFO(`handleRxError, transport return code ${TransportReturnCode.name(tsRc)}`);
                    this._state = TransportSessionState.CONNECTION_FAILED;
                    if (tsRc === TransportReturnCode.DATA_DECODE_ERROR) {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DATA_DECODE_ERROR, "Received data decode error", null, ErrorSubcode.DATA_DECODE_ERROR, this._sid));
                    } else {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, "Connection error", ErrorSubcode.CONNECTION_ERROR, this._sid));
                    }
                }
                handleSendFailure(status, msg) {
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_INFO(`Connection destroy failure (${msg}) while in state ${this._state}`);
                        this.destroyCleanup(`Connection destroy failure: ${msg}`, ErrorSubcode.CONNECTION_ERROR);
                    } else {
                        LOG_INFO(`Connection failure (${msg}) while in state ${this._state}`);
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error: ${msg}`, status, ErrorSubcode.CONNECTION_ERROR, this._sid));
                    }
                }
                handleCreateConnFailure(status, msg) {
                    if (this._state === TransportSessionState.DOWN) {
                        return;
                    }
                    LOG_INFO(`Connection create failure (${msg}) while in state ${this._state}`);
                    this.destroyCleanup(`Connection create failure: ${msg}`, ErrorSubcode.CONNECTION_ERROR);
                }
                destroyTimerExpiry() {
                    this.destroyCleanup("Destroy request timeout", ErrorSubcode.CONNECTION_ERROR);
                }
                cancelDestroyTimeout() {
                    if (this._destroyTimer) {
                        clearTimeout(this._destroyTimer);
                        this._destroyTimer = null;
                    }
                }
                destroyCleanup(infoStr, subcode, asyncSendEvent) {
                    LOG_DEBUG(`Destroy cleanup: ${infoStr}`);
                    if (this._createConn) {
                        LOG_DEBUG("Destroy cleanup: Abort createConn");
                        this._createConn.abort();
                    }
                    if (this._httpSendConn) {
                        LOG_DEBUG("Destroy cleanup: Abort sendConn");
                        this._httpSendConn.abort();
                    }
                    if (this._httpReceiveConn) {
                        LOG_DEBUG("Destroy cleanup: Abort receiveConn");
                        this._httpReceiveConn.abort();
                    }
                    this._createUrl = null;
                    this._routerUrl = null;
                    this._createConn = null;
                    this._httpSendConn = null;
                    this._httpReceiveConn = null;
                    this._smfDataTokenTSHeader = null;
                    this._rxChannelClient = null;
                    this._routerTag = "";
                    this._queuedData = [];
                    this._queuedDataSize = 0;
                    this._canSendNeeded = false;
                    this.cancelDestroyTimeout();
                    this.cancelConnectTimeout();
                    this._state = TransportSessionState.DOWN;
                    const finalize = () => {
                        if (this._eventCB) {
                            this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, infoStr || "Session is destroyed", null, subcode || 0, this._sid));
                        }
                        this._client = null;
                        this._eventCB = null;
                    };
                    if (asyncSendEvent) {
                        setTimeout(finalize, 0);
                    } else {
                        finalize();
                    }
                }
                getInfoStr() {
                    const str = `HTTPTransportSession; sid=${formatHexString(this._sid)}; routerTag=${this._routerTag}`;
                    return str;
                }
            }
            module.exports.HTTPTransportSession = HTTPTransportSession;
        },
        "./modules/solclient-transport/lib/web/http/send-xhr.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Base64,
                Convert
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                XHRFactory
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/xhr-factory.js");
            const {
                encode: base64Encode
            } = Base64;
            const {
                stringToUint8Array
            } = Convert;
            function sendXhrBinaryMSIE10(xhr, data, contentType) {
                xhr.responseType = "arraybuffer";
                xhr.overrideMimeType(`${contentType}; charset=x-user-defined`);
                xhr.setRequestHeader("Content-Type", `${contentType}; charset=x-user-defined`);
                xhr.send(stringToUint8Array(data));
            }
            function sendXhrBinaryXHR2(xhr, data, contentType) {
                xhr.overrideMimeType(`${contentType}; charset=x-user-defined`);
                xhr.setRequestHeader("Content-Type", `${contentType}; charset=x-user-defined`);
                xhr.send(stringToUint8Array(data).buffer);
            }
            function sendXhrText(xhr, data, contentType, connClose) {
                xhr.setRequestHeader("Content-Type", `${contentType}; charset=x-user-defined`);
                xhr.send(data === null || data === undefined ? data : base64Encode(data), connClose);
            }
            const sendXhrBinary = (() => {
                if (typeof window !== "undefined" && window.Uint8Array && window.Blob) {
                    const xhr = XHRFactory.create(true);
                    if (xhr.responseType) {
                        return sendXhrBinaryMSIE10;
                    }
                    return sendXhrBinaryXHR2;
                }
                return sendXhrText;
            })();
            module.exports.sendXhrBinary = sendXhrBinary;
            module.exports.sendXhrText = sendXhrText;
        },
        "./modules/solclient-transport/lib/web/http/xhr-factory.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const XHRFactory = {
                create(allowFail = false) {
                    const xhr = typeof XMLHttpRequest !== "undefined" ? new XMLHttpRequest() : null;
                    if (!allowFail && !xhr) {
                        throw new TransportError("Failed to create an XMLHTTPRequest", ErrorSubcode.CREATE_XHR_FAILED);
                    }
                    return xhr;
                }
            };
            module.exports.XHRFactory = XHRFactory;
        },
        "./modules/solclient-transport/lib/web/state-base64.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TSHState
            } = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js");
            class StateBase64 extends TSHState {
                constructor(useSsl, exitCb, nextState) {
                    super(useSsl, TransportProtocol.HTTP_BASE64, exitCb, nextState);
                }
            }
            module.exports.StateBase64 = StateBase64;
        },
        "./modules/solclient-transport/lib/web/state-binary.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TSHState
            } = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js");
            const {
                WebTransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js");
            class StateBinary extends TSHState {
                constructor(useSsl, exitCb, nextState) {
                    super(useSsl, TransportProtocol.HTTP_BINARY, exitCb, nextState);
                }
                validateLegal() {
                    return WebTransportCapabilities.xhrBinary();
                }
            }
            module.exports.StateBinary = StateBinary;
        },
        "./modules/solclient-transport/lib/web/state-streaming-and-binary.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TSHState
            } = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js");
            const {
                WebTransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js");
            class StateStreamingAndBinary extends TSHState {
                constructor(useSsl, exitCb, nextState) {
                    super(useSsl, TransportProtocol.HTTP_BINARY_STREAMING, exitCb, nextState);
                }
                validateLegal() {
                    return WebTransportCapabilities.streaming() && WebTransportCapabilities.xhrBinary();
                }
            }
            module.exports.StateStreamingAndBinary = StateStreamingAndBinary;
        },
        "./modules/solclient-transport/lib/web/state-websocket-binary.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TSHState
            } = __webpack_require__("./modules/solclient-transport/lib/tsh-state.js");
            const {
                WebTransportCapabilities
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-capabilities.js");
            class StateWebSocketBinary extends TSHState {
                constructor(useSsl, exitCb, nextState) {
                    super(useSsl, TransportProtocol.WS_BINARY, exitCb, nextState);
                }
                validateLegal() {
                    return WebTransportCapabilities.webSocket();
                }
            }
            module.exports.StateWebSocketBinary = StateWebSocketBinary;
        },
        "./modules/solclient-transport/lib/web/web-transport-capabilities.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const HTTPLib = __webpack_require__("./modules/solclient-transport/lib/web/http/api.js");
            const {
                WebSocketTransportSession
            } = __webpack_require__("./modules/solclient-transport/lib/web/websocket-transport-session.js");
            const {
                HTTPConnection
            } = HTTPLib;
            const WebTransportCapabilities = {
                webSocket() {
                    return WebSocketTransportSession.browserSupportsBinaryWebSockets();
                },
                xhrBinary() {
                    return HTTPConnection.browserSupportsXhrBinary();
                },
                streaming() {
                    return HTTPConnection.browserSupportsStreamingResponse();
                }
            };
            module.exports.WebTransportCapabilities = WebTransportCapabilities;
        },
        "./modules/solclient-transport/lib/web/web-transport-events.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const WebTransportEvent = {
                CONNECT: "Connect",
                DESTROY: "Destroy",
                DOWNGRADE: "Downgrade",
                DESTROYED_NOTICE: "DestroyedNotice",
                CONNECT_TIMEOUT: "ConnectTimeout",
                UP_NOTICE: "UpNotice",
                SEND_ERROR: "SendError"
            };
            module.exports.WebTransportEvent = Enum.new(WebTransportEvent);
        },
        "./modules/solclient-transport/lib/web/web-transport-fsm.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                FsmEvent,
                State,
                StateMachine
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            const {
                LogFormatter
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                WebTransportEvent
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-events.js");
            const {
                WebTransportState
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-states.js");
            const {
                LOG_TRACE,
                LOG_INFO
            } = new LogFormatter();
            class WebTransportFSM extends StateMachine {
                constructor(transportIn, getId) {
                    super({
                        name: "WebTransportFSM"
                    });
                    const transport = transportIn;
                    const fsm = this;
                    const logger = new LogFormatter();
                    logger.formatter = function logFormatter(...args) {
                        return [ `[web-transport-fsm=${getId()}]`, ...args ];
                    };
                    this.log = logger.wrap(this.log, this);
                    this.transport = transport;
                    this.initial(function onInitial() {
                        return this.transitionTo(this.WebTransportDown, context => {
                            LOG_TRACE(`Starting ${context.getStateMachine().getName()}`);
                        });
                    });
                    this.unhandledEventReaction(function onUnhandledEvent(wEvent) {
                        LOG_TRACE(`Ignoring event ${wEvent.getName()} in state ${this.getCurrentState().getName()}`);
                        return this;
                    });
                    this.WebTransportDown = new State({
                        name: WebTransportState.DOWN,
                        parentContext: this
                    }).reaction(WebTransportEvent.CONNECT, function onConnect() {
                        return this.transitionTo(fsm.WebTransportConnecting);
                    }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                        return this.transitionTo(fsm.WebTransportDestroying);
                    });
                    this.WebTransportConnecting = new State({
                        name: WebTransportState.CONNECTING,
                        parentContext: this
                    }).entry(() => {
                        try {
                            const rc = transport.connectInternal();
                            if (rc !== TransportReturnCode.OK) {
                                const connError = transport.getConnError();
                                const wEvent = new FsmEvent({
                                    name: WebTransportEvent.DESTROY
                                });
                                wEvent._destroyMsg = connError ? connError.message : "Error occurred while establishing transport";
                                wEvent._subcode = connError ? connError.subcode : null;
                                wEvent._eventReason = connError;
                                return this.processEvent(wEvent);
                            }
                        } catch (e) {
                            LOG_INFO(`transport.connectInternal threw: ${e.message}`);
                            const wEvent = new FsmEvent({
                                name: WebTransportEvent.DESTROY
                            });
                            wEvent._destroyMsg = e.message;
                            wEvent._subcode = e.subcode ? e.subcode : ErrorSubcode.CONNECTION_ERROR;
                            wEvent._eventReason = e;
                            return this.processEvent(wEvent);
                        }
                        return undefined;
                    }).reaction(WebTransportEvent.SEND_ERROR, wEvent => {
                        transport.notifyEvent(wEvent._transportEvent);
                        return fsm.attemptDowngrade(wEvent._transportEvent);
                    }).reaction(WebTransportEvent.CONNECT_TIMEOUT, e => fsm.attemptDowngrade(e._transportEvent)).reaction(WebTransportEvent.DESTROYED_NOTICE, wEvent => {
                        transport.notifyEvent(wEvent._transportEvent);
                        return this.transitionTo(fsm.WebTransportDown);
                    }).reaction(WebTransportEvent.UP_NOTICE, function onUpNotice(wEvent) {
                        transport.notifyEvent(wEvent._transportEvent);
                        return this.transitionTo(fsm.WebTransportUp);
                    }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                        return this.transitionTo(fsm.WebTransportDestroying);
                    });
                    this.WebTransportDowngrading = new State({
                        name: WebTransportState.DOWNGRADING,
                        parentContext: this
                    }).reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
                        LOG_INFO("Web transport: request downgrade");
                        if (!transport.completeDowngrade()) {
                            LOG_INFO("Web transport: connection error, no downgrade");
                            transport.notifyEvent(wEvent._transportEvent);
                            fsm.notifyDowngradeFailed();
                            return this.transitionTo(fsm.WebTransportDown);
                        }
                        return this.transitionTo(fsm.WebTransportConnecting);
                    }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                        return this.transitionTo(fsm.WebTransportDestroying);
                    });
                    this.WebTransportUp = new State({
                        name: WebTransportState.UP,
                        parentContext: this
                    }).reaction(WebTransportEvent.DOWNGRADE, wEvent => fsm.attemptDowngrade(new TransportSessionEvent(wEvent._downgradeMsg, wEvent._subcode))).reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
                        transport.notifyEvent(wEvent._transportEvent);
                        return this.transitionTo(fsm.WebTransportDown);
                    }).reaction(WebTransportEvent.DESTROY, function onDestroy(wEvent) {
                        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                        return this.transitionTo(fsm.WebTransportDestroying);
                    }).reaction(WebTransportEvent.SEND_ERROR, function onUpNotice(wEvent) {
                        transport.notifyEvent(wEvent._transportEvent);
                        transport.destroyInternal(wEvent._destroyMsg, wEvent._subcode);
                        return this.transitionTo(fsm.WebTransportDestroying);
                    });
                    this.WebTransportDestroying = new State({
                        name: WebTransportState.DESTROYING,
                        parentContext: this
                    }).reaction(WebTransportEvent.DESTROYED_NOTICE, function onDestroyed(wEvent) {
                        transport.notifyEvent(wEvent._transportEvent);
                        return this.transitionTo(fsm.WebTransportDown);
                    });
                }
                attemptDowngrade(tsEvent) {
                    const {
                        infoStr,
                        errorSubcode
                    } = tsEvent;
                    if (!this.transport.beginDowngrade(infoStr, errorSubcode)) {
                        LOG_TRACE("Downgrade unavailable");
                        this.transport.destroyInternal(infoStr, errorSubcode);
                        this.transport.notifyEvent(tsEvent);
                        return this.transitionTo(this.WebTransportDestroying);
                    }
                    LOG_TRACE("Downgrade available");
                    return this.transitionTo(this.WebTransportDowngrading);
                }
                notifyDowngradeFailed() {
                    LOG_TRACE("Notifying of downgrade failure");
                    this.transport.notifyEvent(new TransportSessionEvent(TransportSessionEventCode.DOWNGRADE_FAILED, "Downgrade failed"));
                }
            }
            module.exports.WebTransportFSM = WebTransportFSM;
        },
        "./modules/solclient-transport/lib/web/web-transport-session-base.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LOG_DEBUG,
                LOG_TRACE
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportClientStats
            } = __webpack_require__("./modules/solclient-transport/lib/transport-client-stats.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const MAX_BUFFERED_AMOUNT_QUERY_INTERVAL_MS = 4e3;
            class WebTransportSessionBase extends TransportBase {
                constructor(url, eventCB, client, props) {
                    super(url, eventCB, client, props);
                    this._connectTimeout = props.transportDowngradeTimeoutInMsecs;
                    this._connectTimer = null;
                    this._clientstats = new TransportClientStats();
                    this._sendBufferMaxSize = props.sendBufferMaxSize;
                    this._maxPayloadBytes = props.maxWebPayload;
                    this._queuedData = [];
                    this._queuedDataSize = 0;
                    this._canSendNeeded = false;
                    this._state = TransportSessionState.DOWN;
                    this._connError = null;
                }
                getClientStats() {
                    return this._clientstats;
                }
                createConnectTimeout() {
                    if (this._connectTimeout > 0) {
                        this._connectTimer = setTimeout(() => {
                            this.connectTimerExpiry();
                        }, this._connectTimeout);
                    }
                }
                cancelConnectTimeout() {
                    if (this._connectTimer) {
                        clearTimeout(this._connectTimer);
                        this._connectTimer = null;
                    }
                }
                connectTimerExpiry() {
                    return undefined;
                }
                allowEnqueue(datalen) {
                    return this._queuedDataSize === 0 || datalen + this._queuedDataSize <= this._sendBufferMaxSize;
                }
                enqueueFailNoSpace() {
                    this._canSendNeeded = true;
                    return TransportReturnCode.NO_SPACE;
                }
                flush(callback) {
                    callback();
                }
                getQueuedDataToSend() {
                    let data = "";
                    let bytesAllowed = this._maxPayloadBytes;
                    LOG_TRACE(`getQueuedDataToSend: bytesAllowed=${bytesAllowed}, bufferedAmount=${this.getBufferedAmount ? this.getBufferedAmount() : "undefined"}`);
                    if (this.getBufferedAmount) {
                        bytesAllowed = this._maxPayloadBytes - this.getBufferedAmount();
                        if (bytesAllowed <= 0) {
                            LOG_DEBUG(`$$ bytesAllowed=${bytesAllowed}, maxPayloadBytes=${this._maxPayloadBytes}, bufferedAmount=${this.getBufferedAmount()}`);
                            if (false) {}
                            return data;
                        }
                        if (false) {}
                    }
                    if (this._queuedDataSize > bytesAllowed) {
                        let payloadSize = bytesAllowed;
                        while (payloadSize && this._queuedDataSize) {
                            const elem = this._queuedData[0];
                            const elemLength = elem.length;
                            if (elemLength > payloadSize) {
                                data += elem.substr(0, payloadSize);
                                this._queuedData[0] = elem.substr(payloadSize);
                                this._queuedDataSize -= payloadSize;
                                payloadSize = 0;
                            } else {
                                data += this._queuedData.shift();
                                payloadSize -= elemLength;
                                this._queuedDataSize -= elemLength;
                                this._clientstats.msgWritten++;
                            }
                        }
                    } else {
                        data = this._queuedData.join("");
                        this._clientstats.msgWritten += this._queuedData.length;
                        this._queuedData = [];
                        this._queuedDataSize = 0;
                    }
                    LOG_DEBUG(`Sending ${data.length} bytes from queued data`);
                    return data;
                }
            }
            module.exports.WebTransportSessionBase = WebTransportSessionBase;
        },
        "./modules/solclient-transport/lib/web/web-transport-states.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Enum
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const WebTransportState = {
                DOWN: "WebTransportDown",
                CONNECTING: "WebTransportConnecting",
                DOWNGRADING: "WebTransportDowngrading",
                DESTROYING: "WebTransportDestroying",
                UP: "WebTransportUp"
            };
            module.exports.WebTransportState = Enum.new(WebTransportState);
        },
        "./modules/solclient-transport/lib/web/web-transport.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                HTTPTransportSession
            } = __webpack_require__("./modules/solclient-transport/lib/web/http/api.js");
            const {
                LOG_TRACE,
                LOG_INFO,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                FsmEvent
            } = __webpack_require__("./modules/solclient-fsm/api.js");
            const {
                TransportBase
            } = __webpack_require__("./modules/solclient-transport/lib/transport-base.js");
            const {
                TransportProtocol
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocols.js");
            const {
                TransportProtocolHandler
            } = __webpack_require__("./modules/solclient-transport/lib/transport-protocol-handler.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                WebSocketTransportSession
            } = __webpack_require__("./modules/solclient-transport/lib/web/websocket-transport-session.js");
            const {
                WebTransportEvent
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-events.js");
            const {
                WebTransportFSM
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-fsm.js");
            class WebTransport extends TransportBase {
                constructor(url, eventCB, client, props, getId) {
                    super(url, eventCB, client, props);
                    LOG_TRACE(`webTransportProtocolList ${props.webTransportProtocolList}`);
                    this._transportHandler = new TransportProtocolHandler(url, props.webTransportProtocolList);
                    this._webTransportFsm = new WebTransportFSM(this, getId);
                    this._webTransportFsm.start();
                }
                notifyEvent(event) {
                    this._eventCB(event);
                }
                handleDestroyed() {
                    this._transportSession = null;
                }
                handleTransportEvent(transportEvent) {
                    LOG_INFO(`Web transport receive transport event: ${transportEvent}`);
                    let wEvent;
                    switch (transportEvent.getTransportEventCode()) {
                      case TransportSessionEventCode.UP_NOTICE:
                        wEvent = new FsmEvent({
                            name: WebTransportEvent.UP_NOTICE
                        });
                        wEvent._transportEvent = transportEvent;
                        this._webTransportFsm.processEvent(wEvent);
                        break;

                      case TransportSessionEventCode.DESTROYED_NOTICE:
                        this.handleDestroyed();
                        wEvent = new FsmEvent({
                            name: WebTransportEvent.DESTROYED_NOTICE
                        });
                        wEvent._transportEvent = transportEvent;
                        this._webTransportFsm.processEvent(wEvent);
                        break;

                      case TransportSessionEventCode.SEND_ERROR:
                        wEvent = new FsmEvent({
                            name: WebTransportEvent.SEND_ERROR
                        });
                        wEvent._transportEvent = transportEvent;
                        this._webTransportFsm.processEvent(wEvent);
                        break;

                      case TransportSessionEventCode.CONNECT_TIMEOUT:
                        wEvent = new FsmEvent({
                            name: WebTransportEvent.CONNECT_TIMEOUT
                        });
                        wEvent._transportEvent = transportEvent;
                        this._webTransportFsm.processEvent(wEvent);
                        break;

                      case TransportSessionEventCode.DOWNGRADE_FAILED:
                        this._lastDowngradeSucceeded = false;
                        break;

                      case TransportSessionEventCode.DOWNGRADE_SUCCEEDED:
                        this._lastDowngradeSucceeded = true;
                        break;

                      default:
                        this._eventCB(transportEvent);
                    }
                }
                connect() {
                    const wEvent = new FsmEvent({
                        name: WebTransportEvent.CONNECT
                    });
                    this._webTransportFsm.processEvent(wEvent);
                    return TransportReturnCode.OK;
                }
                connectInternal() {
                    this._transportSession = null;
                    const tpProtocol = this._transportHandler.getTransportProtocol();
                    this._props.transportProtocol = tpProtocol;
                    switch (tpProtocol) {
                      case TransportProtocol.HTTP_BASE64:
                      case TransportProtocol.HTTP_BINARY:
                      case TransportProtocol.HTTP_BINARY_STREAMING:
                        this._transportSession = new HTTPTransportSession(this._url, evt => this.handleTransportEvent(evt), this._client, this._props);
                        break;

                      case TransportProtocol.WS_BINARY:
                        this._transportSession = new WebSocketTransportSession(this._url, evt => this.handleTransportEvent(evt), this._client, this._props);
                        break;

                      default:
                        LOG_ERROR(`Web transport unrecognized TransportProtocol: ${tpProtocol}`);
                        throw new OperationError(`No transport session provider for scheme: ${tpProtocol}`, ErrorSubcode.CONNECTION_ERROR, tpProtocol);
                    }
                    LOG_INFO(`Connect Transport ${tpProtocol}`);
                    return this._transportSession.connect();
                }
                destroy(msg, subcode) {
                    const wEvent = new FsmEvent({
                        name: WebTransportEvent.DESTROY
                    });
                    wEvent._destroyMsg = msg;
                    wEvent._subcode = subcode;
                    this._webTransportFsm.processEvent(wEvent);
                    return TransportReturnCode.OK;
                }
                beginDowngrade(msg, subcode) {
                    if (this._transportHandler.canCompleteDowngrade()) {
                        LOG_TRACE("Web transport downgrade");
                        this.destroyInternal(msg, subcode);
                        return true;
                    }
                    LOG_TRACE("Web transport downgrade rejected");
                    return false;
                }
                completeDowngrade() {
                    if (!this._transportHandler.canCompleteDowngrade()) {
                        return false;
                    }
                    return this._transportHandler.completeDowngrade();
                }
                destroyInternal(msg, subcode) {
                    if (this._transportSession) {
                        this._transportSession.destroy(msg, subcode);
                    }
                }
                flush(callback) {
                    return this._transportSession.flush(callback);
                }
                getConnError() {
                    if (this._transportSession) {
                        return this._transportSession._connError;
                    }
                    return null;
                }
                getInfoStr() {
                    if (this._transportSession) {
                        return this._transportSession.getInfoStr();
                    }
                    return "Not connected.";
                }
                getTransportProtocol() {
                    return this._transportHandler.getTransportProtocol();
                }
                getClientStats() {
                    if (this._transportSession) {
                        return this._transportSession.getClientStats();
                    }
                    return null;
                }
                requestDowngrade(msg, subcode) {
                    LOG_TRACE("Creating downgrade request event");
                    this._lastDowngradeSucceeded = undefined;
                    const wEvent = new FsmEvent({
                        name: WebTransportEvent.DOWNGRADE
                    });
                    wEvent._downgradeMsg = msg;
                    wEvent._subcode = subcode;
                    this._webTransportFsm.processEvent(wEvent);
                    return this._lastDowngradeSucceeded;
                }
                send(message, forceAllowEnqueue) {
                    return this._transportSession.send(message, forceAllowEnqueue);
                }
            }
            module.exports.WebTransport = WebTransport;
        },
        "./modules/solclient-transport/lib/web/websocket-close-codes.js": module => {
            module.exports.WebSocketCloseCodes = {
                0: {
                    name: "Unknown code",
                    description: "No status code was returned by the operation"
                },
                1e3: {
                    name: "Normal Closure",
                    description: "The connection closed normally"
                },
                1001: {
                    name: "Going Away",
                    description: "The endpoint is going away due to a server failure or client navigation"
                },
                1002: {
                    name: "Protocol Error",
                    description: "A WebSocket protocol error occurred"
                },
                1003: {
                    name: "Unsupported Data",
                    description: "The endpoint cannot handle the specified data type"
                },
                1004: {
                    name: "Reserved",
                    description: ""
                },
                1005: {
                    name: "No Status Recvd",
                    description: "Expected a status code but none was provided"
                },
                1006: {
                    name: "Abnormal Closure",
                    description: "No close frame was received before remote hangup"
                },
                1007: {
                    name: "Invalid Frame Payload Data",
                    description: "A message contained data inconsistent with its encoding"
                },
                1008: {
                    name: "Policy Violation",
                    description: "A message violated endpoint policy"
                },
                1009: {
                    name: "Message Too Big",
                    description: "A data frame was too large"
                },
                1010: {
                    name: "Missing Extension",
                    description: "The endpoint did not negotiate an expected extension"
                },
                1011: {
                    name: "Internal Error",
                    description: "The server encountered an unexpected condition that prevented it from fulfilling the request"
                },
                1012: {
                    name: "Service Restart",
                    description: "The server is restarting"
                },
                1013: {
                    name: "Try Again Later",
                    description: "The server is terminating the connection due to a temporary condition"
                },
                1014: {
                    name: "Bad Gateway",
                    description: "A gateway or proxy received an invalid response from the upstream server"
                },
                1015: {
                    name: "TLS Handshake",
                    description: "The connection was closed due to a failure to perform a TLS handshake"
                }
            };
        },
        "./modules/solclient-transport/lib/web/websocket-transport-session.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                LOG_TRACE,
                LOG_DEBUG,
                LOG_INFO,
                LOG_WARN,
                LOG_ERROR
            } = __webpack_require__("./modules/solclient-log/api.js");
            const {
                ArrayUtils
            } = __webpack_require__("./modules/solclient-util/api.js");
            const {
                Convert,
                Hex
            } = __webpack_require__("./modules/solclient-convert/api.js");
            const {
                ErrorSubcode
            } = __webpack_require__("./modules/solclient-error/api.js");
            const {
                mixin
            } = __webpack_require__("./modules/solclient-eskit/api.js");
            const {
                TransportError
            } = __webpack_require__("./modules/solclient-transport/lib/transport-error.js");
            const {
                TransportReturnCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-return-codes.js");
            const {
                TransportSessionEvent
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event.js");
            const {
                TransportSessionEventCode
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-event-codes.js");
            const {
                TransportSessionState
            } = __webpack_require__("./modules/solclient-transport/lib/transport-session-states.js");
            const {
                WebSocketCloseCodes
            } = __webpack_require__("./modules/solclient-transport/lib/web/websocket-close-codes.js");
            const {
                WebTransportSessionBase
            } = __webpack_require__("./modules/solclient-transport/lib/web/web-transport-session-base.js");
            const http = __webpack_require__("http");
            const https = __webpack_require__("https");
            const {
                stringToArrayBuffer
            } = Convert;
            const {
                formatHexString
            } = Hex;
            const {
                includes
            } = ArrayUtils;
            const globalContext = typeof window === "undefined" ? global : window;
            let MyWebSocket = globalContext.WebSocket;
            if (true) {
                MyWebSocket = __webpack_require__("./node_modules/ws/index.js");
            }
            function adaptURL(url) {
                const v = url.match(/(ws|http)(s?:\/\/.+)/);
                return `ws${v[2]}`;
            }
            class WebSocketTransportSession extends WebTransportSessionBase {
                constructor(url, eventCB, client, props) {
                    super(url, eventCB, client, props);
                    this._url = adaptURL(url);
                    this._socket = null;
                    this._sessionId = new Date().getTime();
                    if (false) {}
                }
                onOpen() {
                    this.cancelConnectTimeout();
                    this._state = TransportSessionState.SESSION_UP;
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.UP_NOTICE, "Connected", 0, null, this._sessionId));
                }
                onClose(originalSocket, event) {
                    if (originalSocket !== this._socket) {
                        LOG_DEBUG("Websocket Transport Session stray onClose for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_TRACE("WebSocket transport is being destroyed, ignore error");
                        return;
                    }
                    const msgBuf = [];
                    const code = WebSocketCloseCodes[event.code] || WebSocketCloseCodes[0];
                    msgBuf.push(`${event.code} ${code.name} (${code.description})`);
                    if (event.wasClean !== undefined) {
                        msgBuf.push(`clean closure: ${event.wasClean}`);
                    }
                    if (event.reason) {
                        msgBuf.push(`reason: ${event.reason}`);
                    }
                    const msg = msgBuf.join(", ");
                    LOG_DEBUG(`WebSocket transport connection is closed ${msg}`);
                    LOG_TRACE(`Event { type: ${event.type} wasClean: ${event.wasClean} code: ${event.code} reason: ${event.reason} }`);
                    this._state = TransportSessionState.CONNECTION_FAILED;
                    this.destroy(`Connection closed: ${msg}`, ErrorSubcode.COMMUNICATION_ERROR);
                }
                onDrain() {
                    LOG_TRACE("Drained socket");
                    this.maybeEmitCanSend();
                    this.maybeEmitFlush();
                }
                onBufferedAmountPoll() {
                    if (this.getBufferedAmount() === 0) {
                        this.onDrain();
                    } else if (this.scheduleQuery) {
                        this.scheduleQuery();
                    }
                }
                onError(originalSocket, event) {
                    LOG_INFO(`Websocket Transport Session onError for socket ${originalSocket} while socket is ${this._socket}`);
                    if (originalSocket !== this._socket) {
                        LOG_INFO("Websocket Transport Session stray onError for previous socket, ignoring.");
                        return;
                    }
                    if (this._state === TransportSessionState.WAITING_FOR_DESTROY) {
                        LOG_INFO("WebSocket transport is being destroyed, ignore error");
                        return;
                    }
                    const msg = event.message ? `: ${event.message}` : "";
                    LOG_INFO(`WebSocket transport connection error ${msg} while in state ${this._state}`);
                    if (this._state === TransportSessionState.WAITING_FOR_CONNECT) {
                        this.cancelConnectTimeout();
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        this.destroy(`Connection failed: ${msg}`, ErrorSubcode.CONNECTION_ERROR);
                    } else {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.SEND_ERROR, `Connection error${msg}`, null, ErrorSubcode.CONNECTION_ERROR, null));
                    }
                }
                onMessage(event) {
                    if (this._client) {
                        this._client.rxDataArrayBuffer(event.data);
                    }
                }
                connectTimerExpiry() {
                    LOG_INFO("WebSocket transport connect timeout");
                    this.state = TransportSessionState.CONNECTION_FAILED;
                    this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CONNECT_TIMEOUT, "Connection timed out", null, ErrorSubcode.TIMEOUT));
                }
                connect() {
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_ERROR(`Invalid state for operation: ${TransportSessionState.nameOf(this._state)}`);
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    if (!this._url) {
                        LOG_WARN("Cannot connect to null URL");
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    if (this._socket) {
                        this.onError("Socket already connected");
                    }
                    LOG_INFO("Establishing WebSocket transport session");
                    try {
                        this.createConnectTimeout();
                        this._state = TransportSessionState.WAITING_FOR_CREATE;
                        if (true && !this._socketOptions) {
                            LOG_DEBUG("Creating Node websocket options");
                            this._socketOptions = this.createWebSocketOptions(this.onDrain.bind(this));
                        }
                        LOG_INFO("Constructing socket");
                        if (false) {} else {
                            this._socket = new MyWebSocket(this._url, "smf.solacesystems.com", this._socketOptions);
                            this._socket.ondrain = this.onDrain.bind(this);
                        }
                        LOG_TRACE("Assigning properties to socket");
                        this._socket.binaryType = "arraybuffer";
                        this._socket.onopen = this.onOpen.bind(this);
                        this._socket.onmessage = this.onMessage.bind(this);
                        this._socket.onclose = this.onClose.bind(this, this._socket);
                        this._socket.onerror = this.onError.bind(this, this._socket);
                        LOG_TRACE("Prepared socket");
                    } catch (error) {
                        LOG_INFO(`Error connecting: ${error.message}`);
                        LOG_TRACE("Error details", error.stack || error);
                        this._state = TransportSessionState.CONNECTION_FAILED;
                        this.cancelConnectTimeout();
                        if (error instanceof TransportError) {
                            this._connError = error;
                        } else {
                            throw new TransportError(`Could not create WebSocket: ${error.message}`, error.subcode || ErrorSubcode.CONNECTION_ERROR);
                        }
                        return TransportReturnCode.CONNECTION_ERROR;
                    }
                    LOG_INFO("WebSocket is connecting");
                    return TransportReturnCode.OK;
                }
                send(data, force = false) {
                    if (this._state !== TransportSessionState.SESSION_UP) {
                        return TransportReturnCode.INVALID_STATE_FOR_OPERATION;
                    }
                    const dataLen = data.length;
                    const bufferAllow = this._sendBufferMaxSize - this.getBufferedAmount() >= 0;
                    if (!(force || bufferAllow)) {
                        this._canSendNeeded = true;
                        if (this.scheduleQuery) this.scheduleQuery();
                        return TransportReturnCode.NO_SPACE;
                    }
                    const maxPayloadBytes = this._maxPayloadBytes;
                    const ab = stringToArrayBuffer(data);
                    if (dataLen > maxPayloadBytes) {
                        for (let i = 0; i < dataLen; i += maxPayloadBytes) {
                            this._socket.send(ab.slice(i, i + maxPayloadBytes));
                        }
                    } else {
                        this._socket.send(ab);
                    }
                    this._clientstats.bytesWritten += dataLen;
                    ++this._clientstats.msgWritten;
                    return TransportReturnCode.OK;
                }
                getBufferedAmount() {
                    return this._socket ? this._socket["bufferedAmount"] : 0;
                }
                flush(callback) {
                    this._flushCallback = callback;
                    this.maybeEmitFlush();
                }
                maybeEmitCanSend() {
                    if (this._canSendNeeded && this.getBufferedAmount() < this._sendBufferMaxSize) {
                        LOG_TRACE("Transport emitting CAN_ACCEPT_DATA");
                        this._canSendNeeded = false;
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.CAN_ACCEPT_DATA, "", null, 0, this._sessionId));
                    }
                }
                maybeEmitFlush() {
                    if (!this._flushCallback) return;
                    if (false) {}
                    LOG_DEBUG("Transport emitting FLUSH");
                    const cb = this._flushCallback;
                    this._flushCallback = null;
                    cb();
                }
                destroy(message, subcode) {
                    if (this._state !== TransportSessionState.DOWN) {
                        LOG_INFO(`Destroy WebSocket transport: ${message}`);
                        this._state = TransportSessionState.WAITING_FOR_DESTROY;
                        if (this._socket) {
                            this._socket.close();
                            this._socket.onopen = null;
                            this._socket.onmessage = null;
                            this._socket.onclose = null;
                            this._socket.onerror = function onerrorStub() {};
                            this._socket = null;
                        }
                        if (this._connectTimer) {
                            clearTimeout(this._connectTimer);
                            this._connectTimer = undefined;
                        }
                        if (false) {}
                        this._canSendNeeded = false;
                        this._state = TransportSessionState.DOWN;
                        this._client = null;
                    }
                    if (this._eventCB) {
                        this._eventCB(new TransportSessionEvent(TransportSessionEventCode.DESTROYED_NOTICE, message || "Session is destroyed", null, subcode || 0, this._sessionId));
                        this._eventCB = null;
                    }
                    return TransportReturnCode.OK;
                }
                getInfoStr() {
                    const str = `WebSocketTransportSession; sid=${formatHexString(this._sessionId)}`;
                    return str;
                }
                static browserSupportsBinaryWebSockets() {
                    LOG_DEBUG("websocket browserSupportBinaryCheck - " + "if WebSocket, ArrayBuffer and Uint8Array are supported");
                    const exists = [ "function", "object" ];
                    if (!includes(exists, typeof MyWebSocket) || !includes(exists, typeof ArrayBuffer) || !includes(exists, typeof Uint8Array)) {
                        LOG_INFO("websocket browserSupportBinaryCheck: false - some required classes not supported");
                        return false;
                    }
                    LOG_DEBUG("websocket browserSupportBinaryCheck - if WebSocket supports binaryType");
                    if ("binaryType" in MyWebSocket.prototype) {
                        LOG_INFO("websocket browserSupportBinaryCheck: true - WebSocket supports binaryType");
                        return true;
                    }
                    LOG_INFO("websocket browserSupportBinaryCheck: false - WebSocket does not support binaryType");
                    return false;
                }
            }
            if (false) {} else {
                const {
                    NodeTLSOptsMixin
                } = __webpack_require__("./modules/solclient-transport/lib/node-tls-opts-mixin.js");
                mixin(WebTransportSessionBase, NodeTLSOptsMixin);
                mixin(WebTransportSessionBase, class WebTransportSessionBaseNode {
                    createWebSocketOptions(onDrainCallback) {
                        let options = {};
                        if (this._ssl) {
                            options = this.createTLSOptions();
                            options["agent"] = new https.Agent({
                                keepAlive: false
                            });
                        } else {
                            options["agent"] = new http.Agent();
                        }
                        const wsAgent = options["agent"];
                        const origCreateConnection = wsAgent.createConnection;
                        wsAgent.createConnection = function newCreateConnection(opts, callback) {
                            const socket = origCreateConnection.call(this, opts, callback);
                            socket.on("drain", onDrainCallback);
                            return socket;
                        };
                        LOG_DEBUG("WebSocket options", options);
                        return options;
                    }
                });
            }
            module.exports.WebSocketTransportSession = WebSocketTransportSession;
        },
        "./modules/solclient-util/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                APIProperties
            } = __webpack_require__("./modules/solclient-util/lib/api-properties.js");
            const {
                APIPropertiesValidators
            } = __webpack_require__("./modules/solclient-util/lib/api-properties-validators.js");
            const {
                ArrayUtils
            } = __webpack_require__("./modules/solclient-util/lib/array-utils.js");
            const {
                parseURL
            } = __webpack_require__("./modules/solclient-util/lib/url.js");
            const {
                Process
            } = __webpack_require__("./modules/solclient-util/lib/process.js");
            const {
                StringBuffer
            } = __webpack_require__("./modules/solclient-util/lib/string-buffer.js");
            const {
                StringUtils
            } = __webpack_require__("./modules/solclient-util/lib/string-utils.js");
            const {
                TimingBucket
            } = __webpack_require__("./modules/solclient-util/lib/timing-bucket.js");
            const {
                UUID
            } = __webpack_require__("./modules/solclient-util/lib/uuid.js");
            const {
                Version
            } = __webpack_require__("./modules/solclient-util/lib/version.js");
            module.exports = {
                parseURL: parseURL,
                APIProperties: APIProperties,
                APIPropertiesValidators: APIPropertiesValidators,
                ArrayUtils: ArrayUtils,
                Process: Process,
                StringBuffer: StringBuffer,
                StringUtils: StringUtils,
                TimingBucket: TimingBucket,
                UUID: UUID,
                Version: Version
            };
        },
        "./modules/solclient-util/lib/api-properties-validators.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/api.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const APIPropertiesValidators = {
                validateInstance(typeDesc, instance, name, ...args) {
                    args.forEach(check => {
                        const validator = check.shift();
                        const validatorArgs = [ typeDesc, instance, name, ...check ];
                        validator(...validatorArgs);
                    });
                },
                valInstance(typeDesc, instance, name, typeInstance, typeInstanceDesc) {
                    if (!Check.instanceOf(instance[name], typeInstance)) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be instance of ${typeInstanceDesc}`);
                    }
                },
                valNotEmpty(typeDesc, instance, name) {
                    if (Check.none(instance[name]) || instance[name] === "") {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' cannot be empty.`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                },
                valLength(typeDesc, instance, name, max) {
                    if (Check.string(instance[name]) && instance[name].length > max) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' exceeded max length ${max}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                },
                valRange(typeDesc, instance, name, min, max) {
                    if (Check.number(instance[name]) && (instance[name] < min || instance[name] > max)) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' out of range [${min}; ${max}].`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                },
                valString(typeDesc, instance, name) {
                    if (!Check.string(instance[name])) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be type string; was ${typeof instance[name]}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                },
                valNumber(typeDesc, instance, name) {
                    if (!Check.number(instance[name])) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be type number; was ${typeof instance[name]}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                },
                valBoolean(typeDesc, instance, name) {
                    const val = instance[name];
                    if (!Check.boolean(val)) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be type boolean; was ${typeof val}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                },
                valIsMember(typeDesc, instance, key, enumInstance, enumName, allowNull = false) {
                    const val = instance[key];
                    if (allowNull && (val === null || val === undefined)) return;
                    if (enumInstance.values.indexOf(val) >= 0) return;
                    throw new OperationError(`${typeDesc} validation: Property '${key}'=${val} must be a member of ${enumName}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                },
                valStringOrArray(typeDesc, instance, name) {
                    const val = instance[name];
                    if (typeof val !== "string" && !Array.isArray(val)) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be a string or array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                },
                valArrayIsMember(typeDesc, instance, name, enumInstance, enumName, allowUndefined, allowEmpty, allowDuplicate) {
                    const val = instance[name];
                    if (val === undefined || val === null) {
                        if (allowUndefined) {
                            return;
                        }
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (!Array.isArray(instance[name])) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    if (!allowEmpty && instance[name].length === 0) {
                        throw new OperationError(`${typeDesc} validation: Property '${name}' cannot be empty`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                    }
                    instance[name].forEach((ele, index) => {
                        if (!enumInstance.values.includes(ele)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be an array of ${enumName}`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        if (!allowDuplicate) {
                            if (instance[name].indexOf(ele, index + 1) >= 0) {
                                throw new OperationError(`${typeDesc} validation: Property '${name}' cannot have duplicate element value`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                            }
                        }
                    });
                },
                valArrayOfString(typeDesc, instance, name) {
                    const val = instance[name];
                    if (Check.something(val)) {
                        if (!Array.isArray(val)) {
                            throw new OperationError(`${typeDesc} validation: Property '${name}' must be type Array`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                        }
                        val.forEach(ele => {
                            if (typeof ele !== "string") {
                                throw new OperationError(`${typeDesc} validation: Property '${name}' must be an array of string`, ErrorSubcode.PARAMETER_INVALID_TYPE);
                            }
                        });
                    }
                },
                valTopicString(typedesc, instance, name) {
                    const {
                        DestinationUtil,
                        DestinationType
                    } = __webpack_require__("./modules/solclient-destination/api.js");
                    module.exports.APIPropertiesValidators.valString(typedesc, instance, name);
                    const val = instance[name];
                    const result = DestinationUtil.validateAndEncode(DestinationType.TOPIC, val);
                    if (result.error) {
                        throw new OperationError(`${typedesc} validation: Property '${name}' must be ` + `a valid topic string: ${result.error}`, ErrorSubcode.PARAMETER_OUT_OF_RANGE);
                    }
                },
                valTopicStringOrEmpty(typedesc, instance, name) {
                    const val = instance[name];
                    if (val && val.length) {
                        module.exports.APIPropertiesValidators.valTopicString(typedesc, instance, name);
                    }
                }
            };
            module.exports.APIPropertiesValidators = APIPropertiesValidators;
        },
        "./modules/solclient-util/lib/api-properties.js": (module, __unused_webpack_exports, __webpack_require__) => {
            var util_inspect = __webpack_require__("util")["inspect"];
            const cloneObj = __webpack_require__("./node_modules/clone/clone.js");
            const CLONE_CIRCULAR = false;
            const CLONE_DEPTH = 1;
            class APIProperties {
                constructor(...options) {
                    Object.assign(this, ...options);
                }
                toString() {
                    return util_inspect(this);
                }
                clone() {
                    return cloneObj(this, CLONE_CIRCULAR, CLONE_DEPTH);
                }
            }
            module.exports.APIProperties = APIProperties;
        },
        "./modules/solclient-util/lib/array-utils.js": module => {
            function flatten(array) {
                return array.reduce((acc, el) => acc.concat(Array.isArray(el) ? flatten(el) : el), []);
            }
            function includes(array, el) {
                return array.some(v => v === el);
            }
            module.exports.ArrayUtils = {
                flatten: flatten,
                includes: includes
            };
        },
        "./modules/solclient-util/lib/process.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const WINDOWS_VERSION_MAP = {
                6.4: "10.0",
                6.3: "8.1",
                6.2: "8",
                6.1: "7",
                "6.0": "Vista",
                5.2: "Server 2003",
                5.1: "XP",
                5.01: "2000 SP1",
                "5.0": "2000",
                "4.0": "4.0"
            };
            const NODE_OS_TYPES = {
                Darwin: "OSX",
                Windows_NT: "Windows"
            };
            const context = typeof window !== "undefined" ? window : global;
            const DEFAULT = {};
            const NODE_PROCESS = {
                product: "solclientjs",
                platform: "node",
                agent: "node",
                process: context.process
            };
            const BROWSER_PROCESS = {
                product: "solclientjs",
                platform: "unknown",
                agent: "Gecko"
            };
            function getBrowserAgentInfo() {
                const navObj = typeof navigator !== "undefined" ? navigator : null;
                if (!navObj) return null;
                const agentStr = navigator.userAgent;
                const browsers = [ [ "edge", /Edge\/([0-9._]+)/ ], [ "chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9.]+)(:?\s|$)/ ], [ "firefox", /Firefox\/([0-9.]+)(?:\s|$)/ ], [ "opera", /Opera\/([0-9.]+)(?:\s|$)/ ], [ "opera", /OPR\/([0-9.]+)(:?\s|$)$/ ], [ "ie", /Trident\/7\.0.*rv:([0-9.]+).*\).*Gecko$/ ], [ "ie", /MSIE\s([0-9.]+);.*Trident\/[4-8].0/ ], [ "ie", /MSIE\s(7\.0)/ ], [ "bb10", /BB10;\sTouch.*Version\/([0-9.]+)/ ], [ "android", /Android\s([0-9.]+)/ ], [ "ios", /Version\/([0-9._]+).*Mobile.*Safari.*/ ], [ "safari", /Version\/([0-9._]+).*Safari/ ] ];
                const agentInfo = {
                    browser: {
                        name: "unknown",
                        version: "0.0.0"
                    },
                    platform: {
                        os: "unknown",
                        arch: "unknown",
                        version: "unknown"
                    }
                };
                const agentHas = (...strs) => strs.some(str => agentStr.indexOf(str) >= 0);
                const firstValue = (...vals) => vals.filter(Boolean).shift();
                Object.assign(agentInfo, browsers.map(([ key, rule ]) => {
                    if (!rule.test(agentStr)) return false;
                    const match = rule.exec(agentStr);
                    const versionStrs = match && match[1].split(/[._]/).slice(0, 3);
                    const version = versionStrs.map(str => parseInt(str, 10));
                    while (version.length < 3) version.push(0);
                    return {
                        browser: {
                            name: key,
                            version: version.join(".")
                        }
                    };
                }).filter(Boolean).shift());
                const os = firstValue(agentHas("Windows Phone") && "WindowsPhone", agentHas("Windows") && "Windows", agentHas("Linux") && "Linux", agentHas("like Mac OS X") && "iOS", agentHas("OS X") && "OSX", agentHas("Android", "Adr") && "Android", agentHas("BB10", "RIM Tablet OS", "BlackBerry") && "BlackBerry");
                const versionTests = {
                    Windows: () => firstValue(agentHas("Win16") && "3.1.1", agentHas("Windows CE") && "CE", agentHas("Windows 95") && "4.00.950", agentHas("Windows 98; Win 9x 4.90") && "4.90", agentHas("Windows 98") && "4.10", (() => {
                        const parenParts = agentStr.match(/\(.+?\)/);
                        const versionPart = parenParts[0];
                        if (!versionPart) return false;
                        const versionMatch = str => versionPart.indexOf(str) >= 0;
                        return firstValue(...Object.keys(WINDOWS_VERSION_MAP).map(k => versionMatch(k) && WINDOWS_VERSION_MAP[k]));
                    })()),
                    OSX: () => agentStr.match(/OS X ((\d+[._])+\d+)\b/)[1],
                    Linux: () => "",
                    iOS: () => agentStr.match(/OS ((\d+[._])+\d+) like Mac OS X/)[1],
                    Android: () => agentStr.match(/(?:Android|Adr) ((\d+[._])+\d_)/)[1],
                    BlackBerry: () => agentStr.match(/(?:Version\/|RIM Tablet OS )((\d+\.)+\d+)/)[1]
                };
                const versionTest = versionTests[os];
                agentInfo.platform.os = os || "Unknown";
                agentInfo.platform.version = (versionTest && versionTest() || "0.0.0").replace(/_/g, ".");
                return agentInfo;
            }
            try {
                if (false) {}
                if (true && context.process) {
                    const os = __webpack_require__("os");
                    const ostype = os.type();
                    const osname = NODE_OS_TYPES[ostype] || ostype || "unknown";
                    const nodeVersionStr = `node-${process.version.substr(1)}`;
                    Object.assign(NODE_PROCESS, {
                        platform: `${nodeVersionStr}-${osname}-${os.release()}-${os.arch()}`,
                        agent: nodeVersionStr,
                        description: nodeVersionStr
                    });
                }
            } catch (ex) {}
            const Process = Object.assign({}, DEFAULT, false ? 0 : {}, true ? NODE_PROCESS : 0);
            module.exports.Process = Process;
        },
        "./modules/solclient-util/lib/string-buffer.js": module => {
            class StringBuffer {
                constructor(...args) {
                    this.clear();
                    this.append(...args);
                }
                append(...args) {
                    [ ...args ].forEach(arg => {
                        this.buffer[this.index++] = String(arg);
                    });
                    return this;
                }
                clear() {
                    this.buffer = [];
                    this.index = 0;
                }
                toString() {
                    return this.buffer.join("");
                }
            }
            module.exports.StringBuffer = StringBuffer;
        },
        "./modules/solclient-util/lib/string-utils.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                StringBuffer
            } = __webpack_require__("./modules/solclient-util/lib/string-buffer.js");
            const PAD_LEFT = 0;
            const PAD_RIGHT = 1;
            const LUT_PRINTABLE = (() => {
                const tmp = [];
                for (let c = 0; c < 256; ++c) {
                    tmp[c] = c < 33 || c > 126 ? "." : String.fromCharCode(c);
                }
                return tmp;
            })();
            function padLeftRight(str, minLen, padSide, padChar = " ") {
                if (typeof str !== "string") {
                    return str;
                }
                if (str.length >= minLen) {
                    return str;
                }
                const buf = new StringBuffer();
                for (let i = 0; i < minLen - str.length; i++) {
                    buf.append(padChar.charAt(0));
                }
                switch (padSide) {
                  case PAD_LEFT:
                    return `${buf}${str}`;

                  case PAD_RIGHT:
                    return `${str}${buf}`;

                  default:
                    return str;
                }
            }
            function leastSpaces(length, line) {
                if (!line.length) return length;
                const spaces = line.match(/^\s*/)[0].length;
                return spaces < length ? spaces : length;
            }
            function capitalizeWord(str) {
                return `${str.charAt(0).toUpperCase()}${str.substr(1)}`;
            }
            function isEmptyFun(str) {
                return str === undefined || str === null || str.length === 0;
            }
            const StringUtils = {};
            StringUtils.capitalize = function capitalize(str) {
                if (!(str && str.length)) {
                    return str;
                }
                return str.split(" ").map(capitalizeWord).join(" ");
            };
            StringUtils.isEmpty = isEmptyFun;
            StringUtils.notEmpty = function notEmpty(str) {
                return !isEmptyFun(str);
            };
            StringUtils.toSafeChars = function toSafeChars(str) {
                return str.replace(/[^a-zA-Z0-9_/.]/g, "");
            };
            StringUtils.padLeft = function padLeft(str, minLen, padChar) {
                return padLeftRight(str, minLen, PAD_LEFT, padChar);
            };
            StringUtils.padRight = function padRight(str, minLen, padChar) {
                return padLeftRight(str, minLen, PAD_RIGHT, padChar);
            };
            StringUtils.nullTerminate = function nullTerminate(str) {
                if (str === null || str === undefined) {
                    throw new Error("non str in nullTerminate");
                }
                const lastChar = str.charCodeAt(str.length - 1);
                if (lastChar === 0) {
                    return str;
                }
                return str + String.fromCharCode(0);
            };
            StringUtils.stripNullTerminate = function stripNullTerminate(str) {
                if (str === null || str === undefined) {
                    throw new Error("null str in stripNullTerminate");
                }
                const lastChar = str.charCodeAt(str.length - 1);
                if (lastChar === 0) {
                    return str.substr(0, str.length - 1);
                }
                return str;
            };
            StringUtils.hexdump = function hexdump(s) {
                const output = new StringBuffer();
                const printable = new StringBuffer();
                const spacer = pos => pos === 8 || pos === 16 ? "  " : " ";
                let linelen = 0;
                for (let i = 0, sLength = s.length; i < sLength; i++) {
                    const ccode = s.charCodeAt(i);
                    output.append(padLeftRight(ccode.toString(16), 2, PAD_LEFT));
                    printable.append(LUT_PRINTABLE[ccode] || ".");
                    output.append(spacer(++linelen));
                    if (i === s.length - 1) {
                        while (linelen < 16) {
                            output.append(`  ${spacer(++linelen)}`);
                        }
                    }
                    if (linelen === 16) {
                        output.append(printable.join(""));
                        output.append("\n");
                        linelen = 0;
                        printable.clear();
                    }
                }
                return output.toString();
            };
            StringUtils.heredoc = function heredoc(literals, ...substitutions) {
                const subst = [ ...substitutions, "" ];
                const lines = literals.map(k => k + subst.shift()).join("").split(/\r?\n/);
                const spaces = lines.length === 1 ? 0 : lines.reduce(leastSpaces, Infinity);
                while (lines[0] === "") {
                    lines.shift();
                }
                return lines.map(line => line.substring(spaces)).join("\n");
            };
            module.exports.StringUtils = StringUtils;
        },
        "./modules/solclient-util/lib/timing-bucket.js": module => {
            class TimingBucket {
                constructor(name, interval) {
                    this.name = name;
                    this.interval = interval;
                    this.buckets = [];
                }
                get bucketCount() {
                    let c = 0;
                    for (let i = 0, n = this.buckets.length; i < n; ++i) {
                        c += this.buckets[i] || 0;
                    }
                    return c;
                }
                log(v) {
                    if (v === undefined || isNaN(v)) {
                        return;
                    }
                    const normalized = Math.floor(v / this.interval) * this.interval;
                    this.buckets[normalized] = this.buckets[normalized] || 0;
                    this.buckets[normalized]++;
                }
                toString() {
                    const cont = [];
                    this.buckets.forEach(i => {
                        cont.push(`${i}: ${this.buckets[i]}`);
                    });
                    return `{${cont.join(", ")}}`;
                }
            }
            module.exports.TimingBucket = TimingBucket;
        },
        "./modules/solclient-util/lib/url.js": (module, __unused_webpack_exports, __webpack_require__) => {
            let parseURL;
            if (true) {
                parseURL = __webpack_require__("url").parse;
            } else {}
            module.exports.parseURL = parseURL;
        },
        "./modules/solclient-util/lib/uuid.js": module => {
            function generateUUID() {
                let d = new Date().getTime();
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
                    const r = (d + Math.random() * 16) % 16 | 0;
                    d = Math.floor(d / 16);
                    return (c === "x" ? r : r & 3 | 8).toString(16);
                });
            }
            module.exports.UUID = {
                generateUUID: generateUUID
            };
        },
        "./modules/solclient-util/lib/version.js": module => {
            const VERSION = "10.10.0" || 0;
            const DATE = true ? new Date(Date.parse("Wed Mar 30 2022 17:25:09 GMT-0400 (Eastern Daylight Time)")) : 0;
            const MODE = "RELEASE";
            const TARGET = {
                name: "node",
                node: true,
                browser: false
            };
            const FORMATTED_DATE = (() => {
                const pad = n => n < 10 ? `0${n}` : n;
                const d = DATE;
                const YYYY = d.getFullYear();
                const MM = pad(d.getMonth() + 1);
                const DD = pad(d.getDate());
                const hh = pad(d.getHours());
                const mm = pad(d.getMinutes());
                return `${YYYY}/${MM}/${DD} ${hh}:${mm}`;
            })();
            const SUMMARY = [ "SolclientJS", "10.10.0", MODE, FORMATTED_DATE ].join(", ");
            const Version = {
                version: VERSION,
                date: DATE,
                formattedDate: FORMATTED_DATE,
                target: TARGET,
                mode: MODE,
                debug: false,
                release: true,
                summary: SUMMARY,
                toString() {
                    return SUMMARY;
                }
            };
            module.exports.Version = Version;
        },
        "./modules/solclient-validate/api.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/lib/check.js");
            const {
                Parameter
            } = __webpack_require__("./modules/solclient-validate/lib/parameter.js");
            module.exports.Check = Check;
            module.exports.Parameter = Parameter;
        },
        "./modules/solclient-validate/lib/base-checks.js": module => {
            const EPSILON = 1e6;
            function flatten(arr) {
                return arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
            }
            const BaseChecks = (() => {
                const result = {
                    nothing(value) {
                        return value === undefined || value === null;
                    },
                    anything(value) {
                        return !BaseChecks.nothing(value);
                    },
                    undefined(value) {
                        return typeof value === "undefined";
                    },
                    defined(value) {
                        return !BaseChecks.undefined(value);
                    },
                    array(value) {
                        return BaseChecks.anything(value) && Array.isArray(value);
                    },
                    object(value) {
                        return !BaseChecks.array(value) && value !== null && (typeof value === "object" || value instanceof Object);
                    },
                    instanceOf(val, type) {
                        return BaseChecks.object(val) && val instanceof type;
                    },
                    type(val, type) {
                        return typeof val === type;
                    },
                    instanceOfAny(val, ...types) {
                        return BaseChecks.array(types) && flatten(types).some(type => BaseChecks.instanceOf(val, type));
                    },
                    empty(val) {
                        if (BaseChecks.nothing(val)) return true;
                        if (BaseChecks.object(val)) {
                            if (Object.keys(val).length === 0) {
                                return true;
                            }
                        }
                        if (val.length === 0) {
                            return true;
                        }
                        return false;
                    },
                    truthy(val, fn) {
                        return !!fn(val);
                    },
                    rangeGe(val, rangeMinInclusive) {
                        return val >= rangeMinInclusive;
                    },
                    rangeGt(val, rangeMin) {
                        return val > rangeMin;
                    },
                    rangeLe(val, rangeMaxInclusive) {
                        return val <= rangeMaxInclusive;
                    },
                    rangeLt(val, rangeMax) {
                        return val < rangeMax;
                    },
                    rangeCompare(val, operator, operand, ...args) {
                        switch (operator) {
                          case "=":
                          case "==":
                          case "===":
                            return val === operand;

                          case "~=":
                          case "=~":
                            {
                                const epsilon = args[0] || EPSILON;
                                return Math.abs(val - operand) < epsilon;
                            }

                          case "<":
                            return val < operand;

                          case "<=":
                            return val <= operand;

                          case ">":
                            return val > operand;

                          case ">=":
                            return val >= operand;

                          default:
                            throw new Error(`Illegal operator for rangeCompare: ${operator}`);
                        }
                    },
                    NaN(val) {
                        return Number.isNaN(val);
                    },
                    included(val, obj) {
                        if (BaseChecks.nothing(obj)) {
                            return false;
                        }
                        if (obj.includes) {
                            return obj.includes(val);
                        }
                        if (Array.isArray(obj)) {
                            return obj.indexOf(val) >= 0;
                        }
                        if (BaseChecks.object(obj)) {
                            const keys = Object.keys(obj);
                            return BaseChecks.included(val, keys);
                        }
                        return false;
                    },
                    equal(val, expected) {
                        return val === expected;
                    },
                    member(val, obj) {
                        return BaseChecks.anything(obj) && (BaseChecks.array(obj) ? BaseChecks.included(val, obj) : Object.keys(obj).some(k => obj[k] === val));
                    },
                    boolean(v) {
                        return BaseChecks.type(v, "boolean");
                    },
                    number(v) {
                        return BaseChecks.type(v, "number");
                    },
                    string(v) {
                        return BaseChecks.type(v, "string");
                    },
                    function(v) {
                        return BaseChecks.type(v, "function");
                    }
                };
                result.none = result.nothing;
                result.something = result.anything;
                Object.keys(result).forEach(key => {
                    result[key].orNull = function orNull(val, ...args) {
                        return val === null || result[key](val, ...args);
                    };
                    result[key].orUndefined = function orUndefined(val, ...args) {
                        return val === undefined || result[key](val, ...args);
                    };
                    result[key].orNothing = function orNothing(val, ...args) {
                        return result.nothing(val) || result[key](val, ...args);
                    };
                });
                return result;
            })();
            module.exports.BaseChecks = BaseChecks;
        },
        "./modules/solclient-validate/lib/check.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                BaseChecks
            } = __webpack_require__("./modules/solclient-validate/lib/base-checks.js");
            function thenGen(doOp) {
                return {
                    then: doOp ? f => f() : (_, elseFn) => elseFn()
                };
            }
            const Check = (() => {
                const result = Object.assign({}, BaseChecks);
                result.when = condition => thenGen(condition);
                result.unless = condition => thenGen(!condition);
                return result;
            })();
            module.exports.Check = Check;
        },
        "./modules/solclient-validate/lib/parameter.js": (module, __unused_webpack_exports, __webpack_require__) => {
            const {
                Check
            } = __webpack_require__("./modules/solclient-validate/lib/check.js");
            const {
                ErrorSubcode,
                OperationError
            } = __webpack_require__("./modules/solclient-error/api.js");
            const NO_OBJ = {};
            function objectValues(object) {
                return Object.keys(object).map(k => object[k]);
            }
            function subcodeSummary(subcode, expected = null, got = NO_OBJ) {
                const expectedStr = expected ? `; expected: ${expected}` : "";
                const gotStr = got !== NO_OBJ ? `; got: ${got}` : "";
                switch (subcode) {
                  case ErrorSubcode.PARAMETER_INVALID_TYPE:
                    return `Parameter type was invalid${expectedStr}${gotStr}`;

                  default:
                    return ErrorSubcode.nameOf(subcode).toLowerCase().replace(/_/, " ") + expectedStr;
                }
            }
            function validateError(name, subcode, message) {
                throw new OperationError(`Parameter ${name} failed validation`, subcode, message);
            }
            function validate(name, subcode, message, check, value, ...validatorArgs) {
                if (!check(value, ...validatorArgs)) {
                    return validateError(name, subcode, message);
                }
                return value;
            }
            const typename = x => x && x.constructor && x.constructor.name || typeof x;
            const Parameter = {};
            Parameter.isArray = function isArray(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "array", value)) {
                return validate(name, subcode, message, Check.isArray, value);
            };
            Parameter.isBoolean = function isBoolean(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "boolean", value)) {
                return validate(name, subcode, message, Check.boolean, value);
            };
            Parameter.isBooleanOrNothing = function isBooleanOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "boolean or nothing", value)) {
                return validate(name, subcode, message, Check.boolean.orNothing, value);
            };
            Parameter.isEnumMember = function isEnumMember(name, value, memberOfEnum, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of [${memberOfEnum.names.join(", ")}]`, value)) {
                return validate(name, subcode, message, Check.member, value, memberOfEnum);
            };
            Parameter.isEnumMemberOrNothing = function isEnumMemberOrNothing(name, value, memberOfEnum, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of [${memberOfEnum.names.join(", ")}]`, value)) {
                return validate(name, subcode, message, Check.member.orNothing, value, memberOfEnum);
            };
            Parameter.isFunction = function isFunction(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "function", value)) {
                return validate(name, subcode, message, Check.function, value);
            };
            Parameter.isFunctionOrNothing = function isFunctionOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "function or nothing", value)) {
                return validate(name, subcode, message, Check.function.orNothing, value);
            };
            Parameter.isInstanceOf = function isInstanceOf(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, instanceOf.name, typename(value))) {
                return validate(name, subcode, message, Check.instanceOf, value, instanceOf);
            };
            Parameter.isInstanceOfOrNothing = function isInstanceOfOrNothing(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, `${instanceOf.name} or nothing`, typename(value))) {
                return validate(name, subcode, message, Check.instanceOf.orNothing, value, instanceOf);
            };
            Parameter.isInstanceOfOrNull = function isInstanceOfOrNull(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, `${instanceOf.name} or null`, typename(value))) {
                return validate(name, subcode, message, Check.instanceOf.orNull, value, instanceOf);
            };
            Parameter.isInstanceOfOrUndefined = function isInstanceOfOrUndefined(name, value, instanceOf, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, `${instanceOf.name} or undefined`, typename(value))) {
                return validate(name, subcode, message, Check.instanceOf.orUndefined, value, instanceOf);
            };
            Parameter.isMember = function isMember(name, value, memberOf, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `one of ${memberOf.name}.[${objectValues(memberOf).join(", ")}]`, value)) {
                return validate(name, subcode, message, Check.member, value, memberOf);
            };
            Parameter.isNumber = function isNumber(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number", value)) {
                return validate(name, subcode, message, Check.number, value);
            };
            Parameter.isNumberOrNothing = function isNumberOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number or nothing", value)) {
                return validate(name, subcode, message, Check.number.orNothing, value);
            };
            Parameter.isNumberOrNull = function isNumberOrNull(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "number or null", value)) {
                return validate(name, subcode, message, Check.number.orNull, value);
            };
            Parameter.isRangeCompare = function isRangeCompare(name, value, operator, operand, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `${operator} ${operand}`, value)) {
                return validate(name, subcode, message, Check.rangeCompare, value, operator, operand);
            };
            Parameter.isRangeCompareOrNothing = function isRangeCompareOrNothing(name, value, operator, operand, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `${operator} ${operand} or nothing`, value)) {
                return validate(name, subcode, message, Check.rangeCompare.orNothing, value, operator, operand);
            };
            Parameter.isStringOrNull = function isStringOrNull(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string or null", value)) {
                return validate(name, subcode, message, Check.string.orNull, value);
            };
            Parameter.isString = function isString(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string", value)) {
                return validate(name, subcode, message, Check.string, value);
            };
            Parameter.isStringOrNothing = function isStringOrNothing(name, value, subcode = ErrorSubcode.PARAMETER_INVALID_TYPE, message = subcodeSummary(subcode, "string or nothing", value)) {
                return validate(name, subcode, message, Check.string.orNothing, value);
            };
            Parameter.isValue = function isValue(name, value, expected, subcode = ErrorSubcode.PARAMETER_OUT_OF_RANGE, message = subcodeSummary(subcode, `must be ${value}`)) {
                return validate(name, subcode, message, Check.equal, value, expected);
            };
            module.exports.Parameter = Parameter;
        },
        "./node_modules/clone/clone.js": module => {
            var clone = function() {
                "use strict";
                function _instanceof(obj, type) {
                    return type != null && obj instanceof type;
                }
                var nativeMap;
                try {
                    nativeMap = Map;
                } catch (_) {
                    nativeMap = function() {};
                }
                var nativeSet;
                try {
                    nativeSet = Set;
                } catch (_) {
                    nativeSet = function() {};
                }
                var nativePromise;
                try {
                    nativePromise = Promise;
                } catch (_) {
                    nativePromise = function() {};
                }
                function clone(parent, circular, depth, prototype, includeNonEnumerable) {
                    if (typeof circular === "object") {
                        depth = circular.depth;
                        prototype = circular.prototype;
                        includeNonEnumerable = circular.includeNonEnumerable;
                        circular = circular.circular;
                    }
                    var allParents = [];
                    var allChildren = [];
                    var useBuffer = typeof Buffer != "undefined";
                    if (typeof circular == "undefined") circular = true;
                    if (typeof depth == "undefined") depth = Infinity;
                    function _clone(parent, depth) {
                        if (parent === null) return null;
                        if (depth === 0) return parent;
                        var child;
                        var proto;
                        if (typeof parent != "object") {
                            return parent;
                        }
                        if (_instanceof(parent, nativeMap)) {
                            child = new nativeMap();
                        } else if (_instanceof(parent, nativeSet)) {
                            child = new nativeSet();
                        } else if (_instanceof(parent, nativePromise)) {
                            child = new nativePromise(function(resolve, reject) {
                                parent.then(function(value) {
                                    resolve(_clone(value, depth - 1));
                                }, function(err) {
                                    reject(_clone(err, depth - 1));
                                });
                            });
                        } else if (clone.__isArray(parent)) {
                            child = [];
                        } else if (clone.__isRegExp(parent)) {
                            child = new RegExp(parent.source, __getRegExpFlags(parent));
                            if (parent.lastIndex) child.lastIndex = parent.lastIndex;
                        } else if (clone.__isDate(parent)) {
                            child = new Date(parent.getTime());
                        } else if (useBuffer && Buffer.isBuffer(parent)) {
                            if (Buffer.allocUnsafe) {
                                child = Buffer.allocUnsafe(parent.length);
                            } else {
                                child = new Buffer(parent.length);
                            }
                            parent.copy(child);
                            return child;
                        } else if (_instanceof(parent, Error)) {
                            child = Object.create(parent);
                        } else {
                            if (typeof prototype == "undefined") {
                                proto = Object.getPrototypeOf(parent);
                                child = Object.create(proto);
                            } else {
                                child = Object.create(prototype);
                                proto = prototype;
                            }
                        }
                        if (circular) {
                            var index = allParents.indexOf(parent);
                            if (index != -1) {
                                return allChildren[index];
                            }
                            allParents.push(parent);
                            allChildren.push(child);
                        }
                        if (_instanceof(parent, nativeMap)) {
                            parent.forEach(function(value, key) {
                                var keyChild = _clone(key, depth - 1);
                                var valueChild = _clone(value, depth - 1);
                                child.set(keyChild, valueChild);
                            });
                        }
                        if (_instanceof(parent, nativeSet)) {
                            parent.forEach(function(value) {
                                var entryChild = _clone(value, depth - 1);
                                child.add(entryChild);
                            });
                        }
                        for (var i in parent) {
                            var attrs;
                            if (proto) {
                                attrs = Object.getOwnPropertyDescriptor(proto, i);
                            }
                            if (attrs && attrs.set == null) {
                                continue;
                            }
                            child[i] = _clone(parent[i], depth - 1);
                        }
                        if (Object.getOwnPropertySymbols) {
                            var symbols = Object.getOwnPropertySymbols(parent);
                            for (var i = 0; i < symbols.length; i++) {
                                var symbol = symbols[i];
                                var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
                                if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
                                    continue;
                                }
                                child[symbol] = _clone(parent[symbol], depth - 1);
                                if (!descriptor.enumerable) {
                                    Object.defineProperty(child, symbol, {
                                        enumerable: false
                                    });
                                }
                            }
                        }
                        if (includeNonEnumerable) {
                            var allPropertyNames = Object.getOwnPropertyNames(parent);
                            for (var i = 0; i < allPropertyNames.length; i++) {
                                var propertyName = allPropertyNames[i];
                                var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
                                if (descriptor && descriptor.enumerable) {
                                    continue;
                                }
                                child[propertyName] = _clone(parent[propertyName], depth - 1);
                                Object.defineProperty(child, propertyName, {
                                    enumerable: false
                                });
                            }
                        }
                        return child;
                    }
                    return _clone(parent, depth);
                }
                clone.clonePrototype = function clonePrototype(parent) {
                    if (parent === null) return null;
                    var c = function() {};
                    c.prototype = parent;
                    return new c();
                };
                function __objToStr(o) {
                    return Object.prototype.toString.call(o);
                }
                clone.__objToStr = __objToStr;
                function __isDate(o) {
                    return typeof o === "object" && __objToStr(o) === "[object Date]";
                }
                clone.__isDate = __isDate;
                function __isArray(o) {
                    return typeof o === "object" && __objToStr(o) === "[object Array]";
                }
                clone.__isArray = __isArray;
                function __isRegExp(o) {
                    return typeof o === "object" && __objToStr(o) === "[object RegExp]";
                }
                clone.__isRegExp = __isRegExp;
                function __getRegExpFlags(re) {
                    var flags = "";
                    if (re.global) flags += "g";
                    if (re.ignoreCase) flags += "i";
                    if (re.multiline) flags += "m";
                    return flags;
                }
                clone.__getRegExpFlags = __getRegExpFlags;
                return clone;
            }();
            if (true && module.exports) {
                module.exports = clone;
            }
        },
        "./node_modules/ws/index.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const WebSocket = __webpack_require__("./node_modules/ws/lib/websocket.js");
            WebSocket.createWebSocketStream = __webpack_require__("./node_modules/ws/lib/stream.js");
            WebSocket.Server = __webpack_require__("./node_modules/ws/lib/websocket-server.js");
            WebSocket.Receiver = __webpack_require__("./node_modules/ws/lib/receiver.js");
            WebSocket.Sender = __webpack_require__("./node_modules/ws/lib/sender.js");
            WebSocket.WebSocket = WebSocket;
            WebSocket.WebSocketServer = WebSocket.Server;
            module.exports = WebSocket;
        },
        "./node_modules/ws/lib/buffer-util.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {
                EMPTY_BUFFER
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            function concat(list, totalLength) {
                if (list.length === 0) return EMPTY_BUFFER;
                if (list.length === 1) return list[0];
                const target = Buffer.allocUnsafe(totalLength);
                let offset = 0;
                for (let i = 0; i < list.length; i++) {
                    const buf = list[i];
                    target.set(buf, offset);
                    offset += buf.length;
                }
                if (offset < totalLength) return target.slice(0, offset);
                return target;
            }
            function _mask(source, mask, output, offset, length) {
                for (let i = 0; i < length; i++) {
                    output[offset + i] = source[i] ^ mask[i & 3];
                }
            }
            function _unmask(buffer, mask) {
                for (let i = 0; i < buffer.length; i++) {
                    buffer[i] ^= mask[i & 3];
                }
            }
            function toArrayBuffer(buf) {
                if (buf.byteLength === buf.buffer.byteLength) {
                    return buf.buffer;
                }
                return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            }
            function toBuffer(data) {
                toBuffer.readOnly = true;
                if (Buffer.isBuffer(data)) return data;
                let buf;
                if (data instanceof ArrayBuffer) {
                    buf = Buffer.from(data);
                } else if (ArrayBuffer.isView(data)) {
                    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                } else {
                    buf = Buffer.from(data);
                    toBuffer.readOnly = false;
                }
                return buf;
            }
            try {
                const bufferUtil = __webpack_require__("bufferutil");
                module.exports = {
                    concat: concat,
                    mask(source, mask, output, offset, length) {
                        if (length < 48) _mask(source, mask, output, offset, length); else bufferUtil.mask(source, mask, output, offset, length);
                    },
                    toArrayBuffer: toArrayBuffer,
                    toBuffer: toBuffer,
                    unmask(buffer, mask) {
                        if (buffer.length < 32) _unmask(buffer, mask); else bufferUtil.unmask(buffer, mask);
                    }
                };
            } catch (e) {
                module.exports = {
                    concat: concat,
                    mask: _mask,
                    toArrayBuffer: toArrayBuffer,
                    toBuffer: toBuffer,
                    unmask: _unmask
                };
            }
        },
        "./node_modules/ws/lib/constants.js": module => {
            "use strict";
            module.exports = {
                BINARY_TYPES: [ "nodebuffer", "arraybuffer", "fragments" ],
                EMPTY_BUFFER: Buffer.alloc(0),
                GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
                kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
                kListener: Symbol("kListener"),
                kStatusCode: Symbol("status-code"),
                kWebSocket: Symbol("websocket"),
                NOOP: () => {}
            };
        },
        "./node_modules/ws/lib/event-target.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {
                kForOnEventAttribute,
                kListener
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            const kCode = Symbol("kCode");
            const kData = Symbol("kData");
            const kError = Symbol("kError");
            const kMessage = Symbol("kMessage");
            const kReason = Symbol("kReason");
            const kTarget = Symbol("kTarget");
            const kType = Symbol("kType");
            const kWasClean = Symbol("kWasClean");
            class Event {
                constructor(type) {
                    this[kTarget] = null;
                    this[kType] = type;
                }
                get target() {
                    return this[kTarget];
                }
                get type() {
                    return this[kType];
                }
            }
            Object.defineProperty(Event.prototype, "target", {
                enumerable: true
            });
            Object.defineProperty(Event.prototype, "type", {
                enumerable: true
            });
            class CloseEvent extends Event {
                constructor(type, options = {}) {
                    super(type);
                    this[kCode] = options.code === undefined ? 0 : options.code;
                    this[kReason] = options.reason === undefined ? "" : options.reason;
                    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
                }
                get code() {
                    return this[kCode];
                }
                get reason() {
                    return this[kReason];
                }
                get wasClean() {
                    return this[kWasClean];
                }
            }
            Object.defineProperty(CloseEvent.prototype, "code", {
                enumerable: true
            });
            Object.defineProperty(CloseEvent.prototype, "reason", {
                enumerable: true
            });
            Object.defineProperty(CloseEvent.prototype, "wasClean", {
                enumerable: true
            });
            class ErrorEvent extends Event {
                constructor(type, options = {}) {
                    super(type);
                    this[kError] = options.error === undefined ? null : options.error;
                    this[kMessage] = options.message === undefined ? "" : options.message;
                }
                get error() {
                    return this[kError];
                }
                get message() {
                    return this[kMessage];
                }
            }
            Object.defineProperty(ErrorEvent.prototype, "error", {
                enumerable: true
            });
            Object.defineProperty(ErrorEvent.prototype, "message", {
                enumerable: true
            });
            class MessageEvent extends Event {
                constructor(type, options = {}) {
                    super(type);
                    this[kData] = options.data === undefined ? null : options.data;
                }
                get data() {
                    return this[kData];
                }
            }
            Object.defineProperty(MessageEvent.prototype, "data", {
                enumerable: true
            });
            const EventTarget = {
                addEventListener(type, listener, options = {}) {
                    let wrapper;
                    if (type === "message") {
                        wrapper = function onMessage(data, isBinary) {
                            const event = new MessageEvent("message", {
                                data: isBinary ? data : data.toString()
                            });
                            event[kTarget] = this;
                            listener.call(this, event);
                        };
                    } else if (type === "close") {
                        wrapper = function onClose(code, message) {
                            const event = new CloseEvent("close", {
                                code: code,
                                reason: message.toString(),
                                wasClean: this._closeFrameReceived && this._closeFrameSent
                            });
                            event[kTarget] = this;
                            listener.call(this, event);
                        };
                    } else if (type === "error") {
                        wrapper = function onError(error) {
                            const event = new ErrorEvent("error", {
                                error: error,
                                message: error.message
                            });
                            event[kTarget] = this;
                            listener.call(this, event);
                        };
                    } else if (type === "open") {
                        wrapper = function onOpen() {
                            const event = new Event("open");
                            event[kTarget] = this;
                            listener.call(this, event);
                        };
                    } else {
                        return;
                    }
                    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
                    wrapper[kListener] = listener;
                    if (options.once) {
                        this.once(type, wrapper);
                    } else {
                        this.on(type, wrapper);
                    }
                },
                removeEventListener(type, handler) {
                    for (const listener of this.listeners(type)) {
                        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
                            this.removeListener(type, listener);
                            break;
                        }
                    }
                }
            };
            module.exports = {
                CloseEvent: CloseEvent,
                ErrorEvent: ErrorEvent,
                Event: Event,
                EventTarget: EventTarget,
                MessageEvent: MessageEvent
            };
        },
        "./node_modules/ws/lib/extension.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {
                tokenChars
            } = __webpack_require__("./node_modules/ws/lib/validation.js");
            function push(dest, name, elem) {
                if (dest[name] === undefined) dest[name] = [ elem ]; else dest[name].push(elem);
            }
            function parse(header) {
                const offers = Object.create(null);
                let params = Object.create(null);
                let mustUnescape = false;
                let isEscaping = false;
                let inQuotes = false;
                let extensionName;
                let paramName;
                let start = -1;
                let code = -1;
                let end = -1;
                let i = 0;
                for (;i < header.length; i++) {
                    code = header.charCodeAt(i);
                    if (extensionName === undefined) {
                        if (end === -1 && tokenChars[code] === 1) {
                            if (start === -1) start = i;
                        } else if (i !== 0 && (code === 32 || code === 9)) {
                            if (end === -1 && start !== -1) end = i;
                        } else if (code === 59 || code === 44) {
                            if (start === -1) {
                                throw new SyntaxError(`Unexpected character at index ${i}`);
                            }
                            if (end === -1) end = i;
                            const name = header.slice(start, end);
                            if (code === 44) {
                                push(offers, name, params);
                                params = Object.create(null);
                            } else {
                                extensionName = name;
                            }
                            start = end = -1;
                        } else {
                            throw new SyntaxError(`Unexpected character at index ${i}`);
                        }
                    } else if (paramName === undefined) {
                        if (end === -1 && tokenChars[code] === 1) {
                            if (start === -1) start = i;
                        } else if (code === 32 || code === 9) {
                            if (end === -1 && start !== -1) end = i;
                        } else if (code === 59 || code === 44) {
                            if (start === -1) {
                                throw new SyntaxError(`Unexpected character at index ${i}`);
                            }
                            if (end === -1) end = i;
                            push(params, header.slice(start, end), true);
                            if (code === 44) {
                                push(offers, extensionName, params);
                                params = Object.create(null);
                                extensionName = undefined;
                            }
                            start = end = -1;
                        } else if (code === 61 && start !== -1 && end === -1) {
                            paramName = header.slice(start, i);
                            start = end = -1;
                        } else {
                            throw new SyntaxError(`Unexpected character at index ${i}`);
                        }
                    } else {
                        if (isEscaping) {
                            if (tokenChars[code] !== 1) {
                                throw new SyntaxError(`Unexpected character at index ${i}`);
                            }
                            if (start === -1) start = i; else if (!mustUnescape) mustUnescape = true;
                            isEscaping = false;
                        } else if (inQuotes) {
                            if (tokenChars[code] === 1) {
                                if (start === -1) start = i;
                            } else if (code === 34 && start !== -1) {
                                inQuotes = false;
                                end = i;
                            } else if (code === 92) {
                                isEscaping = true;
                            } else {
                                throw new SyntaxError(`Unexpected character at index ${i}`);
                            }
                        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
                            inQuotes = true;
                        } else if (end === -1 && tokenChars[code] === 1) {
                            if (start === -1) start = i;
                        } else if (start !== -1 && (code === 32 || code === 9)) {
                            if (end === -1) end = i;
                        } else if (code === 59 || code === 44) {
                            if (start === -1) {
                                throw new SyntaxError(`Unexpected character at index ${i}`);
                            }
                            if (end === -1) end = i;
                            let value = header.slice(start, end);
                            if (mustUnescape) {
                                value = value.replace(/\\/g, "");
                                mustUnescape = false;
                            }
                            push(params, paramName, value);
                            if (code === 44) {
                                push(offers, extensionName, params);
                                params = Object.create(null);
                                extensionName = undefined;
                            }
                            paramName = undefined;
                            start = end = -1;
                        } else {
                            throw new SyntaxError(`Unexpected character at index ${i}`);
                        }
                    }
                }
                if (start === -1 || inQuotes || code === 32 || code === 9) {
                    throw new SyntaxError("Unexpected end of input");
                }
                if (end === -1) end = i;
                const token = header.slice(start, end);
                if (extensionName === undefined) {
                    push(offers, token, params);
                } else {
                    if (paramName === undefined) {
                        push(params, token, true);
                    } else if (mustUnescape) {
                        push(params, paramName, token.replace(/\\/g, ""));
                    } else {
                        push(params, paramName, token);
                    }
                    push(offers, extensionName, params);
                }
                return offers;
            }
            function format(extensions) {
                return Object.keys(extensions).map(extension => {
                    let configurations = extensions[extension];
                    if (!Array.isArray(configurations)) configurations = [ configurations ];
                    return configurations.map(params => {
                        return [ extension ].concat(Object.keys(params).map(k => {
                            let values = params[k];
                            if (!Array.isArray(values)) values = [ values ];
                            return values.map(v => v === true ? k : `${k}=${v}`).join("; ");
                        })).join("; ");
                    }).join(", ");
                }).join(", ");
            }
            module.exports = {
                format: format,
                parse: parse
            };
        },
        "./node_modules/ws/lib/limiter.js": module => {
            "use strict";
            const kDone = Symbol("kDone");
            const kRun = Symbol("kRun");
            class Limiter {
                constructor(concurrency) {
                    this[kDone] = () => {
                        this.pending--;
                        this[kRun]();
                    };
                    this.concurrency = concurrency || Infinity;
                    this.jobs = [];
                    this.pending = 0;
                }
                add(job) {
                    this.jobs.push(job);
                    this[kRun]();
                }
                [kRun]() {
                    if (this.pending === this.concurrency) return;
                    if (this.jobs.length) {
                        const job = this.jobs.shift();
                        this.pending++;
                        job(this[kDone]);
                    }
                }
            }
            module.exports = Limiter;
        },
        "./node_modules/ws/lib/permessage-deflate.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const zlib = __webpack_require__("zlib");
            const bufferUtil = __webpack_require__("./node_modules/ws/lib/buffer-util.js");
            const Limiter = __webpack_require__("./node_modules/ws/lib/limiter.js");
            const {
                kStatusCode
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            const TRAILER = Buffer.from([ 0, 0, 255, 255 ]);
            const kPerMessageDeflate = Symbol("permessage-deflate");
            const kTotalLength = Symbol("total-length");
            const kCallback = Symbol("callback");
            const kBuffers = Symbol("buffers");
            const kError = Symbol("error");
            let zlibLimiter;
            class PerMessageDeflate {
                constructor(options, isServer, maxPayload) {
                    this._maxPayload = maxPayload | 0;
                    this._options = options || {};
                    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
                    this._isServer = !!isServer;
                    this._deflate = null;
                    this._inflate = null;
                    this.params = null;
                    if (!zlibLimiter) {
                        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
                        zlibLimiter = new Limiter(concurrency);
                    }
                }
                static get extensionName() {
                    return "permessage-deflate";
                }
                offer() {
                    const params = {};
                    if (this._options.serverNoContextTakeover) {
                        params.server_no_context_takeover = true;
                    }
                    if (this._options.clientNoContextTakeover) {
                        params.client_no_context_takeover = true;
                    }
                    if (this._options.serverMaxWindowBits) {
                        params.server_max_window_bits = this._options.serverMaxWindowBits;
                    }
                    if (this._options.clientMaxWindowBits) {
                        params.client_max_window_bits = this._options.clientMaxWindowBits;
                    } else if (this._options.clientMaxWindowBits == null) {
                        params.client_max_window_bits = true;
                    }
                    return params;
                }
                accept(configurations) {
                    configurations = this.normalizeParams(configurations);
                    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
                    return this.params;
                }
                cleanup() {
                    if (this._inflate) {
                        this._inflate.close();
                        this._inflate = null;
                    }
                    if (this._deflate) {
                        const callback = this._deflate[kCallback];
                        this._deflate.close();
                        this._deflate = null;
                        if (callback) {
                            callback(new Error("The deflate stream was closed while data was being processed"));
                        }
                    }
                }
                acceptAsServer(offers) {
                    const opts = this._options;
                    const accepted = offers.find(params => {
                        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
                            return false;
                        }
                        return true;
                    });
                    if (!accepted) {
                        throw new Error("None of the extension offers can be accepted");
                    }
                    if (opts.serverNoContextTakeover) {
                        accepted.server_no_context_takeover = true;
                    }
                    if (opts.clientNoContextTakeover) {
                        accepted.client_no_context_takeover = true;
                    }
                    if (typeof opts.serverMaxWindowBits === "number") {
                        accepted.server_max_window_bits = opts.serverMaxWindowBits;
                    }
                    if (typeof opts.clientMaxWindowBits === "number") {
                        accepted.client_max_window_bits = opts.clientMaxWindowBits;
                    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
                        delete accepted.client_max_window_bits;
                    }
                    return accepted;
                }
                acceptAsClient(response) {
                    const params = response[0];
                    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
                        throw new Error('Unexpected parameter "client_no_context_takeover"');
                    }
                    if (!params.client_max_window_bits) {
                        if (typeof this._options.clientMaxWindowBits === "number") {
                            params.client_max_window_bits = this._options.clientMaxWindowBits;
                        }
                    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
                        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
                    }
                    return params;
                }
                normalizeParams(configurations) {
                    configurations.forEach(params => {
                        Object.keys(params).forEach(key => {
                            let value = params[key];
                            if (value.length > 1) {
                                throw new Error(`Parameter "${key}" must have only a single value`);
                            }
                            value = value[0];
                            if (key === "client_max_window_bits") {
                                if (value !== true) {
                                    const num = +value;
                                    if (!Number.isInteger(num) || num < 8 || num > 15) {
                                        throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                                    }
                                    value = num;
                                } else if (!this._isServer) {
                                    throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                                }
                            } else if (key === "server_max_window_bits") {
                                const num = +value;
                                if (!Number.isInteger(num) || num < 8 || num > 15) {
                                    throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                                }
                                value = num;
                            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
                                if (value !== true) {
                                    throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                                }
                            } else {
                                throw new Error(`Unknown parameter "${key}"`);
                            }
                            params[key] = value;
                        });
                    });
                    return configurations;
                }
                decompress(data, fin, callback) {
                    zlibLimiter.add(done => {
                        this._decompress(data, fin, (err, result) => {
                            done();
                            callback(err, result);
                        });
                    });
                }
                compress(data, fin, callback) {
                    zlibLimiter.add(done => {
                        this._compress(data, fin, (err, result) => {
                            done();
                            callback(err, result);
                        });
                    });
                }
                _decompress(data, fin, callback) {
                    const endpoint = this._isServer ? "client" : "server";
                    if (!this._inflate) {
                        const key = `${endpoint}_max_window_bits`;
                        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                        this._inflate = zlib.createInflateRaw({
                            ...this._options.zlibInflateOptions,
                            windowBits: windowBits
                        });
                        this._inflate[kPerMessageDeflate] = this;
                        this._inflate[kTotalLength] = 0;
                        this._inflate[kBuffers] = [];
                        this._inflate.on("error", inflateOnError);
                        this._inflate.on("data", inflateOnData);
                    }
                    this._inflate[kCallback] = callback;
                    this._inflate.write(data);
                    if (fin) this._inflate.write(TRAILER);
                    this._inflate.flush(() => {
                        const err = this._inflate[kError];
                        if (err) {
                            this._inflate.close();
                            this._inflate = null;
                            callback(err);
                            return;
                        }
                        const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
                        if (this._inflate._readableState.endEmitted) {
                            this._inflate.close();
                            this._inflate = null;
                        } else {
                            this._inflate[kTotalLength] = 0;
                            this._inflate[kBuffers] = [];
                            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                                this._inflate.reset();
                            }
                        }
                        callback(null, data);
                    });
                }
                _compress(data, fin, callback) {
                    const endpoint = this._isServer ? "server" : "client";
                    if (!this._deflate) {
                        const key = `${endpoint}_max_window_bits`;
                        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
                        this._deflate = zlib.createDeflateRaw({
                            ...this._options.zlibDeflateOptions,
                            windowBits: windowBits
                        });
                        this._deflate[kTotalLength] = 0;
                        this._deflate[kBuffers] = [];
                        this._deflate.on("data", deflateOnData);
                    }
                    this._deflate[kCallback] = callback;
                    this._deflate.write(data);
                    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
                        if (!this._deflate) {
                            return;
                        }
                        let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
                        if (fin) data = data.slice(0, data.length - 4);
                        this._deflate[kCallback] = null;
                        this._deflate[kTotalLength] = 0;
                        this._deflate[kBuffers] = [];
                        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                            this._deflate.reset();
                        }
                        callback(null, data);
                    });
                }
            }
            module.exports = PerMessageDeflate;
            function deflateOnData(chunk) {
                this[kBuffers].push(chunk);
                this[kTotalLength] += chunk.length;
            }
            function inflateOnData(chunk) {
                this[kTotalLength] += chunk.length;
                if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
                    this[kBuffers].push(chunk);
                    return;
                }
                this[kError] = new RangeError("Max payload size exceeded");
                this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
                this[kError][kStatusCode] = 1009;
                this.removeListener("data", inflateOnData);
                this.reset();
            }
            function inflateOnError(err) {
                this[kPerMessageDeflate]._inflate = null;
                err[kStatusCode] = 1007;
                this[kCallback](err);
            }
        },
        "./node_modules/ws/lib/receiver.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {
                Writable
            } = __webpack_require__("stream");
            const PerMessageDeflate = __webpack_require__("./node_modules/ws/lib/permessage-deflate.js");
            const {
                BINARY_TYPES,
                EMPTY_BUFFER,
                kStatusCode,
                kWebSocket
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            const {
                concat,
                toArrayBuffer,
                unmask
            } = __webpack_require__("./node_modules/ws/lib/buffer-util.js");
            const {
                isValidStatusCode,
                isValidUTF8
            } = __webpack_require__("./node_modules/ws/lib/validation.js");
            const GET_INFO = 0;
            const GET_PAYLOAD_LENGTH_16 = 1;
            const GET_PAYLOAD_LENGTH_64 = 2;
            const GET_MASK = 3;
            const GET_DATA = 4;
            const INFLATING = 5;
            class Receiver extends Writable {
                constructor(options = {}) {
                    super();
                    this._binaryType = options.binaryType || BINARY_TYPES[0];
                    this._extensions = options.extensions || {};
                    this._isServer = !!options.isServer;
                    this._maxPayload = options.maxPayload | 0;
                    this._skipUTF8Validation = !!options.skipUTF8Validation;
                    this[kWebSocket] = undefined;
                    this._bufferedBytes = 0;
                    this._buffers = [];
                    this._compressed = false;
                    this._payloadLength = 0;
                    this._mask = undefined;
                    this._fragmented = 0;
                    this._masked = false;
                    this._fin = false;
                    this._opcode = 0;
                    this._totalPayloadLength = 0;
                    this._messageLength = 0;
                    this._fragments = [];
                    this._state = GET_INFO;
                    this._loop = false;
                }
                _write(chunk, encoding, cb) {
                    if (this._opcode === 8 && this._state == GET_INFO) return cb();
                    this._bufferedBytes += chunk.length;
                    this._buffers.push(chunk);
                    this.startLoop(cb);
                }
                consume(n) {
                    this._bufferedBytes -= n;
                    if (n === this._buffers[0].length) return this._buffers.shift();
                    if (n < this._buffers[0].length) {
                        const buf = this._buffers[0];
                        this._buffers[0] = buf.slice(n);
                        return buf.slice(0, n);
                    }
                    const dst = Buffer.allocUnsafe(n);
                    do {
                        const buf = this._buffers[0];
                        const offset = dst.length - n;
                        if (n >= buf.length) {
                            dst.set(this._buffers.shift(), offset);
                        } else {
                            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
                            this._buffers[0] = buf.slice(n);
                        }
                        n -= buf.length;
                    } while (n > 0);
                    return dst;
                }
                startLoop(cb) {
                    let err;
                    this._loop = true;
                    do {
                        switch (this._state) {
                          case GET_INFO:
                            err = this.getInfo();
                            break;

                          case GET_PAYLOAD_LENGTH_16:
                            err = this.getPayloadLength16();
                            break;

                          case GET_PAYLOAD_LENGTH_64:
                            err = this.getPayloadLength64();
                            break;

                          case GET_MASK:
                            this.getMask();
                            break;

                          case GET_DATA:
                            err = this.getData(cb);
                            break;

                          default:
                            this._loop = false;
                            return;
                        }
                    } while (this._loop);
                    cb(err);
                }
                getInfo() {
                    if (this._bufferedBytes < 2) {
                        this._loop = false;
                        return;
                    }
                    const buf = this.consume(2);
                    if ((buf[0] & 48) !== 0) {
                        this._loop = false;
                        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
                    }
                    const compressed = (buf[0] & 64) === 64;
                    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
                        this._loop = false;
                        return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
                    }
                    this._fin = (buf[0] & 128) === 128;
                    this._opcode = buf[0] & 15;
                    this._payloadLength = buf[1] & 127;
                    if (this._opcode === 0) {
                        if (compressed) {
                            this._loop = false;
                            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
                        }
                        if (!this._fragmented) {
                            this._loop = false;
                            return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
                        }
                        this._opcode = this._fragmented;
                    } else if (this._opcode === 1 || this._opcode === 2) {
                        if (this._fragmented) {
                            this._loop = false;
                            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
                        }
                        this._compressed = compressed;
                    } else if (this._opcode > 7 && this._opcode < 11) {
                        if (!this._fin) {
                            this._loop = false;
                            return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
                        }
                        if (compressed) {
                            this._loop = false;
                            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
                        }
                        if (this._payloadLength > 125) {
                            this._loop = false;
                            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
                        }
                    } else {
                        this._loop = false;
                        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
                    }
                    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
                    this._masked = (buf[1] & 128) === 128;
                    if (this._isServer) {
                        if (!this._masked) {
                            this._loop = false;
                            return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
                        }
                    } else if (this._masked) {
                        this._loop = false;
                        return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
                    }
                    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16; else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64; else return this.haveLength();
                }
                getPayloadLength16() {
                    if (this._bufferedBytes < 2) {
                        this._loop = false;
                        return;
                    }
                    this._payloadLength = this.consume(2).readUInt16BE(0);
                    return this.haveLength();
                }
                getPayloadLength64() {
                    if (this._bufferedBytes < 8) {
                        this._loop = false;
                        return;
                    }
                    const buf = this.consume(8);
                    const num = buf.readUInt32BE(0);
                    if (num > Math.pow(2, 53 - 32) - 1) {
                        this._loop = false;
                        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
                    }
                    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
                    return this.haveLength();
                }
                haveLength() {
                    if (this._payloadLength && this._opcode < 8) {
                        this._totalPayloadLength += this._payloadLength;
                        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
                            this._loop = false;
                            return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
                        }
                    }
                    if (this._masked) this._state = GET_MASK; else this._state = GET_DATA;
                }
                getMask() {
                    if (this._bufferedBytes < 4) {
                        this._loop = false;
                        return;
                    }
                    this._mask = this.consume(4);
                    this._state = GET_DATA;
                }
                getData(cb) {
                    let data = EMPTY_BUFFER;
                    if (this._payloadLength) {
                        if (this._bufferedBytes < this._payloadLength) {
                            this._loop = false;
                            return;
                        }
                        data = this.consume(this._payloadLength);
                        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
                            unmask(data, this._mask);
                        }
                    }
                    if (this._opcode > 7) return this.controlMessage(data);
                    if (this._compressed) {
                        this._state = INFLATING;
                        this.decompress(data, cb);
                        return;
                    }
                    if (data.length) {
                        this._messageLength = this._totalPayloadLength;
                        this._fragments.push(data);
                    }
                    return this.dataMessage();
                }
                decompress(data, cb) {
                    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
                        if (err) return cb(err);
                        if (buf.length) {
                            this._messageLength += buf.length;
                            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
                                return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
                            }
                            this._fragments.push(buf);
                        }
                        const er = this.dataMessage();
                        if (er) return cb(er);
                        this.startLoop(cb);
                    });
                }
                dataMessage() {
                    if (this._fin) {
                        const messageLength = this._messageLength;
                        const fragments = this._fragments;
                        this._totalPayloadLength = 0;
                        this._messageLength = 0;
                        this._fragmented = 0;
                        this._fragments = [];
                        if (this._opcode === 2) {
                            let data;
                            if (this._binaryType === "nodebuffer") {
                                data = concat(fragments, messageLength);
                            } else if (this._binaryType === "arraybuffer") {
                                data = toArrayBuffer(concat(fragments, messageLength));
                            } else {
                                data = fragments;
                            }
                            this.emit("message", data, true);
                        } else {
                            const buf = concat(fragments, messageLength);
                            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                                this._loop = false;
                                return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
                            }
                            this.emit("message", buf, false);
                        }
                    }
                    this._state = GET_INFO;
                }
                controlMessage(data) {
                    if (this._opcode === 8) {
                        this._loop = false;
                        if (data.length === 0) {
                            this.emit("conclude", 1005, EMPTY_BUFFER);
                            this.end();
                        } else if (data.length === 1) {
                            return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
                        } else {
                            const code = data.readUInt16BE(0);
                            if (!isValidStatusCode(code)) {
                                return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
                            }
                            const buf = data.slice(2);
                            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                                return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
                            }
                            this.emit("conclude", code, buf);
                            this.end();
                        }
                    } else if (this._opcode === 9) {
                        this.emit("ping", data);
                    } else {
                        this.emit("pong", data);
                    }
                    this._state = GET_INFO;
                }
            }
            module.exports = Receiver;
            function error(ErrorCtor, message, prefix, statusCode, errorCode) {
                const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
                Error.captureStackTrace(err, error);
                err.code = errorCode;
                err[kStatusCode] = statusCode;
                return err;
            }
        },
        "./node_modules/ws/lib/sender.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const net = __webpack_require__("net");
            const tls = __webpack_require__("tls");
            const {
                randomFillSync
            } = __webpack_require__("crypto");
            const PerMessageDeflate = __webpack_require__("./node_modules/ws/lib/permessage-deflate.js");
            const {
                EMPTY_BUFFER
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            const {
                isValidStatusCode
            } = __webpack_require__("./node_modules/ws/lib/validation.js");
            const {
                mask: applyMask,
                toBuffer
            } = __webpack_require__("./node_modules/ws/lib/buffer-util.js");
            const kByteLength = Symbol("kByteLength");
            const maskBuffer = Buffer.alloc(4);
            class Sender {
                constructor(socket, extensions, generateMask) {
                    this._extensions = extensions || {};
                    if (generateMask) {
                        this._generateMask = generateMask;
                        this._maskBuffer = Buffer.alloc(4);
                    }
                    this._socket = socket;
                    this._firstFragment = true;
                    this._compress = false;
                    this._bufferedBytes = 0;
                    this._deflating = false;
                    this._queue = [];
                }
                static frame(data, options) {
                    let mask;
                    let merge = false;
                    let offset = 2;
                    let skipMasking = false;
                    if (options.mask) {
                        mask = options.maskBuffer || maskBuffer;
                        if (options.generateMask) {
                            options.generateMask(mask);
                        } else {
                            randomFillSync(mask, 0, 4);
                        }
                        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
                        offset = 6;
                    }
                    let dataLength;
                    if (typeof data === "string") {
                        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
                            dataLength = options[kByteLength];
                        } else {
                            data = Buffer.from(data);
                            dataLength = data.length;
                        }
                    } else {
                        dataLength = data.length;
                        merge = options.mask && options.readOnly && !skipMasking;
                    }
                    let payloadLength = dataLength;
                    if (dataLength >= 65536) {
                        offset += 8;
                        payloadLength = 127;
                    } else if (dataLength > 125) {
                        offset += 2;
                        payloadLength = 126;
                    }
                    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
                    target[0] = options.fin ? options.opcode | 128 : options.opcode;
                    if (options.rsv1) target[0] |= 64;
                    target[1] = payloadLength;
                    if (payloadLength === 126) {
                        target.writeUInt16BE(dataLength, 2);
                    } else if (payloadLength === 127) {
                        target[2] = target[3] = 0;
                        target.writeUIntBE(dataLength, 4, 6);
                    }
                    if (!options.mask) return [ target, data ];
                    target[1] |= 128;
                    target[offset - 4] = mask[0];
                    target[offset - 3] = mask[1];
                    target[offset - 2] = mask[2];
                    target[offset - 1] = mask[3];
                    if (skipMasking) return [ target, data ];
                    if (merge) {
                        applyMask(data, mask, target, offset, dataLength);
                        return [ target ];
                    }
                    applyMask(data, mask, data, 0, dataLength);
                    return [ target, data ];
                }
                close(code, data, mask, cb) {
                    let buf;
                    if (code === undefined) {
                        buf = EMPTY_BUFFER;
                    } else if (typeof code !== "number" || !isValidStatusCode(code)) {
                        throw new TypeError("First argument must be a valid error code number");
                    } else if (data === undefined || !data.length) {
                        buf = Buffer.allocUnsafe(2);
                        buf.writeUInt16BE(code, 0);
                    } else {
                        const length = Buffer.byteLength(data);
                        if (length > 123) {
                            throw new RangeError("The message must not be greater than 123 bytes");
                        }
                        buf = Buffer.allocUnsafe(2 + length);
                        buf.writeUInt16BE(code, 0);
                        if (typeof data === "string") {
                            buf.write(data, 2);
                        } else {
                            buf.set(data, 2);
                        }
                    }
                    const options = {
                        [kByteLength]: buf.length,
                        fin: true,
                        generateMask: this._generateMask,
                        mask: mask,
                        maskBuffer: this._maskBuffer,
                        opcode: 8,
                        readOnly: false,
                        rsv1: false
                    };
                    if (this._deflating) {
                        this.enqueue([ this.dispatch, buf, false, options, cb ]);
                    } else {
                        this.sendFrame(Sender.frame(buf, options), cb);
                    }
                }
                ping(data, mask, cb) {
                    let byteLength;
                    let readOnly;
                    if (typeof data === "string") {
                        byteLength = Buffer.byteLength(data);
                        readOnly = false;
                    } else {
                        data = toBuffer(data);
                        byteLength = data.length;
                        readOnly = toBuffer.readOnly;
                    }
                    if (byteLength > 125) {
                        throw new RangeError("The data size must not be greater than 125 bytes");
                    }
                    const options = {
                        [kByteLength]: byteLength,
                        fin: true,
                        generateMask: this._generateMask,
                        mask: mask,
                        maskBuffer: this._maskBuffer,
                        opcode: 9,
                        readOnly: readOnly,
                        rsv1: false
                    };
                    if (this._deflating) {
                        this.enqueue([ this.dispatch, data, false, options, cb ]);
                    } else {
                        this.sendFrame(Sender.frame(data, options), cb);
                    }
                }
                pong(data, mask, cb) {
                    let byteLength;
                    let readOnly;
                    if (typeof data === "string") {
                        byteLength = Buffer.byteLength(data);
                        readOnly = false;
                    } else {
                        data = toBuffer(data);
                        byteLength = data.length;
                        readOnly = toBuffer.readOnly;
                    }
                    if (byteLength > 125) {
                        throw new RangeError("The data size must not be greater than 125 bytes");
                    }
                    const options = {
                        [kByteLength]: byteLength,
                        fin: true,
                        generateMask: this._generateMask,
                        mask: mask,
                        maskBuffer: this._maskBuffer,
                        opcode: 10,
                        readOnly: readOnly,
                        rsv1: false
                    };
                    if (this._deflating) {
                        this.enqueue([ this.dispatch, data, false, options, cb ]);
                    } else {
                        this.sendFrame(Sender.frame(data, options), cb);
                    }
                }
                send(data, options, cb) {
                    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                    let opcode = options.binary ? 2 : 1;
                    let rsv1 = options.compress;
                    let byteLength;
                    let readOnly;
                    if (typeof data === "string") {
                        byteLength = Buffer.byteLength(data);
                        readOnly = false;
                    } else {
                        data = toBuffer(data);
                        byteLength = data.length;
                        readOnly = toBuffer.readOnly;
                    }
                    if (this._firstFragment) {
                        this._firstFragment = false;
                        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
                            rsv1 = byteLength >= perMessageDeflate._threshold;
                        }
                        this._compress = rsv1;
                    } else {
                        rsv1 = false;
                        opcode = 0;
                    }
                    if (options.fin) this._firstFragment = true;
                    if (perMessageDeflate) {
                        const opts = {
                            [kByteLength]: byteLength,
                            fin: options.fin,
                            generateMask: this._generateMask,
                            mask: options.mask,
                            maskBuffer: this._maskBuffer,
                            opcode: opcode,
                            readOnly: readOnly,
                            rsv1: rsv1
                        };
                        if (this._deflating) {
                            this.enqueue([ this.dispatch, data, this._compress, opts, cb ]);
                        } else {
                            this.dispatch(data, this._compress, opts, cb);
                        }
                    } else {
                        this.sendFrame(Sender.frame(data, {
                            [kByteLength]: byteLength,
                            fin: options.fin,
                            generateMask: this._generateMask,
                            mask: options.mask,
                            maskBuffer: this._maskBuffer,
                            opcode: opcode,
                            readOnly: readOnly,
                            rsv1: false
                        }), cb);
                    }
                }
                dispatch(data, compress, options, cb) {
                    if (!compress) {
                        this.sendFrame(Sender.frame(data, options), cb);
                        return;
                    }
                    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
                    this._bufferedBytes += options[kByteLength];
                    this._deflating = true;
                    perMessageDeflate.compress(data, options.fin, (_, buf) => {
                        if (this._socket.destroyed) {
                            const err = new Error("The socket was closed while data was being compressed");
                            if (typeof cb === "function") cb(err);
                            for (let i = 0; i < this._queue.length; i++) {
                                const params = this._queue[i];
                                const callback = params[params.length - 1];
                                if (typeof callback === "function") callback(err);
                            }
                            return;
                        }
                        this._bufferedBytes -= options[kByteLength];
                        this._deflating = false;
                        options.readOnly = false;
                        this.sendFrame(Sender.frame(buf, options), cb);
                        this.dequeue();
                    });
                }
                dequeue() {
                    while (!this._deflating && this._queue.length) {
                        const params = this._queue.shift();
                        this._bufferedBytes -= params[3][kByteLength];
                        Reflect.apply(params[0], this, params.slice(1));
                    }
                }
                enqueue(params) {
                    this._bufferedBytes += params[3][kByteLength];
                    this._queue.push(params);
                }
                sendFrame(list, cb) {
                    if (list.length === 2) {
                        this._socket.cork();
                        this._socket.write(list[0]);
                        this._socket.write(list[1], cb);
                        this._socket.uncork();
                    } else {
                        this._socket.write(list[0], cb);
                    }
                }
            }
            module.exports = Sender;
        },
        "./node_modules/ws/lib/stream.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {
                Duplex
            } = __webpack_require__("stream");
            function emitClose(stream) {
                stream.emit("close");
            }
            function duplexOnEnd() {
                if (!this.destroyed && this._writableState.finished) {
                    this.destroy();
                }
            }
            function duplexOnError(err) {
                this.removeListener("error", duplexOnError);
                this.destroy();
                if (this.listenerCount("error") === 0) {
                    this.emit("error", err);
                }
            }
            function createWebSocketStream(ws, options) {
                let terminateOnDestroy = true;
                const duplex = new Duplex({
                    ...options,
                    autoDestroy: false,
                    emitClose: false,
                    objectMode: false,
                    writableObjectMode: false
                });
                ws.on("message", function message(msg, isBinary) {
                    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
                    if (!duplex.push(data)) ws.pause();
                });
                ws.once("error", function error(err) {
                    if (duplex.destroyed) return;
                    terminateOnDestroy = false;
                    duplex.destroy(err);
                });
                ws.once("close", function close() {
                    if (duplex.destroyed) return;
                    duplex.push(null);
                });
                duplex._destroy = function(err, callback) {
                    if (ws.readyState === ws.CLOSED) {
                        callback(err);
                        process.nextTick(emitClose, duplex);
                        return;
                    }
                    let called = false;
                    ws.once("error", function error(err) {
                        called = true;
                        callback(err);
                    });
                    ws.once("close", function close() {
                        if (!called) callback(err);
                        process.nextTick(emitClose, duplex);
                    });
                    if (terminateOnDestroy) ws.terminate();
                };
                duplex._final = function(callback) {
                    if (ws.readyState === ws.CONNECTING) {
                        ws.once("open", function open() {
                            duplex._final(callback);
                        });
                        return;
                    }
                    if (ws._socket === null) return;
                    if (ws._socket._writableState.finished) {
                        callback();
                        if (duplex._readableState.endEmitted) duplex.destroy();
                    } else {
                        ws._socket.once("finish", function finish() {
                            callback();
                        });
                        ws.close();
                    }
                };
                duplex._read = function() {
                    if (ws.isPaused) ws.resume();
                };
                duplex._write = function(chunk, encoding, callback) {
                    if (ws.readyState === ws.CONNECTING) {
                        ws.once("open", function open() {
                            duplex._write(chunk, encoding, callback);
                        });
                        return;
                    }
                    ws.send(chunk, callback);
                };
                duplex.on("end", duplexOnEnd);
                duplex.on("error", duplexOnError);
                return duplex;
            }
            module.exports = createWebSocketStream;
        },
        "./node_modules/ws/lib/subprotocol.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const {
                tokenChars
            } = __webpack_require__("./node_modules/ws/lib/validation.js");
            function parse(header) {
                const protocols = new Set();
                let start = -1;
                let end = -1;
                let i = 0;
                for (i; i < header.length; i++) {
                    const code = header.charCodeAt(i);
                    if (end === -1 && tokenChars[code] === 1) {
                        if (start === -1) start = i;
                    } else if (i !== 0 && (code === 32 || code === 9)) {
                        if (end === -1 && start !== -1) end = i;
                    } else if (code === 44) {
                        if (start === -1) {
                            throw new SyntaxError(`Unexpected character at index ${i}`);
                        }
                        if (end === -1) end = i;
                        const protocol = header.slice(start, end);
                        if (protocols.has(protocol)) {
                            throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
                        }
                        protocols.add(protocol);
                        start = end = -1;
                    } else {
                        throw new SyntaxError(`Unexpected character at index ${i}`);
                    }
                }
                if (start === -1 || end !== -1) {
                    throw new SyntaxError("Unexpected end of input");
                }
                const protocol = header.slice(start, i);
                if (protocols.has(protocol)) {
                    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
                }
                protocols.add(protocol);
                return protocols;
            }
            module.exports = {
                parse: parse
            };
        },
        "./node_modules/ws/lib/validation.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const tokenChars = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 ];
            function isValidStatusCode(code) {
                return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
            }
            function _isValidUTF8(buf) {
                const len = buf.length;
                let i = 0;
                while (i < len) {
                    if ((buf[i] & 128) === 0) {
                        i++;
                    } else if ((buf[i] & 224) === 192) {
                        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
                            return false;
                        }
                        i += 2;
                    } else if ((buf[i] & 240) === 224) {
                        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
                            return false;
                        }
                        i += 3;
                    } else if ((buf[i] & 248) === 240) {
                        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
                            return false;
                        }
                        i += 4;
                    } else {
                        return false;
                    }
                }
                return true;
            }
            try {
                const isValidUTF8 = __webpack_require__("utf-8-validate");
                module.exports = {
                    isValidStatusCode: isValidStatusCode,
                    isValidUTF8(buf) {
                        return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
                    },
                    tokenChars: tokenChars
                };
            } catch (e) {
                module.exports = {
                    isValidStatusCode: isValidStatusCode,
                    isValidUTF8: _isValidUTF8,
                    tokenChars: tokenChars
                };
            }
        },
        "./node_modules/ws/lib/websocket-server.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const EventEmitter = __webpack_require__("events");
            const http = __webpack_require__("http");
            const https = __webpack_require__("https");
            const net = __webpack_require__("net");
            const tls = __webpack_require__("tls");
            const {
                createHash
            } = __webpack_require__("crypto");
            const extension = __webpack_require__("./node_modules/ws/lib/extension.js");
            const PerMessageDeflate = __webpack_require__("./node_modules/ws/lib/permessage-deflate.js");
            const subprotocol = __webpack_require__("./node_modules/ws/lib/subprotocol.js");
            const WebSocket = __webpack_require__("./node_modules/ws/lib/websocket.js");
            const {
                GUID,
                kWebSocket
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            const keyRegex = /^[+/0-9A-Za-z]{22}==$/;
            const RUNNING = 0;
            const CLOSING = 1;
            const CLOSED = 2;
            class WebSocketServer extends EventEmitter {
                constructor(options, callback) {
                    super();
                    options = {
                        maxPayload: 100 * 1024 * 1024,
                        skipUTF8Validation: false,
                        perMessageDeflate: false,
                        handleProtocols: null,
                        clientTracking: true,
                        verifyClient: null,
                        noServer: false,
                        backlog: null,
                        server: null,
                        host: null,
                        path: null,
                        port: null,
                        WebSocket: WebSocket,
                        ...options
                    };
                    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
                        throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + "must be specified");
                    }
                    if (options.port != null) {
                        this._server = http.createServer((req, res) => {
                            const body = http.STATUS_CODES[426];
                            res.writeHead(426, {
                                "Content-Length": body.length,
                                "Content-Type": "text/plain"
                            });
                            res.end(body);
                        });
                        this._server.listen(options.port, options.host, options.backlog, callback);
                    } else if (options.server) {
                        this._server = options.server;
                    }
                    if (this._server) {
                        const emitConnection = this.emit.bind(this, "connection");
                        this._removeListeners = addListeners(this._server, {
                            listening: this.emit.bind(this, "listening"),
                            error: this.emit.bind(this, "error"),
                            upgrade: (req, socket, head) => {
                                this.handleUpgrade(req, socket, head, emitConnection);
                            }
                        });
                    }
                    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
                    if (options.clientTracking) {
                        this.clients = new Set();
                        this._shouldEmitClose = false;
                    }
                    this.options = options;
                    this._state = RUNNING;
                }
                address() {
                    if (this.options.noServer) {
                        throw new Error('The server is operating in "noServer" mode');
                    }
                    if (!this._server) return null;
                    return this._server.address();
                }
                close(cb) {
                    if (this._state === CLOSED) {
                        if (cb) {
                            this.once("close", () => {
                                cb(new Error("The server is not running"));
                            });
                        }
                        process.nextTick(emitClose, this);
                        return;
                    }
                    if (cb) this.once("close", cb);
                    if (this._state === CLOSING) return;
                    this._state = CLOSING;
                    if (this.options.noServer || this.options.server) {
                        if (this._server) {
                            this._removeListeners();
                            this._removeListeners = this._server = null;
                        }
                        if (this.clients) {
                            if (!this.clients.size) {
                                process.nextTick(emitClose, this);
                            } else {
                                this._shouldEmitClose = true;
                            }
                        } else {
                            process.nextTick(emitClose, this);
                        }
                    } else {
                        const server = this._server;
                        this._removeListeners();
                        this._removeListeners = this._server = null;
                        server.close(() => {
                            emitClose(this);
                        });
                    }
                }
                shouldHandle(req) {
                    if (this.options.path) {
                        const index = req.url.indexOf("?");
                        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
                        if (pathname !== this.options.path) return false;
                    }
                    return true;
                }
                handleUpgrade(req, socket, head, cb) {
                    socket.on("error", socketOnError);
                    const key = req.headers["sec-websocket-key"] !== undefined ? req.headers["sec-websocket-key"] : false;
                    const version = +req.headers["sec-websocket-version"];
                    if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
                        return abortHandshake(socket, 400);
                    }
                    const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
                    let protocols = new Set();
                    if (secWebSocketProtocol !== undefined) {
                        try {
                            protocols = subprotocol.parse(secWebSocketProtocol);
                        } catch (err) {
                            return abortHandshake(socket, 400);
                        }
                    }
                    const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
                    const extensions = {};
                    if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
                        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
                        try {
                            const offers = extension.parse(secWebSocketExtensions);
                            if (offers[PerMessageDeflate.extensionName]) {
                                perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
                                extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                            }
                        } catch (err) {
                            return abortHandshake(socket, 400);
                        }
                    }
                    if (this.options.verifyClient) {
                        const info = {
                            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
                            secure: !!(req.socket.authorized || req.socket.encrypted),
                            req: req
                        };
                        if (this.options.verifyClient.length === 2) {
                            this.options.verifyClient(info, (verified, code, message, headers) => {
                                if (!verified) {
                                    return abortHandshake(socket, code || 401, message, headers);
                                }
                                this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                            });
                            return;
                        }
                        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
                    }
                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
                }
                completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
                    if (!socket.readable || !socket.writable) return socket.destroy();
                    if (socket[kWebSocket]) {
                        throw new Error("server.handleUpgrade() was called more than once with the same " + "socket, possibly due to a misconfiguration");
                    }
                    if (this._state > RUNNING) return abortHandshake(socket, 503);
                    const digest = createHash("sha1").update(key + GUID).digest("base64");
                    const headers = [ "HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", `Sec-WebSocket-Accept: ${digest}` ];
                    const ws = new this.options.WebSocket(null);
                    if (protocols.size) {
                        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
                        if (protocol) {
                            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
                            ws._protocol = protocol;
                        }
                    }
                    if (extensions[PerMessageDeflate.extensionName]) {
                        const params = extensions[PerMessageDeflate.extensionName].params;
                        const value = extension.format({
                            [PerMessageDeflate.extensionName]: [ params ]
                        });
                        headers.push(`Sec-WebSocket-Extensions: ${value}`);
                        ws._extensions = extensions;
                    }
                    this.emit("headers", headers, req);
                    socket.write(headers.concat("\r\n").join("\r\n"));
                    socket.removeListener("error", socketOnError);
                    ws.setSocket(socket, head, {
                        maxPayload: this.options.maxPayload,
                        skipUTF8Validation: this.options.skipUTF8Validation
                    });
                    if (this.clients) {
                        this.clients.add(ws);
                        ws.on("close", () => {
                            this.clients.delete(ws);
                            if (this._shouldEmitClose && !this.clients.size) {
                                process.nextTick(emitClose, this);
                            }
                        });
                    }
                    cb(ws, req);
                }
            }
            module.exports = WebSocketServer;
            function addListeners(server, map) {
                for (const event of Object.keys(map)) server.on(event, map[event]);
                return function removeListeners() {
                    for (const event of Object.keys(map)) {
                        server.removeListener(event, map[event]);
                    }
                };
            }
            function emitClose(server) {
                server._state = CLOSED;
                server.emit("close");
            }
            function socketOnError() {
                this.destroy();
            }
            function abortHandshake(socket, code, message, headers) {
                if (socket.writable) {
                    message = message || http.STATUS_CODES[code];
                    headers = {
                        Connection: "close",
                        "Content-Type": "text/html",
                        "Content-Length": Buffer.byteLength(message),
                        ...headers
                    };
                    socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
                }
                socket.removeListener("error", socketOnError);
                socket.destroy();
            }
        },
        "./node_modules/ws/lib/websocket.js": (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            const EventEmitter = __webpack_require__("events");
            const https = __webpack_require__("https");
            const http = __webpack_require__("http");
            const net = __webpack_require__("net");
            const tls = __webpack_require__("tls");
            const {
                randomBytes,
                createHash
            } = __webpack_require__("crypto");
            const {
                Readable
            } = __webpack_require__("stream");
            const {
                URL
            } = __webpack_require__("url");
            const PerMessageDeflate = __webpack_require__("./node_modules/ws/lib/permessage-deflate.js");
            const Receiver = __webpack_require__("./node_modules/ws/lib/receiver.js");
            const Sender = __webpack_require__("./node_modules/ws/lib/sender.js");
            const {
                BINARY_TYPES,
                EMPTY_BUFFER,
                GUID,
                kForOnEventAttribute,
                kListener,
                kStatusCode,
                kWebSocket,
                NOOP
            } = __webpack_require__("./node_modules/ws/lib/constants.js");
            const {
                EventTarget: {
                    addEventListener,
                    removeEventListener
                }
            } = __webpack_require__("./node_modules/ws/lib/event-target.js");
            const {
                format,
                parse
            } = __webpack_require__("./node_modules/ws/lib/extension.js");
            const {
                toBuffer
            } = __webpack_require__("./node_modules/ws/lib/buffer-util.js");
            const readyStates = [ "CONNECTING", "OPEN", "CLOSING", "CLOSED" ];
            const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
            const protocolVersions = [ 8, 13 ];
            const closeTimeout = 30 * 1e3;
            class WebSocket extends EventEmitter {
                constructor(address, protocols, options) {
                    super();
                    this._binaryType = BINARY_TYPES[0];
                    this._closeCode = 1006;
                    this._closeFrameReceived = false;
                    this._closeFrameSent = false;
                    this._closeMessage = EMPTY_BUFFER;
                    this._closeTimer = null;
                    this._extensions = {};
                    this._paused = false;
                    this._protocol = "";
                    this._readyState = WebSocket.CONNECTING;
                    this._receiver = null;
                    this._sender = null;
                    this._socket = null;
                    if (address !== null) {
                        this._bufferedAmount = 0;
                        this._isServer = false;
                        this._redirects = 0;
                        if (protocols === undefined) {
                            protocols = [];
                        } else if (!Array.isArray(protocols)) {
                            if (typeof protocols === "object" && protocols !== null) {
                                options = protocols;
                                protocols = [];
                            } else {
                                protocols = [ protocols ];
                            }
                        }
                        initAsClient(this, address, protocols, options);
                    } else {
                        this._isServer = true;
                    }
                }
                get binaryType() {
                    return this._binaryType;
                }
                set binaryType(type) {
                    if (!BINARY_TYPES.includes(type)) return;
                    this._binaryType = type;
                    if (this._receiver) this._receiver._binaryType = type;
                }
                get bufferedAmount() {
                    if (!this._socket) return this._bufferedAmount;
                    return this._socket._writableState.length + this._sender._bufferedBytes;
                }
                get extensions() {
                    return Object.keys(this._extensions).join();
                }
                get isPaused() {
                    return this._paused;
                }
                get onclose() {
                    return null;
                }
                get onerror() {
                    return null;
                }
                get onopen() {
                    return null;
                }
                get onmessage() {
                    return null;
                }
                get protocol() {
                    return this._protocol;
                }
                get readyState() {
                    return this._readyState;
                }
                get url() {
                    return this._url;
                }
                setSocket(socket, head, options) {
                    const receiver = new Receiver({
                        binaryType: this.binaryType,
                        extensions: this._extensions,
                        isServer: this._isServer,
                        maxPayload: options.maxPayload,
                        skipUTF8Validation: options.skipUTF8Validation
                    });
                    this._sender = new Sender(socket, this._extensions, options.generateMask);
                    this._receiver = receiver;
                    this._socket = socket;
                    receiver[kWebSocket] = this;
                    socket[kWebSocket] = this;
                    receiver.on("conclude", receiverOnConclude);
                    receiver.on("drain", receiverOnDrain);
                    receiver.on("error", receiverOnError);
                    receiver.on("message", receiverOnMessage);
                    receiver.on("ping", receiverOnPing);
                    receiver.on("pong", receiverOnPong);
                    socket.setTimeout(0);
                    socket.setNoDelay();
                    if (head.length > 0) socket.unshift(head);
                    socket.on("close", socketOnClose);
                    socket.on("data", socketOnData);
                    socket.on("end", socketOnEnd);
                    socket.on("error", socketOnError);
                    this._readyState = WebSocket.OPEN;
                    this.emit("open");
                }
                emitClose() {
                    if (!this._socket) {
                        this._readyState = WebSocket.CLOSED;
                        this.emit("close", this._closeCode, this._closeMessage);
                        return;
                    }
                    if (this._extensions[PerMessageDeflate.extensionName]) {
                        this._extensions[PerMessageDeflate.extensionName].cleanup();
                    }
                    this._receiver.removeAllListeners();
                    this._readyState = WebSocket.CLOSED;
                    this.emit("close", this._closeCode, this._closeMessage);
                }
                close(code, data) {
                    if (this.readyState === WebSocket.CLOSED) return;
                    if (this.readyState === WebSocket.CONNECTING) {
                        const msg = "WebSocket was closed before the connection was established";
                        return abortHandshake(this, this._req, msg);
                    }
                    if (this.readyState === WebSocket.CLOSING) {
                        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
                            this._socket.end();
                        }
                        return;
                    }
                    this._readyState = WebSocket.CLOSING;
                    this._sender.close(code, data, !this._isServer, err => {
                        if (err) return;
                        this._closeFrameSent = true;
                        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
                            this._socket.end();
                        }
                    });
                    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
                }
                pause() {
                    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
                        return;
                    }
                    this._paused = true;
                    this._socket.pause();
                }
                ping(data, mask, cb) {
                    if (this.readyState === WebSocket.CONNECTING) {
                        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
                    }
                    if (typeof data === "function") {
                        cb = data;
                        data = mask = undefined;
                    } else if (typeof mask === "function") {
                        cb = mask;
                        mask = undefined;
                    }
                    if (typeof data === "number") data = data.toString();
                    if (this.readyState !== WebSocket.OPEN) {
                        sendAfterClose(this, data, cb);
                        return;
                    }
                    if (mask === undefined) mask = !this._isServer;
                    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
                }
                pong(data, mask, cb) {
                    if (this.readyState === WebSocket.CONNECTING) {
                        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
                    }
                    if (typeof data === "function") {
                        cb = data;
                        data = mask = undefined;
                    } else if (typeof mask === "function") {
                        cb = mask;
                        mask = undefined;
                    }
                    if (typeof data === "number") data = data.toString();
                    if (this.readyState !== WebSocket.OPEN) {
                        sendAfterClose(this, data, cb);
                        return;
                    }
                    if (mask === undefined) mask = !this._isServer;
                    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
                }
                resume() {
                    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
                        return;
                    }
                    this._paused = false;
                    if (!this._receiver._writableState.needDrain) this._socket.resume();
                }
                send(data, options, cb) {
                    if (this.readyState === WebSocket.CONNECTING) {
                        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
                    }
                    if (typeof options === "function") {
                        cb = options;
                        options = {};
                    }
                    if (typeof data === "number") data = data.toString();
                    if (this.readyState !== WebSocket.OPEN) {
                        sendAfterClose(this, data, cb);
                        return;
                    }
                    const opts = {
                        binary: typeof data !== "string",
                        mask: !this._isServer,
                        compress: true,
                        fin: true,
                        ...options
                    };
                    if (!this._extensions[PerMessageDeflate.extensionName]) {
                        opts.compress = false;
                    }
                    this._sender.send(data || EMPTY_BUFFER, opts, cb);
                }
                terminate() {
                    if (this.readyState === WebSocket.CLOSED) return;
                    if (this.readyState === WebSocket.CONNECTING) {
                        const msg = "WebSocket was closed before the connection was established";
                        return abortHandshake(this, this._req, msg);
                    }
                    if (this._socket) {
                        this._readyState = WebSocket.CLOSING;
                        this._socket.destroy();
                    }
                }
            }
            Object.defineProperty(WebSocket, "CONNECTING", {
                enumerable: true,
                value: readyStates.indexOf("CONNECTING")
            });
            Object.defineProperty(WebSocket.prototype, "CONNECTING", {
                enumerable: true,
                value: readyStates.indexOf("CONNECTING")
            });
            Object.defineProperty(WebSocket, "OPEN", {
                enumerable: true,
                value: readyStates.indexOf("OPEN")
            });
            Object.defineProperty(WebSocket.prototype, "OPEN", {
                enumerable: true,
                value: readyStates.indexOf("OPEN")
            });
            Object.defineProperty(WebSocket, "CLOSING", {
                enumerable: true,
                value: readyStates.indexOf("CLOSING")
            });
            Object.defineProperty(WebSocket.prototype, "CLOSING", {
                enumerable: true,
                value: readyStates.indexOf("CLOSING")
            });
            Object.defineProperty(WebSocket, "CLOSED", {
                enumerable: true,
                value: readyStates.indexOf("CLOSED")
            });
            Object.defineProperty(WebSocket.prototype, "CLOSED", {
                enumerable: true,
                value: readyStates.indexOf("CLOSED")
            });
            [ "binaryType", "bufferedAmount", "extensions", "isPaused", "protocol", "readyState", "url" ].forEach(property => {
                Object.defineProperty(WebSocket.prototype, property, {
                    enumerable: true
                });
            });
            [ "open", "error", "close", "message" ].forEach(method => {
                Object.defineProperty(WebSocket.prototype, `on${method}`, {
                    enumerable: true,
                    get() {
                        for (const listener of this.listeners(method)) {
                            if (listener[kForOnEventAttribute]) return listener[kListener];
                        }
                        return null;
                    },
                    set(handler) {
                        for (const listener of this.listeners(method)) {
                            if (listener[kForOnEventAttribute]) {
                                this.removeListener(method, listener);
                                break;
                            }
                        }
                        if (typeof handler !== "function") return;
                        this.addEventListener(method, handler, {
                            [kForOnEventAttribute]: true
                        });
                    }
                });
            });
            WebSocket.prototype.addEventListener = addEventListener;
            WebSocket.prototype.removeEventListener = removeEventListener;
            module.exports = WebSocket;
            function initAsClient(websocket, address, protocols, options) {
                const opts = {
                    protocolVersion: protocolVersions[1],
                    maxPayload: 100 * 1024 * 1024,
                    skipUTF8Validation: false,
                    perMessageDeflate: true,
                    followRedirects: false,
                    maxRedirects: 10,
                    ...options,
                    createConnection: undefined,
                    socketPath: undefined,
                    hostname: undefined,
                    protocol: undefined,
                    timeout: undefined,
                    method: undefined,
                    host: undefined,
                    path: undefined,
                    port: undefined
                };
                if (!protocolVersions.includes(opts.protocolVersion)) {
                    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
                }
                let parsedUrl;
                if (address instanceof URL) {
                    parsedUrl = address;
                    websocket._url = address.href;
                } else {
                    try {
                        parsedUrl = new URL(address);
                    } catch (e) {
                        throw new SyntaxError(`Invalid URL: ${address}`);
                    }
                    websocket._url = address;
                }
                const isSecure = parsedUrl.protocol === "wss:";
                const isUnixSocket = parsedUrl.protocol === "ws+unix:";
                let invalidURLMessage;
                if (parsedUrl.protocol !== "ws:" && !isSecure && !isUnixSocket) {
                    invalidURLMessage = 'The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"';
                } else if (isUnixSocket && !parsedUrl.pathname) {
                    invalidURLMessage = "The URL's pathname is empty";
                } else if (parsedUrl.hash) {
                    invalidURLMessage = "The URL contains a fragment identifier";
                }
                if (invalidURLMessage) {
                    const err = new SyntaxError(invalidURLMessage);
                    if (websocket._redirects === 0) {
                        throw err;
                    } else {
                        emitErrorAndClose(websocket, err);
                        return;
                    }
                }
                const defaultPort = isSecure ? 443 : 80;
                const key = randomBytes(16).toString("base64");
                const get = isSecure ? https.get : http.get;
                const protocolSet = new Set();
                let perMessageDeflate;
                opts.createConnection = isSecure ? tlsConnect : netConnect;
                opts.defaultPort = opts.defaultPort || defaultPort;
                opts.port = parsedUrl.port || defaultPort;
                opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
                opts.headers = {
                    "Sec-WebSocket-Version": opts.protocolVersion,
                    "Sec-WebSocket-Key": key,
                    Connection: "Upgrade",
                    Upgrade: "websocket",
                    ...opts.headers
                };
                opts.path = parsedUrl.pathname + parsedUrl.search;
                opts.timeout = opts.handshakeTimeout;
                if (opts.perMessageDeflate) {
                    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
                    opts.headers["Sec-WebSocket-Extensions"] = format({
                        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
                    });
                }
                if (protocols.length) {
                    for (const protocol of protocols) {
                        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
                            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
                        }
                        protocolSet.add(protocol);
                    }
                    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
                }
                if (opts.origin) {
                    if (opts.protocolVersion < 13) {
                        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
                    } else {
                        opts.headers.Origin = opts.origin;
                    }
                }
                if (parsedUrl.username || parsedUrl.password) {
                    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
                }
                if (isUnixSocket) {
                    const parts = opts.path.split(":");
                    opts.socketPath = parts[0];
                    opts.path = parts[1];
                }
                if (opts.followRedirects) {
                    if (websocket._redirects === 0) {
                        websocket._originalHost = parsedUrl.host;
                        const headers = options && options.headers;
                        options = {
                            ...options,
                            headers: {}
                        };
                        if (headers) {
                            for (const [ key, value ] of Object.entries(headers)) {
                                options.headers[key.toLowerCase()] = value;
                            }
                        }
                    } else if (parsedUrl.host !== websocket._originalHost) {
                        delete opts.headers.authorization;
                        delete opts.headers.cookie;
                        delete opts.headers.host;
                        opts.auth = undefined;
                    }
                    if (opts.auth && !options.headers.authorization) {
                        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
                    }
                }
                let req = websocket._req = get(opts);
                if (opts.timeout) {
                    req.on("timeout", () => {
                        abortHandshake(websocket, req, "Opening handshake has timed out");
                    });
                }
                req.on("error", err => {
                    if (req === null || req.aborted) return;
                    req = websocket._req = null;
                    emitErrorAndClose(websocket, err);
                });
                req.on("response", res => {
                    const location = res.headers.location;
                    const statusCode = res.statusCode;
                    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
                        if (++websocket._redirects > opts.maxRedirects) {
                            abortHandshake(websocket, req, "Maximum redirects exceeded");
                            return;
                        }
                        req.abort();
                        let addr;
                        try {
                            addr = new URL(location, address);
                        } catch (e) {
                            const err = new SyntaxError(`Invalid URL: ${location}`);
                            emitErrorAndClose(websocket, err);
                            return;
                        }
                        initAsClient(websocket, addr, protocols, options);
                    } else if (!websocket.emit("unexpected-response", req, res)) {
                        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
                    }
                });
                req.on("upgrade", (res, socket, head) => {
                    websocket.emit("upgrade", res);
                    if (websocket.readyState !== WebSocket.CONNECTING) return;
                    req = websocket._req = null;
                    const digest = createHash("sha1").update(key + GUID).digest("base64");
                    if (res.headers["sec-websocket-accept"] !== digest) {
                        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
                        return;
                    }
                    const serverProt = res.headers["sec-websocket-protocol"];
                    let protError;
                    if (serverProt !== undefined) {
                        if (!protocolSet.size) {
                            protError = "Server sent a subprotocol but none was requested";
                        } else if (!protocolSet.has(serverProt)) {
                            protError = "Server sent an invalid subprotocol";
                        }
                    } else if (protocolSet.size) {
                        protError = "Server sent no subprotocol";
                    }
                    if (protError) {
                        abortHandshake(websocket, socket, protError);
                        return;
                    }
                    if (serverProt) websocket._protocol = serverProt;
                    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
                    if (secWebSocketExtensions !== undefined) {
                        if (!perMessageDeflate) {
                            const message = "Server sent a Sec-WebSocket-Extensions header but no extension " + "was requested";
                            abortHandshake(websocket, socket, message);
                            return;
                        }
                        let extensions;
                        try {
                            extensions = parse(secWebSocketExtensions);
                        } catch (err) {
                            const message = "Invalid Sec-WebSocket-Extensions header";
                            abortHandshake(websocket, socket, message);
                            return;
                        }
                        const extensionNames = Object.keys(extensions);
                        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
                            const message = "Server indicated an extension that was not requested";
                            abortHandshake(websocket, socket, message);
                            return;
                        }
                        try {
                            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
                        } catch (err) {
                            const message = "Invalid Sec-WebSocket-Extensions header";
                            abortHandshake(websocket, socket, message);
                            return;
                        }
                        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
                    }
                    websocket.setSocket(socket, head, {
                        generateMask: opts.generateMask,
                        maxPayload: opts.maxPayload,
                        skipUTF8Validation: opts.skipUTF8Validation
                    });
                });
            }
            function emitErrorAndClose(websocket, err) {
                websocket._readyState = WebSocket.CLOSING;
                websocket.emit("error", err);
                websocket.emitClose();
            }
            function netConnect(options) {
                options.path = options.socketPath;
                return net.connect(options);
            }
            function tlsConnect(options) {
                options.path = undefined;
                if (!options.servername && options.servername !== "") {
                    options.servername = net.isIP(options.host) ? "" : options.host;
                }
                return tls.connect(options);
            }
            function abortHandshake(websocket, stream, message) {
                websocket._readyState = WebSocket.CLOSING;
                const err = new Error(message);
                Error.captureStackTrace(err, abortHandshake);
                if (stream.setHeader) {
                    stream.abort();
                    if (stream.socket && !stream.socket.destroyed) {
                        stream.socket.destroy();
                    }
                    stream.once("abort", websocket.emitClose.bind(websocket));
                    websocket.emit("error", err);
                } else {
                    stream.destroy(err);
                    stream.once("error", websocket.emit.bind(websocket, "error"));
                    stream.once("close", websocket.emitClose.bind(websocket));
                }
            }
            function sendAfterClose(websocket, data, cb) {
                if (data) {
                    const length = toBuffer(data).length;
                    if (websocket._socket) websocket._sender._bufferedBytes += length; else websocket._bufferedAmount += length;
                }
                if (cb) {
                    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
                    cb(err);
                }
            }
            function receiverOnConclude(code, reason) {
                const websocket = this[kWebSocket];
                websocket._closeFrameReceived = true;
                websocket._closeMessage = reason;
                websocket._closeCode = code;
                if (websocket._socket[kWebSocket] === undefined) return;
                websocket._socket.removeListener("data", socketOnData);
                process.nextTick(resume, websocket._socket);
                if (code === 1005) websocket.close(); else websocket.close(code, reason);
            }
            function receiverOnDrain() {
                const websocket = this[kWebSocket];
                if (!websocket.isPaused) websocket._socket.resume();
            }
            function receiverOnError(err) {
                const websocket = this[kWebSocket];
                if (websocket._socket[kWebSocket] !== undefined) {
                    websocket._socket.removeListener("data", socketOnData);
                    process.nextTick(resume, websocket._socket);
                    websocket.close(err[kStatusCode]);
                }
                websocket.emit("error", err);
            }
            function receiverOnFinish() {
                this[kWebSocket].emitClose();
            }
            function receiverOnMessage(data, isBinary) {
                this[kWebSocket].emit("message", data, isBinary);
            }
            function receiverOnPing(data) {
                const websocket = this[kWebSocket];
                websocket.pong(data, !websocket._isServer, NOOP);
                websocket.emit("ping", data);
            }
            function receiverOnPong(data) {
                this[kWebSocket].emit("pong", data);
            }
            function resume(stream) {
                stream.resume();
            }
            function socketOnClose() {
                const websocket = this[kWebSocket];
                this.removeListener("close", socketOnClose);
                this.removeListener("data", socketOnData);
                this.removeListener("end", socketOnEnd);
                websocket._readyState = WebSocket.CLOSING;
                let chunk;
                if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
                    websocket._receiver.write(chunk);
                }
                websocket._receiver.end();
                this[kWebSocket] = undefined;
                clearTimeout(websocket._closeTimer);
                if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
                    websocket.emitClose();
                } else {
                    websocket._receiver.on("error", receiverOnFinish);
                    websocket._receiver.on("finish", receiverOnFinish);
                }
            }
            function socketOnData(chunk) {
                if (!this[kWebSocket]._receiver.write(chunk)) {
                    this.pause();
                }
            }
            function socketOnEnd() {
                const websocket = this[kWebSocket];
                websocket._readyState = WebSocket.CLOSING;
                websocket._receiver.end();
                this.end();
            }
            function socketOnError() {
                const websocket = this[kWebSocket];
                this.removeListener("error", socketOnError);
                this.on("error", NOOP);
                if (websocket) {
                    websocket._readyState = WebSocket.CLOSING;
                    this.destroy();
                }
            }
        },
        bufferutil: module => {
            "use strict";
            module.exports = require("bufferutil");
        },
        "utf-8-validate": module => {
            "use strict";
            module.exports = require("utf-8-validate");
        },
        buffer: module => {
            "use strict";
            module.exports = require("buffer");
        },
        constants: module => {
            "use strict";
            module.exports = require("constants");
        },
        crypto: module => {
            "use strict";
            module.exports = require("crypto");
        },
        dns: module => {
            "use strict";
            module.exports = require("dns");
        },
        events: module => {
            "use strict";
            module.exports = require("events");
        },
        fs: module => {
            "use strict";
            module.exports = require("fs");
        },
        http: module => {
            "use strict";
            module.exports = require("http");
        },
        https: module => {
            "use strict";
            module.exports = require("https");
        },
        net: module => {
            "use strict";
            module.exports = require("net");
        },
        os: module => {
            "use strict";
            module.exports = require("os");
        },
        stream: module => {
            "use strict";
            module.exports = require("stream");
        },
        tls: module => {
            "use strict";
            module.exports = require("tls");
        },
        url: module => {
            "use strict";
            module.exports = require("url");
        },
        util: module => {
            "use strict";
            module.exports = require("util");
        },
        zlib: module => {
            "use strict";
            module.exports = require("zlib");
        },
        "./node_modules/long/umd/index.js": (module, exports) => {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            var Long = function(exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: true
                });
                exports.default = void 0;
                var wasm = null;
                try {
                    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11 ])), {}).exports;
                } catch (e) {}
                function Long(low, high, unsigned) {
                    this.low = low | 0;
                    this.high = high | 0;
                    this.unsigned = !!unsigned;
                }
                Long.prototype.__isLong__;
                Object.defineProperty(Long.prototype, "__isLong__", {
                    value: true
                });
                function isLong(obj) {
                    return (obj && obj["__isLong__"]) === true;
                }
                function ctz32(value) {
                    var c = Math.clz32(value & -value);
                    return value ? 31 - c : c;
                }
                Long.isLong = isLong;
                var INT_CACHE = {};
                var UINT_CACHE = {};
                function fromInt(value, unsigned) {
                    var obj, cachedObj, cache;
                    if (unsigned) {
                        value >>>= 0;
                        if (cache = 0 <= value && value < 256) {
                            cachedObj = UINT_CACHE[value];
                            if (cachedObj) return cachedObj;
                        }
                        obj = fromBits(value, 0, true);
                        if (cache) UINT_CACHE[value] = obj;
                        return obj;
                    } else {
                        value |= 0;
                        if (cache = -128 <= value && value < 128) {
                            cachedObj = INT_CACHE[value];
                            if (cachedObj) return cachedObj;
                        }
                        obj = fromBits(value, value < 0 ? -1 : 0, false);
                        if (cache) INT_CACHE[value] = obj;
                        return obj;
                    }
                }
                Long.fromInt = fromInt;
                function fromNumber(value, unsigned) {
                    if (isNaN(value)) return unsigned ? UZERO : ZERO;
                    if (unsigned) {
                        if (value < 0) return UZERO;
                        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
                    } else {
                        if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
                        if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
                    }
                    if (value < 0) return fromNumber(-value, unsigned).neg();
                    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
                }
                Long.fromNumber = fromNumber;
                function fromBits(lowBits, highBits, unsigned) {
                    return new Long(lowBits, highBits, unsigned);
                }
                Long.fromBits = fromBits;
                var pow_dbl = Math.pow;
                function fromString(str, unsigned, radix) {
                    if (str.length === 0) throw Error("empty string");
                    if (typeof unsigned === "number") {
                        radix = unsigned;
                        unsigned = false;
                    } else {
                        unsigned = !!unsigned;
                    }
                    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
                    radix = radix || 10;
                    if (radix < 2 || 36 < radix) throw RangeError("radix");
                    var p;
                    if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen"); else if (p === 0) {
                        return fromString(str.substring(1), unsigned, radix).neg();
                    }
                    var radixToPower = fromNumber(pow_dbl(radix, 8));
                    var result = ZERO;
                    for (var i = 0; i < str.length; i += 8) {
                        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
                        if (size < 8) {
                            var power = fromNumber(pow_dbl(radix, size));
                            result = result.mul(power).add(fromNumber(value));
                        } else {
                            result = result.mul(radixToPower);
                            result = result.add(fromNumber(value));
                        }
                    }
                    result.unsigned = unsigned;
                    return result;
                }
                Long.fromString = fromString;
                function fromValue(val, unsigned) {
                    if (typeof val === "number") return fromNumber(val, unsigned);
                    if (typeof val === "string") return fromString(val, unsigned);
                    return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
                }
                Long.fromValue = fromValue;
                var TWO_PWR_16_DBL = 1 << 16;
                var TWO_PWR_24_DBL = 1 << 24;
                var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
                var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
                var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
                var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
                var ZERO = fromInt(0);
                Long.ZERO = ZERO;
                var UZERO = fromInt(0, true);
                Long.UZERO = UZERO;
                var ONE = fromInt(1);
                Long.ONE = ONE;
                var UONE = fromInt(1, true);
                Long.UONE = UONE;
                var NEG_ONE = fromInt(-1);
                Long.NEG_ONE = NEG_ONE;
                var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
                Long.MAX_VALUE = MAX_VALUE;
                var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
                Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
                var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
                Long.MIN_VALUE = MIN_VALUE;
                var LongPrototype = Long.prototype;
                LongPrototype.toInt = function toInt() {
                    return this.unsigned ? this.low >>> 0 : this.low;
                };
                LongPrototype.toNumber = function toNumber() {
                    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
                    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
                };
                LongPrototype.toString = function toString(radix) {
                    radix = radix || 10;
                    if (radix < 2 || 36 < radix) throw RangeError("radix");
                    if (this.isZero()) return "0";
                    if (this.isNegative()) {
                        if (this.eq(MIN_VALUE)) {
                            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
                            return div.toString(radix) + rem1.toInt().toString(radix);
                        } else return "-" + this.neg().toString(radix);
                    }
                    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
                    var result = "";
                    while (true) {
                        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
                        rem = remDiv;
                        if (rem.isZero()) return digits + result; else {
                            while (digits.length < 6) digits = "0" + digits;
                            result = "" + digits + result;
                        }
                    }
                };
                LongPrototype.getHighBits = function getHighBits() {
                    return this.high;
                };
                LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
                    return this.high >>> 0;
                };
                LongPrototype.getLowBits = function getLowBits() {
                    return this.low;
                };
                LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
                    return this.low >>> 0;
                };
                LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
                    if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
                    var val = this.high != 0 ? this.high : this.low;
                    for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
                    return this.high != 0 ? bit + 33 : bit + 1;
                };
                LongPrototype.isZero = function isZero() {
                    return this.high === 0 && this.low === 0;
                };
                LongPrototype.eqz = LongPrototype.isZero;
                LongPrototype.isNegative = function isNegative() {
                    return !this.unsigned && this.high < 0;
                };
                LongPrototype.isPositive = function isPositive() {
                    return this.unsigned || this.high >= 0;
                };
                LongPrototype.isOdd = function isOdd() {
                    return (this.low & 1) === 1;
                };
                LongPrototype.isEven = function isEven() {
                    return (this.low & 1) === 0;
                };
                LongPrototype.equals = function equals(other) {
                    if (!isLong(other)) other = fromValue(other);
                    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
                    return this.high === other.high && this.low === other.low;
                };
                LongPrototype.eq = LongPrototype.equals;
                LongPrototype.notEquals = function notEquals(other) {
                    return !this.eq(other);
                };
                LongPrototype.neq = LongPrototype.notEquals;
                LongPrototype.ne = LongPrototype.notEquals;
                LongPrototype.lessThan = function lessThan(other) {
                    return this.comp(other) < 0;
                };
                LongPrototype.lt = LongPrototype.lessThan;
                LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
                    return this.comp(other) <= 0;
                };
                LongPrototype.lte = LongPrototype.lessThanOrEqual;
                LongPrototype.le = LongPrototype.lessThanOrEqual;
                LongPrototype.greaterThan = function greaterThan(other) {
                    return this.comp(other) > 0;
                };
                LongPrototype.gt = LongPrototype.greaterThan;
                LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
                    return this.comp(other) >= 0;
                };
                LongPrototype.gte = LongPrototype.greaterThanOrEqual;
                LongPrototype.ge = LongPrototype.greaterThanOrEqual;
                LongPrototype.compare = function compare(other) {
                    if (!isLong(other)) other = fromValue(other);
                    if (this.eq(other)) return 0;
                    var thisNeg = this.isNegative(), otherNeg = other.isNegative();
                    if (thisNeg && !otherNeg) return -1;
                    if (!thisNeg && otherNeg) return 1;
                    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
                    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
                };
                LongPrototype.comp = LongPrototype.compare;
                LongPrototype.negate = function negate() {
                    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
                    return this.not().add(ONE);
                };
                LongPrototype.neg = LongPrototype.negate;
                LongPrototype.add = function add(addend) {
                    if (!isLong(addend)) addend = fromValue(addend);
                    var a48 = this.high >>> 16;
                    var a32 = this.high & 65535;
                    var a16 = this.low >>> 16;
                    var a00 = this.low & 65535;
                    var b48 = addend.high >>> 16;
                    var b32 = addend.high & 65535;
                    var b16 = addend.low >>> 16;
                    var b00 = addend.low & 65535;
                    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                    c00 += a00 + b00;
                    c16 += c00 >>> 16;
                    c00 &= 65535;
                    c16 += a16 + b16;
                    c32 += c16 >>> 16;
                    c16 &= 65535;
                    c32 += a32 + b32;
                    c48 += c32 >>> 16;
                    c32 &= 65535;
                    c48 += a48 + b48;
                    c48 &= 65535;
                    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
                };
                LongPrototype.subtract = function subtract(subtrahend) {
                    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
                    return this.add(subtrahend.neg());
                };
                LongPrototype.sub = LongPrototype.subtract;
                LongPrototype.multiply = function multiply(multiplier) {
                    if (this.isZero()) return this;
                    if (!isLong(multiplier)) multiplier = fromValue(multiplier);
                    if (wasm) {
                        var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
                        return fromBits(low, wasm["get_high"](), this.unsigned);
                    }
                    if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
                    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
                    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
                    if (this.isNegative()) {
                        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg()); else return this.neg().mul(multiplier).neg();
                    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
                    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
                    var a48 = this.high >>> 16;
                    var a32 = this.high & 65535;
                    var a16 = this.low >>> 16;
                    var a00 = this.low & 65535;
                    var b48 = multiplier.high >>> 16;
                    var b32 = multiplier.high & 65535;
                    var b16 = multiplier.low >>> 16;
                    var b00 = multiplier.low & 65535;
                    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
                    c00 += a00 * b00;
                    c16 += c00 >>> 16;
                    c00 &= 65535;
                    c16 += a16 * b00;
                    c32 += c16 >>> 16;
                    c16 &= 65535;
                    c16 += a00 * b16;
                    c32 += c16 >>> 16;
                    c16 &= 65535;
                    c32 += a32 * b00;
                    c48 += c32 >>> 16;
                    c32 &= 65535;
                    c32 += a16 * b16;
                    c48 += c32 >>> 16;
                    c32 &= 65535;
                    c32 += a00 * b32;
                    c48 += c32 >>> 16;
                    c32 &= 65535;
                    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
                    c48 &= 65535;
                    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
                };
                LongPrototype.mul = LongPrototype.multiply;
                LongPrototype.divide = function divide(divisor) {
                    if (!isLong(divisor)) divisor = fromValue(divisor);
                    if (divisor.isZero()) throw Error("division by zero");
                    if (wasm) {
                        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
                            return this;
                        }
                        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
                        return fromBits(low, wasm["get_high"](), this.unsigned);
                    }
                    if (this.isZero()) return this.unsigned ? UZERO : ZERO;
                    var approx, rem, res;
                    if (!this.unsigned) {
                        if (this.eq(MIN_VALUE)) {
                            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; else if (divisor.eq(MIN_VALUE)) return ONE; else {
                                var halfThis = this.shr(1);
                                approx = halfThis.div(divisor).shl(1);
                                if (approx.eq(ZERO)) {
                                    return divisor.isNegative() ? ONE : NEG_ONE;
                                } else {
                                    rem = this.sub(divisor.mul(approx));
                                    res = approx.add(rem.div(divisor));
                                    return res;
                                }
                            }
                        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
                        if (this.isNegative()) {
                            if (divisor.isNegative()) return this.neg().div(divisor.neg());
                            return this.neg().div(divisor).neg();
                        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
                        res = ZERO;
                    } else {
                        if (!divisor.unsigned) divisor = divisor.toUnsigned();
                        if (divisor.gt(this)) return UZERO;
                        if (divisor.gt(this.shru(1))) return UONE;
                        res = UZERO;
                    }
                    rem = this;
                    while (rem.gte(divisor)) {
                        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
                        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
                        while (approxRem.isNegative() || approxRem.gt(rem)) {
                            approx -= delta;
                            approxRes = fromNumber(approx, this.unsigned);
                            approxRem = approxRes.mul(divisor);
                        }
                        if (approxRes.isZero()) approxRes = ONE;
                        res = res.add(approxRes);
                        rem = rem.sub(approxRem);
                    }
                    return res;
                };
                LongPrototype.div = LongPrototype.divide;
                LongPrototype.modulo = function modulo(divisor) {
                    if (!isLong(divisor)) divisor = fromValue(divisor);
                    if (wasm) {
                        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
                        return fromBits(low, wasm["get_high"](), this.unsigned);
                    }
                    return this.sub(this.div(divisor).mul(divisor));
                };
                LongPrototype.mod = LongPrototype.modulo;
                LongPrototype.rem = LongPrototype.modulo;
                LongPrototype.not = function not() {
                    return fromBits(~this.low, ~this.high, this.unsigned);
                };
                LongPrototype.countLeadingZeros = function countLeadingZeros() {
                    return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
                };
                LongPrototype.clz = LongPrototype.countLeadingZeros;
                LongPrototype.countTrailingZeros = function countTrailingZeros() {
                    return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
                };
                LongPrototype.ctz = LongPrototype.countTrailingZeros;
                LongPrototype.and = function and(other) {
                    if (!isLong(other)) other = fromValue(other);
                    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
                };
                LongPrototype.or = function or(other) {
                    if (!isLong(other)) other = fromValue(other);
                    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
                };
                LongPrototype.xor = function xor(other) {
                    if (!isLong(other)) other = fromValue(other);
                    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
                };
                LongPrototype.shiftLeft = function shiftLeft(numBits) {
                    if (isLong(numBits)) numBits = numBits.toInt();
                    if ((numBits &= 63) === 0) return this; else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned); else return fromBits(0, this.low << numBits - 32, this.unsigned);
                };
                LongPrototype.shl = LongPrototype.shiftLeft;
                LongPrototype.shiftRight = function shiftRight(numBits) {
                    if (isLong(numBits)) numBits = numBits.toInt();
                    if ((numBits &= 63) === 0) return this; else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned); else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
                };
                LongPrototype.shr = LongPrototype.shiftRight;
                LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
                    if (isLong(numBits)) numBits = numBits.toInt();
                    if ((numBits &= 63) === 0) return this;
                    if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
                    if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
                    return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
                };
                LongPrototype.shru = LongPrototype.shiftRightUnsigned;
                LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
                LongPrototype.rotateLeft = function rotateLeft(numBits) {
                    var b;
                    if (isLong(numBits)) numBits = numBits.toInt();
                    if ((numBits &= 63) === 0) return this;
                    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
                    if (numBits < 32) {
                        b = 32 - numBits;
                        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
                    }
                    numBits -= 32;
                    b = 32 - numBits;
                    return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
                };
                LongPrototype.rotl = LongPrototype.rotateLeft;
                LongPrototype.rotateRight = function rotateRight(numBits) {
                    var b;
                    if (isLong(numBits)) numBits = numBits.toInt();
                    if ((numBits &= 63) === 0) return this;
                    if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
                    if (numBits < 32) {
                        b = 32 - numBits;
                        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
                    }
                    numBits -= 32;
                    b = 32 - numBits;
                    return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
                };
                LongPrototype.rotr = LongPrototype.rotateRight;
                LongPrototype.toSigned = function toSigned() {
                    if (!this.unsigned) return this;
                    return fromBits(this.low, this.high, false);
                };
                LongPrototype.toUnsigned = function toUnsigned() {
                    if (this.unsigned) return this;
                    return fromBits(this.low, this.high, true);
                };
                LongPrototype.toBytes = function toBytes(le) {
                    return le ? this.toBytesLE() : this.toBytesBE();
                };
                LongPrototype.toBytesLE = function toBytesLE() {
                    var hi = this.high, lo = this.low;
                    return [ lo & 255, lo >>> 8 & 255, lo >>> 16 & 255, lo >>> 24, hi & 255, hi >>> 8 & 255, hi >>> 16 & 255, hi >>> 24 ];
                };
                LongPrototype.toBytesBE = function toBytesBE() {
                    var hi = this.high, lo = this.low;
                    return [ hi >>> 24, hi >>> 16 & 255, hi >>> 8 & 255, hi & 255, lo >>> 24, lo >>> 16 & 255, lo >>> 8 & 255, lo & 255 ];
                };
                Long.fromBytes = function fromBytes(bytes, unsigned, le) {
                    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
                };
                Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
                    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
                };
                Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
                    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
                };
                var _default = Long;
                exports.default = _default;
                return "default" in exports ? exports.default : exports;
            }({});
            if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return Long;
            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else {}
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
            return cachedModule.exports;
        }
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        return module.exports;
    }
    var __webpack_exports__ = __webpack_require__("./index.js");
    module.exports = __webpack_exports__;
})();